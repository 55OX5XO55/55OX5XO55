<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#70B7FD"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-space.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-space.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-space.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab-space.svg" color="#70B7FD">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Effective java第三版笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="编程建议">
<meta property="og:url" content="http://example.com/2024/09/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E4%B9%A6%E7%B1%8D/EffectiveJava/%E7%BC%96%E7%A8%8B%E5%BB%BA%E8%AE%AE/index.html">
<meta property="og:site_name" content="space">
<meta property="og:description" content="Effective java第三版笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-09-22T05:51:32.000Z">
<meta property="article:modified_time" content="2024-10-19T14:47:28.053Z">
<meta property="article:author" content="霄剑">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="编程建议">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2024/09/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E4%B9%A6%E7%B1%8D/EffectiveJava/%E7%BC%96%E7%A8%8B%E5%BB%BA%E8%AE%AE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2024/09/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E4%B9%A6%E7%B1%8D/EffectiveJava/%E7%BC%96%E7%A8%8B%E5%BB%BA%E8%AE%AE/","path":"2024/09/22/编程语言/Java/书籍/EffectiveJava/编程建议/","title":"编程建议"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>编程建议 | space</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<script async src="/live2d/autoload.js"> </script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">space</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">16</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">34</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.</span> <span class="nav-text">创建和销毁对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">用静态工厂方法代替构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">1.1.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E7%B1%BB%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">当类需要返回一个特殊的对象的时候</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E7%B1%BB%E9%9C%80%E8%A6%81%E5%A4%8D%E7%94%A8%E4%B9%8B%E5%89%8D%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">当类需要复用之前创建的对象的时候</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">当工具类返回对象的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.1.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E6%97%B6%E8%A6%81%E8%80%83%E8%99%91%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">遇到多个构造器参数时要考虑使用构造器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E5%A4%9A%E4%BD%994%E4%B8%AA%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">构造器参数多余4个的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%BC%BA%E5%8C%96Singleton%E5%B1%9E%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">用私有构造器或枚举类型强化Singleton属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8D%95%E4%BE%8B%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">创建单例类的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="nav-number">1.3.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%BA%E5%8C%96%E4%B8%8D%E5%8F%AF%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">1.4.</span> <span class="nav-text">通过私有构造器强化不可实例化的能力</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">创建工具类的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3"><span class="nav-number">1.4.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%9D%A5%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90"><span class="nav-number">1.5.</span> <span class="nav-text">优先考虑依赖注入来引用资源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93%E7%B1%BBnew%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%94%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%BF%85%E9%A1%BB%E9%80%9A%E8%BF%87%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%89%8D%E8%83%BD%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">当类new一个对象，且这个对象必须通过依赖注入才能进行单元测试的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-4"><span class="nav-number">1.5.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.</span> <span class="nav-text">避免创建不必要的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-5"><span class="nav-number">1.6.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%93new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E7%9C%8B%E8%BF%99%E4%B8%AA%E7%B1%BB%E6%97%B6%E5%80%99%E6%8F%90%E4%BE%9B%E4%BA%86%E7%9B%B8%E5%90%8C%E6%95%88%E6%9E%9C%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%8C%E6%88%96%E8%80%85%E6%98%AF%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">当new一个对象时，看这个类时候提供了相同效果的静态方法，或者是字面量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-5"><span class="nav-number">1.6.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="nav-number">1.7.</span> <span class="nav-text">消除过期的对象引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-6"><span class="nav-number">1.7.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">自己实现集合的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-6"><span class="nav-number">1.7.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95%E5%92%8C%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.</span> <span class="nav-text">避免使用终结方法和清除方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-7"><span class="nav-number">1.8.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99%E9%83%BD%E4%B8%8D%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%80%BB%E7%BB%93%E6%96%B9%E6%B3%95%E5%92%8C%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%E4%B8%8D%E6%98%AF%E6%9C%89%E7%A8%8B%E5%BA%8F%E5%91%98%E7%BC%96%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%9A%84%EF%BC%8C%E8%80%8C%E4%B8%94%E5%AE%83%E4%BB%AC%E9%83%BD%E4%B8%8D%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A2%ABJVM%E8%B0%83%E7%94%A8%E3%80%82%E5%9B%A0%E6%AD%A4%E4%B8%8D%E8%A6%81%E6%9C%9F%E5%BE%85%E7%94%A8%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95%E5%92%8C%E6%B8%85%E9%99%A4%E6%96%B9%E6%B3%95%E6%9D%A5%E6%B8%85%E7%90%86%E8%B5%84%E6%BA%90%EF%BC%8C%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8Java%E7%9A%84final%E6%9C%BA%E5%88%B6"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">任何时候都不要实现总结方法和清除方法，它们的调用时机不是有程序员编程控制的，而且它们都不一定会被JVM调用。因此不要期待用终结方法和清除方法来清理资源，应该使用Java的final机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-7"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-with-resources%E4%BC%98%E5%85%88%E4%BA%8Etry-finally"><span class="nav-number">1.9.</span> <span class="nav-text">try-with-resources优先于try-finally</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-8"><span class="nav-number">1.9.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99try-with-resources%E9%83%BD%E4%BC%98%E5%85%88%E4%BA%8Etry-finally"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">任何时候try-with-resources都优先于try-finally</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-8"><span class="nav-number">1.9.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E9%83%BD%E9%80%9A%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">对所有对象都通用的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96equals%E6%97%B6%E8%AF%B7%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A"><span class="nav-number">2.1.</span> <span class="nav-text">覆盖equals时请遵守通用约定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-9"><span class="nav-number">2.1.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">任何时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-9"><span class="nav-number">2.1.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96equeals%E6%97%B6%E6%80%BB%E8%A6%81%E8%A6%86%E7%9B%96hashcode"><span class="nav-number">2.2.</span> <span class="nav-text">覆盖equeals时总要覆盖hashcode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-10"><span class="nav-number">2.2.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99-1"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">任何时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-10"><span class="nav-number">2.2.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A7%8B%E7%BB%88%E8%A6%81%E8%A6%86%E7%9B%96toString"><span class="nav-number">2.3.</span> <span class="nav-text">始终要覆盖toString</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-11"><span class="nav-number">2.3.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">非静态类和枚举类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-11"><span class="nav-number">2.3.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%A8%E6%85%8E%E5%9C%B0%E8%A6%86%E7%9B%96clone"><span class="nav-number">2.4.</span> <span class="nav-text">谨慎地覆盖clone</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-12"><span class="nav-number">2.4.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99%E9%83%BD%E4%B8%8D%E8%A6%81%E8%80%83%E8%99%91%E8%A6%86%E7%9B%96clone"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">任何时候都不要考虑覆盖clone</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.2.</span> <span class="nav-text">注意实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%80%83%E8%99%91%E5%AE%9E%E7%8E%B0Comparable%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.5.</span> <span class="nav-text">考虑实现Comparable接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-13"><span class="nav-number">2.5.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%80%BC%E7%B1%BB%EF%BC%8C%E9%9C%80%E8%A6%81%E6%9C%89%E6%AF%94%E8%BE%83%E5%8A%9F%E8%83%BD%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">一个值类，需要有比较功能的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-12"><span class="nav-number">2.5.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">接口和类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">使类和成员的可访问性最小化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-14"><span class="nav-number">3.1.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99-2"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">任何时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-13"><span class="nav-number">3.1.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%85%AC%E5%85%B1%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%E8%80%8C%E4%B8%8D%E6%98%AF%E8%AE%BF%E9%97%AE%E5%9F%9F"><span class="nav-number">3.2.</span> <span class="nav-text">在公共类中使用访问方法而不是访问域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-15"><span class="nav-number">3.2.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99-3"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">任何时候</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E5%8F%98%E5%8C%96%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96"><span class="nav-number">3.3.</span> <span class="nav-text">使变化性最小化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-16"><span class="nav-number">3.3.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99-4"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">任何时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-14"><span class="nav-number">3.3.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E4%BC%98%E4%BA%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">3.4.</span> <span class="nav-text">复合优于继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-17"><span class="nav-number">3.4.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99-5"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">任何时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-15"><span class="nav-number">3.4.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%81%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%BB%A7%E6%89%BF%E5%B9%B6%E6%8F%90%E4%BE%9B%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E%EF%BC%8C%E8%A6%81%E4%B9%88%E7%A6%81%E6%AD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">3.5.</span> <span class="nav-text">要么设计继承并提供文档说明，要么禁止继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-18"><span class="nav-number">3.5.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E8%AE%BE%E8%AE%A1%E5%8F%AF%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">自己设计可被继承类的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-16"><span class="nav-number">3.5.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E4%BC%98%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">3.6.</span> <span class="nav-text">接口优于抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-19"><span class="nav-number">3.6.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99-6"><span class="nav-number">3.6.1.1.</span> <span class="nav-text">任何时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-17"><span class="nav-number">3.6.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E5%90%8E%E4%BB%A3%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1%E7%B1%BB%EF%BC%88%E4%B8%8D%E8%A6%81%E8%BD%BB%E6%98%93%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9D%A5%E7%BB%99%E6%8E%A5%E5%8F%A3%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">3.7.</span> <span class="nav-text">为后代接口设计类（不要轻易使用接口的默认方法，来给接口添加新的方法）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-20"><span class="nav-number">3.7.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">3.7.1.1.</span> <span class="nav-text">设计类的时候</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%8F%AA%E7%94%A8%E4%BA%8E%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%8D%E8%A6%81%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="nav-number">3.8.</span> <span class="nav-text">接口只用于定义类型（不要定义常量接口）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-21"><span class="nav-number">3.8.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">3.8.1.1.</span> <span class="nav-text">在创建的接口的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-18"><span class="nav-number">3.8.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%B1%82%E6%AC%A1%E4%BC%98%E4%BA%8E%E6%A0%87%E7%AD%BE%E7%B1%BB"><span class="nav-number">3.9.</span> <span class="nav-text">类层次优于标签类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-22"><span class="nav-number">3.9.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B3%E8%AE%A9%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%8B%A5%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%8A%9F%E8%83%BD%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">3.9.1.1.</span> <span class="nav-text">想让一个类拥有两个类的功能的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-19"><span class="nav-number">3.9.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB%E4%BC%98%E4%BA%8E%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%B1%BB"><span class="nav-number">3.10.</span> <span class="nav-text">静态成员类优于非静态成员类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-23"><span class="nav-number">3.10.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">3.10.1.1.</span> <span class="nav-text">编写嵌套类的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-20"><span class="nav-number">3.10.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%BA%90%E6%96%87%E4%BB%B6%E4%B8%BA%E5%8D%95%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%B1%BB"><span class="nav-number">3.11.</span> <span class="nav-text">限制源文件为单个顶级类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-24"><span class="nav-number">3.11.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">3.11.1.1.</span> <span class="nav-text">创建类的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-21"><span class="nav-number">3.11.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">4.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">请不要使用原生类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-25"><span class="nav-number">4.1.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99-7"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">任何时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-22"><span class="nav-number">4.1.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E9%99%A4%E9%9D%9E%E5%8F%97%E6%A3%80%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="nav-number">4.2.</span> <span class="nav-text">消除非受检的警告</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-26"><span class="nav-number">4.2.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BA%E7%8E%B0%E9%9D%9E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">出现非受检异常的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-23"><span class="nav-number">4.2.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E4%BC%98%E4%BA%8E%E6%95%B0%E7%BB%84"><span class="nav-number">4.3.</span> <span class="nav-text">列表优于数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-27"><span class="nav-number">4.3.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B3%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">想使用数组的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-24"><span class="nav-number">4.3.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E6%B3%9B%E5%9E%8B"><span class="nav-number">4.4.</span> <span class="nav-text">优先考虑泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-28"><span class="nav-number">4.4.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%8F%AF%E4%BB%A5%E9%80%82%E7%94%A8%E4%BA%8E%E7%B1%BB%E5%9E%8B%E6%97%A0%E5%85%B3%E7%9A%84%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">编写可以适用于类型无关的类的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-25"><span class="nav-number">4.4.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">优先考虑泛型方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-29"><span class="nav-number">4.5.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%97%A0%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">编写与类型无关的方法的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-26"><span class="nav-number">4.5.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E6%9C%89%E9%99%90%E5%88%B6%E9%80%9A%E9%85%8D%E7%AC%A6%E6%9D%A5%E6%8F%90%E5%8D%87API%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="nav-number">4.6.</span> <span class="nav-text">利用有限制通配符来提升API的灵活性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-30"><span class="nav-number">4.6.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E6%97%B6"><span class="nav-number">4.6.1.1.</span> <span class="nav-text">编写泛型类的方法和静态泛型方法时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-27"><span class="nav-number">4.6.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%A8%E6%85%8E%E5%B9%B6%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">4.7.</span> <span class="nav-text">谨慎并用泛型和可变参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-31"><span class="nav-number">4.7.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E5%B8%A6%E6%9C%89%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">4.7.1.1.</span> <span class="nav-text">编写带有可变参数的泛型方法的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-28"><span class="nav-number">4.7.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%BC%82%E6%9E%84%E5%AE%B9%E5%99%A8"><span class="nav-number">4.8.</span> <span class="nav-text">优先考虑类型安全的异构容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-32"><span class="nav-number">4.8.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E9%9C%80%E8%A6%81%E5%90%8C%E6%97%B6%E5%AD%98%E5%82%A8%E4%BB%BB%E6%84%8F%E7%A7%8D%E7%B1%BB%E5%9E%8B%E6%97%B6"><span class="nav-number">4.8.1.1.</span> <span class="nav-text">一个容器需要同时存储任意种类型时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-29"><span class="nav-number">4.8.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="nav-number">5.</span> <span class="nav-text">枚举和注解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8enum%E4%BB%A3%E6%9B%BFint%E5%B8%B8%E9%87%8F"><span class="nav-number">5.1.</span> <span class="nav-text">用enum代替int常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-33"><span class="nav-number">5.1.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B3%E5%AE%9A%E4%B9%89%E4%B8%80%E7%BB%84%E6%9C%89%E5%85%B3%E7%B3%BB%E4%B8%94%E6%95%B0%E9%87%8F%E6%9C%89%E9%99%90%E7%9A%84%E5%B8%B8%E9%87%8F%E6%97%B6"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">想定义一组有关系且数量有限的常量时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-30"><span class="nav-number">5.1.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%AD%97%E6%AE%B5%E4%BB%A3%E6%9B%BF%E5%BA%8F%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">使用实例字段代替序数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-34"><span class="nav-number">5.2.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E5%88%97%E4%B8%BE%E4%B8%80%E7%BB%84%E5%9B%BA%E5%AE%9A%E7%9A%84%E6%95%B0%E5%AD%97%E6%97%B6"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">需要列举一组固定的数字时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-31"><span class="nav-number">5.2.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8EnumSet%E4%BB%A3%E6%9B%BF%E4%BD%8D%E5%9F%9F"><span class="nav-number">5.3.</span> <span class="nav-text">使用EnumSet代替位域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-35"><span class="nav-number">5.3.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%9F%9F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">任何使用位域的地方</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-32"><span class="nav-number">5.3.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8EnumMap%E4%BB%A3%E6%9B%BF%E5%BA%8F%E6%95%B0%E7%B4%A2%E5%BC%95"><span class="nav-number">5.4.</span> <span class="nav-text">用EnumMap代替序数索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-36"><span class="nav-number">5.4.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B3%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%9A%84ordinal%E5%80%BC%E4%BD%9C%E4%B8%BA%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">5.4.1.1.</span> <span class="nav-text">想使用枚举的ordinal值作为数组索引的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-33"><span class="nav-number">5.4.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%A8%A1%E6%8B%9F%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="nav-number">5.5.</span> <span class="nav-text">用接口模拟可扩展的枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-37"><span class="nav-number">5.5.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">没有使用的地方</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-34"><span class="nav-number">5.5.2.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E4%BC%98%E5%85%88%E4%BA%8E%E5%91%BD%E5%90%8D%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.5.3.</span> <span class="nav-text">注解优先于命名模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-38"><span class="nav-number">5.5.3.1.</span> <span class="nav-text">使用时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B3%E7%BB%99%E6%9F%90%E4%B8%AA%E7%B1%BB%EF%BC%8C%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AD%97%E6%AE%B5%EF%BC%8C%E5%8F%82%E6%95%B0%E5%8A%A0%E4%B8%8A%E5%85%B6%E4%BB%96%E4%BF%A1%E6%81%AF"><span class="nav-number">5.5.3.2.</span> <span class="nav-text">想给某个类，方法，字段，参数加上其他信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-35"><span class="nav-number">5.5.4.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9D%9A%E6%8C%81%E4%BD%BF%E7%94%A8Override%E6%B3%A8%E8%A7%A3"><span class="nav-number">5.6.</span> <span class="nav-text">坚持使用Override注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-39"><span class="nav-number">5.6.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E6%83%B3%E8%A6%86%E7%9B%96%E8%B6%85%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">5.6.1.1.</span> <span class="nav-text">子类想覆盖超类方法的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-36"><span class="nav-number">5.6.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.7.</span> <span class="nav-text">用标记接口定义类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-40"><span class="nav-number">5.7.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B3%E8%A6%81%E6%A0%87%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%97%B6%EF%BC%8C%E6%9B%B4%E5%85%B7%E4%BD%93%E7%9A%84%E6%98%AF%E6%AD%A3%E5%9C%A8%E7%BC%96%E5%86%99ElementType-Type%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A0%87%E8%AE%B0%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">5.7.1.1.</span> <span class="nav-text">想要标记一个类时，更具体的是正在编写ElementType.Type类型的标记注解的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-37"><span class="nav-number">5.7.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda%E5%92%8CStream"><span class="nav-number">6.</span> <span class="nav-text">Lambda和Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda%E4%BC%98%E5%85%88%E4%BA%8E%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="nav-number">6.1.</span> <span class="nav-text">Lambda优先于匿名类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-41"><span class="nav-number">6.1.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BF%E5%90%8D%E7%B1%BB%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">6.1.1.1.</span> <span class="nav-text">实现单个方法的匿名类的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-38"><span class="nav-number">6.1.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%BC%98%E4%BA%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">方法引用优于Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-42"><span class="nav-number">6.2.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%B3%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%97%B6"><span class="nav-number">6.2.1.1.</span> <span class="nav-text">想使用Lambda表达式时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-39"><span class="nav-number">6.2.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9D%9A%E6%8C%81%E4%BD%BF%E7%94%A8%E6%A0%87%E5%87%86%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number">6.3.</span> <span class="nav-text">坚持使用标准的函数接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-43"><span class="nav-number">6.3.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%B7%B1%E6%83%B3%E5%A3%B0%E6%98%8E%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">6.3.1.1.</span> <span class="nav-text">自己想声明函数接口的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-40"><span class="nav-number">6.3.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8Stream"><span class="nav-number">6.4.</span> <span class="nav-text">谨慎使用Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-44"><span class="nav-number">6.4.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E6%9F%90%E4%BA%9B%E7%89%B9%E5%88%AB%E5%BE%88%E9%9A%BE%E7%90%86%E8%A7%A3%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C%E6%97%B6"><span class="nav-number">6.4.1.1.</span> <span class="nav-text">编写某些特别很难理解的流操作时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-41"><span class="nav-number">6.4.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%80%89%E6%8B%A9Stream%E4%B8%AD%E6%97%A0%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">6.5.</span> <span class="nav-text">优先选择Stream中无副作用的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-45"><span class="nav-number">6.5.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Steam%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99"><span class="nav-number">6.5.1.1.</span> <span class="nav-text">使用Steam进行编程的时候</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-42"><span class="nav-number">6.5.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream%E8%A6%81%E4%BC%98%E5%85%88%E7%94%A8Collection%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.6.</span> <span class="nav-text">Stream要优先用Collection作为返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-46"><span class="nav-number">6.6.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%B5%81%E8%BF%94%E5%9B%9E%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%E6%97%B6"><span class="nav-number">6.6.1.1.</span> <span class="nav-text">需要流返回元素序列时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-43"><span class="nav-number">6.6.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8Stream%E5%B9%B6%E8%A1%8C"><span class="nav-number">6.7.</span> <span class="nav-text">谨慎使用Stream并行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA-47"><span class="nav-number">6.7.1.</span> <span class="nav-text">使用时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E4%BD%95%E6%97%B6%E5%80%99%E9%83%BD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8Stream%E4%B8%AD%E7%9A%84%E5%B9%B6%E8%A1%8C"><span class="nav-number">6.7.1.1.</span> <span class="nav-text">任何时候都不要使用Stream中的并行</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-44"><span class="nav-number">6.7.2.</span> <span class="nav-text">注意事项</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="霄剑"
      src="/images/avatar.svg">
  <p class="site-author-name" itemprop="name">霄剑</p>
  <div class="site-description" itemprop="description">醉后不知天在水,满船清梦压星河</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/55OX5XO55" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;55OX5XO55" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2606863445@qq.com" title="E-Mail → 2606863445@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/09/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E4%B9%A6%E7%B1%8D/EffectiveJava/%E7%BC%96%E7%A8%8B%E5%BB%BA%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="编程建议 | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编程建议
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-22 13:51:32" itemprop="dateCreated datePublished" datetime="2024-09-22T13:51:32+08:00">2024-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-19 22:47:28" itemprop="dateModified" datetime="2024-10-19T22:47:28+08:00">2024-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Effective java第三版笔记</p>
<span id="more"></span>

<h1 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h1><h2 id="用静态工厂方法代替构造器"><a href="#用静态工厂方法代替构造器" class="headerlink" title="用静态工厂方法代替构造器"></a>用静态工厂方法代替构造器</h2><h3 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="当类需要返回一个特殊的对象的时候"><a href="#当类需要返回一个特殊的对象的时候" class="headerlink" title="当类需要返回一个特殊的对象的时候"></a>当类需要返回一个特殊的对象的时候</h4><p>例如需要<code>Integer</code>返回一个质数, 光靠构造器名称很难表达返回质数的意图, 但是静态工厂方法可以取方法名, 表明返回质数的意图</p>
<h4 id="当类需要复用之前创建的对象的时候"><a href="#当类需要复用之前创建的对象的时候" class="headerlink" title="当类需要复用之前创建的对象的时候"></a>当类需要复用之前创建的对象的时候</h4><p>调用构造器如果不报错, 必定会创建一个新的对象. 如果想返回一个之前创建的对象, 只能使用静态方法, 这也是实现单例模式的前提</p>
<h4 id="当工具类返回对象的时候"><a href="#当工具类返回对象的时候" class="headerlink" title="当工具类返回对象的时候"></a>当工具类返回对象的时候</h4><p>工具类例如<code>Driver.getConnect()</code>, Collections.list()&#96;, 这些都是静态方法</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>使用静态方法时, 尽量不要使静态方法依赖底层资源, 应该通过依赖注入的方法处理</li>
</ol>
<h2 id="遇到多个构造器参数时要考虑使用构造器"><a href="#遇到多个构造器参数时要考虑使用构造器" class="headerlink" title="遇到多个构造器参数时要考虑使用构造器"></a>遇到多个构造器参数时要考虑使用构造器</h2><h3 id="使用时机-1"><a href="#使用时机-1" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="构造器参数多余4个的时候"><a href="#构造器参数多余4个的时候" class="headerlink" title="构造器参数多余4个的时候"></a>构造器参数多余4个的时候</h4><p>问题的本质在于参数过多, 可以把多个参数打包放入一个类中, 一次传递. 这个对于非构造方法也是通用的. </p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>如果一个类不需要保证有效性, 直接使用set方法设置值也是可以的. 例如用于参数传递的类(Builder), 它们的效性就是无关紧要的, 用的就是set方法来设置值. 对于需要保证有效性的类, 建议使用构造器模式</li>
</ol>
<h2 id="用私有构造器或枚举类型强化Singleton属性"><a href="#用私有构造器或枚举类型强化Singleton属性" class="headerlink" title="用私有构造器或枚举类型强化Singleton属性"></a>用私有构造器或枚举类型强化Singleton属性</h2><h3 id="使用时机-2"><a href="#使用时机-2" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="创建单例类的时候"><a href="#创建单例类的时候" class="headerlink" title="创建单例类的时候"></a>创建单例类的时候</h4><p>使用单例模式时, 必须私有化构造器, 这是显然的, 不需要解释</p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>优先使用静态域来构建单例模式, 它比枚举更具有通用性</li>
</ol>
<h2 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h2><h3 id="使用时机-3"><a href="#使用时机-3" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="创建工具类的时候"><a href="#创建工具类的时候" class="headerlink" title="创建工具类的时候"></a>创建工具类的时候</h4><p>工具类不应该有实例, 所以一定要私有化构造器, 防止被别人误用创建出实例</p>
<h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><p>抽象类虽然不能被实例化, 但是它的子类可以被实例化, 因此使用抽象类来创建工具类不合适. 抽象类就是用来解决复用的</p>
<h2 id="优先考虑依赖注入来引用资源"><a href="#优先考虑依赖注入来引用资源" class="headerlink" title="优先考虑依赖注入来引用资源"></a>优先考虑依赖注入来引用资源</h2><h3 id="使用时机-4"><a href="#使用时机-4" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="当类new一个对象，且这个对象必须通过依赖注入才能进行单元测试的时候"><a href="#当类new一个对象，且这个对象必须通过依赖注入才能进行单元测试的时候" class="headerlink" title="当类new一个对象，且这个对象必须通过依赖注入才能进行单元测试的时候"></a>当类new一个对象，且这个对象必须通过依赖注入才能进行单元测试的时候</h4><p>当new一个对象的时候，考虑这个对象是否需要进行mock，如果不需要就new，如果必须要进行mock，则通过依赖注入的方式来使用</p>
<h3 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>依赖注入还可以注入依赖对象的工厂方法类，这样被注入的类这一自己创建对象</li>
</ol>
<h2 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h2><h3 id="使用时机-5"><a href="#使用时机-5" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="当new一个对象时，看这个类时候提供了相同效果的静态方法，或者是字面量"><a href="#当new一个对象时，看这个类时候提供了相同效果的静态方法，或者是字面量" class="headerlink" title="当new一个对象时，看这个类时候提供了相同效果的静态方法，或者是字面量"></a>当new一个对象时，看这个类时候提供了相同效果的静态方法，或者是字面量</h4><p>new一定会创建一个新对象，对于某些不可变对象来说，非常浪费，这时使用静态方法，类的实现者可以实现对象的复用</p>
<h3 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>当使用包装类进行计算时，也会创建很多不必要的对象，所以优先使用基本类型</li>
</ol>
<h2 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h2><h3 id="使用时机-6"><a href="#使用时机-6" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="自己实现集合的时候"><a href="#自己实现集合的时候" class="headerlink" title="自己实现集合的时候"></a>自己实现集合的时候</h4><p>自己实现集合的时候，从集合中删除元素后，自己没有将元素的引用设置为null，存在过期引用</p>
<h3 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>这说明java也是会存在内存泄漏的</li>
<li>weakhashmap可以用来实现一个不用自己手动清理过期引用的缓存</li>
<li>注册回调函数，但客户端不取消注册，也会导致服务端内存泄漏</li>
</ol>
<h2 id="避免使用终结方法和清除方法"><a href="#避免使用终结方法和清除方法" class="headerlink" title="避免使用终结方法和清除方法"></a>避免使用终结方法和清除方法</h2><h3 id="使用时机-7"><a href="#使用时机-7" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候都不要实现总结方法和清除方法，它们的调用时机不是有程序员编程控制的，而且它们都不一定会被JVM调用。因此不要期待用终结方法和清除方法来清理资源，应该使用Java的final机制"><a href="#任何时候都不要实现总结方法和清除方法，它们的调用时机不是有程序员编程控制的，而且它们都不一定会被JVM调用。因此不要期待用终结方法和清除方法来清理资源，应该使用Java的final机制" class="headerlink" title="任何时候都不要实现总结方法和清除方法，它们的调用时机不是有程序员编程控制的，而且它们都不一定会被JVM调用。因此不要期待用终结方法和清除方法来清理资源，应该使用Java的final机制"></a>任何时候都不要实现总结方法和清除方法，它们的调用时机不是有程序员编程控制的，而且它们都不一定会被JVM调用。因此不要期待用终结方法和清除方法来清理资源，应该使用Java的final机制</h4><p>终结方法和清除方法存在的另外一个问题是，对于任何对象，哪怕在构造器中抛出异常的对象，在被JVM回收时，都会调用终结方法。这样就可以构造出一种攻击手段，在终结方法种调用构造失败的对象的方法，调用这种对象的方法是非常危险的</p>
<h4 id="注意事项-7"><a href="#注意事项-7" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>清除方法石java9中的特性</li>
<li>在任何时候都不要使用终结方法和清除方法，哪怕是把它们作为资源回收的保底机制也不要使用</li>
</ol>
<h2 id="try-with-resources优先于try-finally"><a href="#try-with-resources优先于try-finally" class="headerlink" title="try-with-resources优先于try-finally"></a>try-with-resources优先于try-finally</h2><h3 id="使用时机-8"><a href="#使用时机-8" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候try-with-resources都优先于try-finally"><a href="#任何时候try-with-resources都优先于try-finally" class="headerlink" title="任何时候try-with-resources都优先于try-finally"></a>任何时候try-with-resources都优先于try-finally</h4><p>因为try和finnally都有可能抛出异常，如果两个地方都抛出了异常，finnally的异常会覆盖try里面的异常，而try里面的异常通常才是根本原因</p>
<h3 id="注意事项-8"><a href="#注意事项-8" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>如果要使用try-with-resources机制，必须要实现autocloseable接口，Java类库里需要关闭资源的类应该都已经实现了这个接口，可以直接使用这个机制</li>
<li>try-with-resources优先抛出try里面的异常，但close里面的异常也是会被记录的，而try-finnaly只会有finnally里面的异常</li>
</ol>
<h1 id="对所有对象都通用的方法"><a href="#对所有对象都通用的方法" class="headerlink" title="对所有对象都通用的方法"></a>对所有对象都通用的方法</h1><h2 id="覆盖equals时请遵守通用约定"><a href="#覆盖equals时请遵守通用约定" class="headerlink" title="覆盖equals时请遵守通用约定"></a>覆盖equals时请遵守通用约定</h2><h3 id="使用时机-9"><a href="#使用时机-9" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候"><a href="#任何时候" class="headerlink" title="任何时候"></a>任何时候</h4><p>自己实现的类需要有逻辑相等的要求，但这时父类的equals并不满足要求，这时候就要自己手动实现equals方法。注意这时就不要使用继承了，使用组合来代替继承，自己来返回一个视图，equeals用instanceof来实现</p>
<h3 id="注意事项-9"><a href="#注意事项-9" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>equals一定不要和非本类或父类之外的其他类进行比较，这样肯定会违反equals的对称约束</li>
<li>覆盖父类（非Object）的equeals（instanceof）会违反对称性，覆盖父类（非Object）的equeals（getClass），子类很容易违反里氏替换原则</li>
<li>不要重写非Object父类的equeals方法，如果要实现逻辑相等的功能，使用复合+视图的方式</li>
</ol>
<h2 id="覆盖equeals时总要覆盖hashcode"><a href="#覆盖equeals时总要覆盖hashcode" class="headerlink" title="覆盖equeals时总要覆盖hashcode"></a>覆盖equeals时总要覆盖hashcode</h2><h3 id="使用时机-10"><a href="#使用时机-10" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候-1"><a href="#任何时候-1" class="headerlink" title="任何时候"></a>任何时候</h4><p>重写equeals方法时。保证hashcode用的域和equeals里面的域一致，少了增大了hash碰撞的可能性，降低效率；多了会让该对象在hashmap和hashset中运行出现问题<br>如果这个类为不可变类，且是为了在hash类集合里作为键，可以选择在创建或第一调用hashcode方法时，将hashcode缓存下来。</p>
<h3 id="注意事项-10"><a href="#注意事项-10" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>hashcode相当于equeals的提前过滤</li>
</ol>
<h2 id="始终要覆盖toString"><a href="#始终要覆盖toString" class="headerlink" title="始终要覆盖toString"></a>始终要覆盖toString</h2><h3 id="使用时机-11"><a href="#使用时机-11" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="非静态类和枚举类"><a href="#非静态类和枚举类" class="headerlink" title="非静态类和枚举类"></a>非静态类和枚举类</h4><p>toString，会在“+”，print当中被自动调用，可以让类使用起来更舒适，静态类不需要，枚举类则是枚举类型自己实现了一个toString方法</p>
<h3 id="注意事项-11"><a href="#注意事项-11" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>toString中打印一些需要对外展示的东西就行了</li>
<li>对于值类，如果可以考虑将toString的格式固定，同时提供一个静态方法将String转回对象。如果格式是固定的，请在方法说明中，指明这是一个固定格式，如果不是固定的，也请指明这个格式不是固定的</li>
<li>对toString打印的值，提供可访问的方法，不然别人也只能假设toString的格式，通过toString来获得值</li>
</ol>
<h2 id="谨慎地覆盖clone"><a href="#谨慎地覆盖clone" class="headerlink" title="谨慎地覆盖clone"></a>谨慎地覆盖clone</h2><h3 id="使用时机-12"><a href="#使用时机-12" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候都不要考虑覆盖clone"><a href="#任何时候都不要考虑覆盖clone" class="headerlink" title="任何时候都不要考虑覆盖clone"></a>任何时候都不要考虑覆盖clone</h4><p>java中clone，是一种特殊的机制，和反序列化一样可以绕过构造器。如果需要实现clone的效果，建议使用静态工厂方法。因为clone是依赖了语言外的创建对象机制，同时clone无法设置final域。</p>
<h3 id="注意实现"><a href="#注意实现" class="headerlink" title="注意实现"></a>注意实现</h3><ol>
<li>尽量不要把接口当作标记接口来使用，但是如果确实要用于编译期识别类，那也没有办法</li>
<li>不要在构造方法中，调用可被重写的方法，因为这时有可能调用到子类的方法，而这时子类的状态还处于不一致状态</li>
<li>覆写方法的访问可以大于父类</li>
</ol>
<h2 id="考虑实现Comparable接口"><a href="#考虑实现Comparable接口" class="headerlink" title="考虑实现Comparable接口"></a>考虑实现Comparable接口</h2><h3 id="使用时机-13"><a href="#使用时机-13" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="一个值类，需要有比较功能的时候"><a href="#一个值类，需要有比较功能的时候" class="headerlink" title="一个值类，需要有比较功能的时候"></a>一个值类，需要有比较功能的时候</h4><p>通过实现comparable接口，可以让这个类就可以利用Java类库中于此接口相关的算法和集合进行操作</p>
<h3 id="注意事项-12"><a href="#注意事项-12" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>违反hashcode会使其无法正常使用依赖hashcode的类，而违反comparable约定，会无法正常使用依赖comparable接口的类</li>
<li>一个值类继承父类后，如果覆写了父类的compareTo和equeals，则无法遵守compareTo和equals的约定，所以应该利用组合的方式来实现comparable</li>
<li>在compareTo返回0应该保持与equeals方法等价，这样可以避免算法之间的差异，例如hashSet和TreeSet，它们都可以去重，如果compareTo&#x3D;0时不与equeals等价，它们的去重后的接口会不一样</li>
<li>实现compareTo或compare时，针对基本类型和包装类型，不用使用-，&lt;, &gt;等操作符，利用包装类的比较方法，这样可以避免溢出和浮点数误差带来的错误结果</li>
<li>java8提供快速创建比较器的方法comparingInt，comparingLong等等，但是这样创建的比较器，性能会慢10%左右，建议自己不要使用，比较器自己实现有不难，使用高级特性还会导致别人阅读起来更麻烦</li>
</ol>
<h1 id="接口和类"><a href="#接口和类" class="headerlink" title="接口和类"></a>接口和类</h1><h2 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h2><h3 id="使用时机-14"><a href="#使用时机-14" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候-2"><a href="#任何时候-2" class="headerlink" title="任何时候"></a>任何时候</h4><p>访问权限最小化，可以让类的使用者可以了解更少的知识，就能使用这个类。同时，让类的开发者也有足够的灵活性去修改这个类<br>如何保证一个类是可控的，让所有实例和静态域都变成私有的，除了静态常量，只有静态常量可以设置为public</p>
<h3 id="注意事项-13"><a href="#注意事项-13" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>访问性可以分为两种，对外不暴露的和对外暴露的。私有的和包级私有的是不对外暴露的，保护的和公共的是对外暴露的</li>
</ol>
<h2 id="在公共类中使用访问方法而不是访问域"><a href="#在公共类中使用访问方法而不是访问域" class="headerlink" title="在公共类中使用访问方法而不是访问域"></a>在公共类中使用访问方法而不是访问域</h2><h3 id="使用时机-15"><a href="#使用时机-15" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候-3"><a href="#任何时候-3" class="headerlink" title="任何时候"></a>任何时候</h4><p>只有这样可以保证这个类的状态，始终是在开发者的可控范围之类的</p>
<h2 id="使变化性最小化"><a href="#使变化性最小化" class="headerlink" title="使变化性最小化"></a>使变化性最小化</h2><h3 id="使用时机-16"><a href="#使用时机-16" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候-4"><a href="#任何时候-4" class="headerlink" title="任何时候"></a>任何时候</h4><p>使类的变化性最小化，最好是不可变对象，一个类能反生变化越小，使用起来越简单<br>不可变对象有很多优点，1. 不可变对象是线程安全的；2. 不可变对象可以被自由的共享；3. 不可变对象状态比较简单，使用使用时不必在意它现在的状态</p>
<h3 id="注意事项-14"><a href="#注意事项-14" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>不可变对象应该考虑提供静态方法，来尽可能复用现有的实例</li>
<li>唯一的缺点，任何一个小改动，都会创建一个新对象，从而带来性能上的问题，这时可以考虑提供一个可变的配套类，就像String和StringBuilder一样</li>
<li>不给变类要是final的，或者构造器私有的，否则别人可以用一个恶意的可变子类来充当不可变父类，使用者依然以为是不可变类，但实际上这个类是可以改变的</li>
</ol>
<h2 id="复合优于继承"><a href="#复合优于继承" class="headerlink" title="复合优于继承"></a>复合优于继承</h2><h3 id="使用时机-17"><a href="#使用时机-17" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候-5"><a href="#任何时候-5" class="headerlink" title="任何时候"></a>任何时候</h4><p>子类和父类的关系太紧密，父类失去了添加新方法的能力和修改已实现方法内部细节的能力，而复合的方式，添加方法和修改方法细节就没有问题</p>
<h3 id="注意事项-15"><a href="#注意事项-15" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>继承就是为了解决复用问题，但是继承不如复合灵活</li>
<li>覆写方法时，光靠父类方法的调用约定是无法写出正确的子类方法的，子类必须知道父类如何实现改方法时，才有可能写对，但这就破坏了父类的封装性</li>
<li>因为能覆写方法，父类调用的方法就不再受父类开发者控制了，打破了类的封装</li>
<li>因为构造器不能被继承，如果用继承的方式来扩展类，子类有可能需要自己来实现构造器，使用组合就没有这个问题</li>
</ol>
<h2 id="要么设计继承并提供文档说明，要么禁止继承"><a href="#要么设计继承并提供文档说明，要么禁止继承" class="headerlink" title="要么设计继承并提供文档说明，要么禁止继承"></a>要么设计继承并提供文档说明，要么禁止继承</h2><h3 id="使用时机-18"><a href="#使用时机-18" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="自己设计可被继承类的时候"><a href="#自己设计可被继承类的时候" class="headerlink" title="自己设计可被继承类的时候"></a>自己设计可被继承类的时候</h4><p>文档需要写出覆盖每个方法带来的影响，如果有影响，需要用@implSpec说明。其实也只有使用模版方法设计模式的时候，才有可能需要设计可以被继承的类，其他的时候，都可以用组合来解决。</p>
<h3 id="注意事项-16"><a href="#注意事项-16" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>构造器不要调用可以被覆盖的方法</li>
<li>为了继承而设计的类，因为公开了实现说明，这个类的修改就很受限制</li>
<li>一个类一定要为自己的功能实现一个接口，使用已有的或自己设计的都行，不然组合实现的类没办法实现多态特性</li>
</ol>
<h2 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h2><h3 id="使用时机-19"><a href="#使用时机-19" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候-6"><a href="#任何时候-6" class="headerlink" title="任何时候"></a>任何时候</h4><p>抽象类除了可以具有实例属性，来实现某些实例方法外，相较接口没有任何优势，其实没必要编写抽象类和继承，除了使用模版方法的时候</p>
<h3 id="注意事项-17"><a href="#注意事项-17" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>如果一个接口方法跟其他的接口方法有强关联，可以考虑用默认方法，但是要加上@implSpec注解</li>
<li>接口和抽象类完全就是两个东西，拿来比较是没有任何意义的</li>
<li>模版方法中父类被称为骨架类，这个父类通常是抽象的，用来实现代码复用。对于一个重要的接口，可以考虑实现它的骨架类，并且实现该接口的一个基本实现，这个基本实现可以继承这个骨架类</li>
</ol>
<h2 id="为后代接口设计类（不要轻易使用接口的默认方法，来给接口添加新的方法）"><a href="#为后代接口设计类（不要轻易使用接口的默认方法，来给接口添加新的方法）" class="headerlink" title="为后代接口设计类（不要轻易使用接口的默认方法，来给接口添加新的方法）"></a>为后代接口设计类（不要轻易使用接口的默认方法，来给接口添加新的方法）</h2><h3 id="使用时机-20"><a href="#使用时机-20" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="设计类的时候"><a href="#设计类的时候" class="headerlink" title="设计类的时候"></a>设计类的时候</h4><p>尽量不要使用给接口增加方法，这样会导致某些实现使用这些方法出现问题。就算要为接口添加新方法，要慎重考虑对实现的影响</p>
<h2 id="接口只用于定义类型（不要定义常量接口）"><a href="#接口只用于定义类型（不要定义常量接口）" class="headerlink" title="接口只用于定义类型（不要定义常量接口）"></a>接口只用于定义类型（不要定义常量接口）</h2><h3 id="使用时机-21"><a href="#使用时机-21" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="在创建的接口的时候"><a href="#在创建的接口的时候" class="headerlink" title="在创建的接口的时候"></a>在创建的接口的时候</h4><p>这时应该用工具类来实现常量，如果常量是可枚举的，可以使用枚举类型</p>
<h3 id="注意事项-18"><a href="#注意事项-18" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>常量接口是指只有常量，没有方法的接口</li>
<li>这条建议不是说接口中不要定义常量，而是不要只定义常量，如果这个常量更接口中的方法有关，是可以定义的</li>
</ol>
<h2 id="类层次优于标签类"><a href="#类层次优于标签类" class="headerlink" title="类层次优于标签类"></a>类层次优于标签类</h2><h3 id="使用时机-22"><a href="#使用时机-22" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="想让一个类拥有两个类的功能的时候"><a href="#想让一个类拥有两个类的功能的时候" class="headerlink" title="想让一个类拥有两个类的功能的时候"></a>想让一个类拥有两个类的功能的时候</h4><p>应该使用继承，或者接口+组合的方式来代替标签类</p>
<h3 id="注意事项-19"><a href="#注意事项-19" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>标签类这种东西是为了给不支持多态的编程语言的一种解决方法，在java中不因该使用这种东西</li>
</ol>
<h2 id="静态成员类优于非静态成员类"><a href="#静态成员类优于非静态成员类" class="headerlink" title="静态成员类优于非静态成员类"></a>静态成员类优于非静态成员类</h2><h3 id="使用时机-23"><a href="#使用时机-23" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="编写嵌套类的时候"><a href="#编写嵌套类的时候" class="headerlink" title="编写嵌套类的时候"></a>编写嵌套类的时候</h4><p>静态成员类优于非静态成员类的主要原因是非静态成员类会降低性能</p>
<h3 id="注意事项-20"><a href="#注意事项-20" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>java有四种嵌套类，静态成员类，非静态成员类，匿名类和局部类，后面三种属于内部类，可以有外部类实例的引用</li>
<li>什么时候用嵌套类，当一个类必须和另外一个类同时使用时，这个类可以定义为嵌套类。嵌套类对于编程语言来说，并不是必须的，作为一种可有可无的特性吧</li>
</ol>
<h2 id="限制源文件为单个顶级类"><a href="#限制源文件为单个顶级类" class="headerlink" title="限制源文件为单个顶级类"></a>限制源文件为单个顶级类</h2><h3 id="使用时机-24"><a href="#使用时机-24" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="创建类的时候"><a href="#创建类的时候" class="headerlink" title="创建类的时候"></a>创建类的时候</h4><p>保证.java文件中只有一个顶级类</p>
<h3 id="注意事项-21"><a href="#注意事项-21" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>java允许一个源文件中定义多个顶级类，这样会让源文件和类定义的关系变得混乱，所以根本没有必要</li>
</ol>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="请不要使用原生类型"><a href="#请不要使用原生类型" class="headerlink" title="请不要使用原生类型"></a>请不要使用原生类型</h2><h3 id="使用时机-25"><a href="#使用时机-25" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候-7"><a href="#任何时候-7" class="headerlink" title="任何时候"></a>任何时候</h4><p>泛型可以让程序更健壮和清楚，避免放入错误的类型和取出时的强制转型</p>
<h3 id="注意事项-22"><a href="#注意事项-22" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>原生类型就是不带类型参数的类型，例如List<E>的原生类型就是List</li>
<li><?>不允许除null之外的任何东西放入</li>
</ol>
<h2 id="消除非受检的警告"><a href="#消除非受检的警告" class="headerlink" title="消除非受检的警告"></a>消除非受检的警告</h2><h3 id="使用时机-26"><a href="#使用时机-26" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="出现非受检异常的时候"><a href="#出现非受检异常的时候" class="headerlink" title="出现非受检异常的时候"></a>出现非受检异常的时候</h4><p>非受检警告指明了运行时可能出现的问题，如果确定运行时不会出现问题，应该使用@SuppressWarnings(“unchecked”)来消除警告，同时通过注释指明它为什么不会出现问题</p>
<h3 id="注意事项-23"><a href="#注意事项-23" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>getClass()是方法，是运行时才能获得信息，编译器是无法得到，只会把它当作是Object</li>
<li>应该在尽可能小的范围内使用@SuppressWarnings(“unchecked”)</li>
</ol>
<h2 id="列表优于数组"><a href="#列表优于数组" class="headerlink" title="列表优于数组"></a>列表优于数组</h2><h3 id="使用时机-27"><a href="#使用时机-27" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="想使用数组的时候"><a href="#想使用数组的时候" class="headerlink" title="想使用数组的时候"></a>想使用数组的时候</h4><p>泛型列表比数组更安全</p>
<h3 id="注意事项-24"><a href="#注意事项-24" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>数组在运行时知道它的具体类型，Object[] objects &#x3D; new Long[10]; 你无法将一个String放入到objects中，会报ArrayStoreException，这个有点像多态。泛型只在编译期知道类型，在运行时，是不知道类型的，变成了Object，类型的具体信息被擦除了 </li>
<li>在泛型类里，泛型参数全部都是Object，字节码是这样的，只有在被取出时，才进行了强转</li>
</ol>
<h2 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h2><h3 id="使用时机-28"><a href="#使用时机-28" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="编写可以适用于类型无关的类的时候"><a href="#编写可以适用于类型无关的类的时候" class="headerlink" title="编写可以适用于类型无关的类的时候"></a>编写可以适用于类型无关的类的时候</h4><p>泛型可以让使用者避免强制类型转换，同时也避免放入错误的类型</p>
<h3 id="注意事项-25"><a href="#注意事项-25" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>并非任何时候列表都能取代数组，数组和链表是计算机中最基本的元素，是数据结构的基础。例如某些List就是数组实现的。需要极高性能的时候，使用数组也是可以的</li>
</ol>
<h2 id="优先考虑泛型方法"><a href="#优先考虑泛型方法" class="headerlink" title="优先考虑泛型方法"></a>优先考虑泛型方法</h2><h3 id="使用时机-29"><a href="#使用时机-29" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="编写与类型无关的方法的时候"><a href="#编写与类型无关的方法的时候" class="headerlink" title="编写与类型无关的方法的时候"></a>编写与类型无关的方法的时候</h4><p>泛型方法避免了调用者的类型转换</p>
<h3 id="注意事项-26"><a href="#注意事项-26" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>因为Java中泛型是用擦除来完成的，可以给不同的参数类型使用单个对象</li>
</ol>
<h2 id="利用有限制通配符来提升API的灵活性"><a href="#利用有限制通配符来提升API的灵活性" class="headerlink" title="利用有限制通配符来提升API的灵活性"></a>利用有限制通配符来提升API的灵活性</h2><h3 id="使用时机-30"><a href="#使用时机-30" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="编写泛型类的方法和静态泛型方法时"><a href="#编写泛型类的方法和静态泛型方法时" class="headerlink" title="编写泛型类的方法和静态泛型方法时"></a>编写泛型类的方法和静态泛型方法时</h4><p>为了获得更大程度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符</p>
<h3 id="注意事项-27"><a href="#注意事项-27" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>要分清方法的参数时生产实例(从参数中创建实例)还是消费实例(把实例放入到参数中)</li>
<li>如果类型参数只在方法生命中出现一次，就可以用通配符取代它，通配符看起来更简单</li>
</ol>
<h2 id="谨慎并用泛型和可变参数"><a href="#谨慎并用泛型和可变参数" class="headerlink" title="谨慎并用泛型和可变参数"></a>谨慎并用泛型和可变参数</h2><h3 id="使用时机-31"><a href="#使用时机-31" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="编写带有可变参数的泛型方法的时候"><a href="#编写带有可变参数的泛型方法的时候" class="headerlink" title="编写带有可变参数的泛型方法的时候"></a>编写带有可变参数的泛型方法的时候</h4><p>泛型和可变参数配合并不好，这是Java设计如此</p>
<h3 id="注意事项-28"><a href="#注意事项-28" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>如果确保没有问题可以使用@SafeVarargs()注解</li>
<li>可以考虑用列表来实现可变参数</li>
<li>要特别注意在泛型方法中调用可变参数泛型方法，会生成Object数组</li>
</ol>
<h2 id="优先考虑类型安全的异构容器"><a href="#优先考虑类型安全的异构容器" class="headerlink" title="优先考虑类型安全的异构容器"></a>优先考虑类型安全的异构容器</h2><h3 id="使用时机-32"><a href="#使用时机-32" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="一个容器需要同时存储任意种类型时"><a href="#一个容器需要同时存储任意种类型时" class="headerlink" title="一个容器需要同时存储任意种类型时"></a>一个容器需要同时存储任意种类型时</h4><p>这时泛型可以起到一个检验参数类型的作用，保证类型安全</p>
<h3 id="注意事项-29"><a href="#注意事项-29" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>泛型最常用于集合，充当类型参数，另外一种用法是将泛型作为键传入容器，用来保证容器的类型安全，保证不会放入别的类型</li>
</ol>
<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="用enum代替int常量"><a href="#用enum代替int常量" class="headerlink" title="用enum代替int常量"></a>用enum代替int常量</h2><h3 id="使用时机-33"><a href="#使用时机-33" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="想定义一组有关系且数量有限的常量时"><a href="#想定义一组有关系且数量有限的常量时" class="headerlink" title="想定义一组有关系且数量有限的常量时"></a>想定义一组有关系且数量有限的常量时</h4><p>int类型的常量不具备类型安全，因为它们都是int类型，可能用混。常量是编译时放入代码的，不重新编译代码是无法改变的，枚举是类，就不会有这个问题</p>
<h3 id="注意事项-30"><a href="#注意事项-30" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>枚举相较int常量，枚举可以直接打印名称，同时可以一次性取出相同类型的全部枚举</li>
<li>枚举相较String常量，唯一的优势是可以列举，所以如果不能会枚举出来或需要进行枚举，还是可以用String常量</li>
<li>枚举的ValueOf可以枚举名称找到枚举</li>
<li>枚举有三种用法，枚举本身，枚举属性和枚举方法，分别是名称的枚举，属性的枚举和方法的枚举</li>
</ol>
<h2 id="使用实例字段代替序数"><a href="#使用实例字段代替序数" class="headerlink" title="使用实例字段代替序数"></a>使用实例字段代替序数</h2><h3 id="使用时机-34"><a href="#使用时机-34" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="需要列举一组固定的数字时"><a href="#需要列举一组固定的数字时" class="headerlink" title="需要列举一组固定的数字时"></a>需要列举一组固定的数字时</h4><p>不要使用枚举本身的序号，自己新建一个实例字段。好处是这样可以设置任何自己想要的值，以及允许值重复</p>
<h3 id="注意事项-31"><a href="#注意事项-31" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>枚举的序号可以说是内部细节，就不该给程序员使用</li>
</ol>
<h2 id="使用EnumSet代替位域"><a href="#使用EnumSet代替位域" class="headerlink" title="使用EnumSet代替位域"></a>使用EnumSet代替位域</h2><h3 id="使用时机-35"><a href="#使用时机-35" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何使用位域的地方"><a href="#任何使用位域的地方" class="headerlink" title="任何使用位域的地方"></a>任何使用位域的地方</h4><p>位域的唯一目的就是为了集合操作，java中已经有集合接口，也就没有必要使用位域了</p>
<h3 id="注意事项-32"><a href="#注意事项-32" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>位域就是Set的一种特殊实现，为了更高效的实现集合运算，是一种低级实现，使用起来比较麻烦</li>
</ol>
<h2 id="用EnumMap代替序数索引"><a href="#用EnumMap代替序数索引" class="headerlink" title="用EnumMap代替序数索引"></a>用EnumMap代替序数索引</h2><h3 id="使用时机-36"><a href="#使用时机-36" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="想使用枚举的ordinal值作为数组索引的时候"><a href="#想使用枚举的ordinal值作为数组索引的时候" class="headerlink" title="想使用枚举的ordinal值作为数组索引的时候"></a>想使用枚举的ordinal值作为数组索引的时候</h4><p>EnumMap可读性更好，也更灵活</p>
<h3 id="注意事项-33"><a href="#注意事项-33" class="headerlink" title="注意事项"></a>注意事项</h3><p>序数很不灵活，不要使用</p>
<h2 id="用接口模拟可扩展的枚举"><a href="#用接口模拟可扩展的枚举" class="headerlink" title="用接口模拟可扩展的枚举"></a>用接口模拟可扩展的枚举</h2><h3 id="使用时机-37"><a href="#使用时机-37" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="没有使用的地方"><a href="#没有使用的地方" class="headerlink" title="没有使用的地方"></a>没有使用的地方</h4><p>没必要实现可扩展的枚举</p>
<h3 id="注意事项-34"><a href="#注意事项-34" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>本质上就是枚举类型实现接口</li>
</ol>
<h3 id="注解优先于命名模式"><a href="#注解优先于命名模式" class="headerlink" title="注解优先于命名模式"></a>注解优先于命名模式</h3><h4 id="使用时机-38"><a href="#使用时机-38" class="headerlink" title="使用时机"></a>使用时机</h4><h4 id="想给某个类，方法，字段，参数加上其他信息"><a href="#想给某个类，方法，字段，参数加上其他信息" class="headerlink" title="想给某个类，方法，字段，参数加上其他信息"></a>想给某个类，方法，字段，参数加上其他信息</h4><p>注解就是为了这个而存在的</p>
<h3 id="注意事项-35"><a href="#注意事项-35" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>命名模式就是将数据或标识写在类名，方法命中，字段名中或参数名中，这样非常不灵活</li>
<li>注解类型声明中使用的注解被称为元注解</li>
<li>Java8增加了另外一种形式的多值注解，叫做重复注解，但是可读性不太好，了解就行</li>
</ol>
<h2 id="坚持使用Override注解"><a href="#坚持使用Override注解" class="headerlink" title="坚持使用Override注解"></a>坚持使用Override注解</h2><h3 id="使用时机-39"><a href="#使用时机-39" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="子类想覆盖超类方法的时候"><a href="#子类想覆盖超类方法的时候" class="headerlink" title="子类想覆盖超类方法的时候"></a>子类想覆盖超类方法的时候</h4><p>这样可以防止方法名或者方法参数写错导致没能覆盖父类方法的情况</p>
<h3 id="注意事项-36"><a href="#注意事项-36" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>如果没有标注Override，子类方法还覆盖了父类的方法，IDE还会给出提示，防止子类意外覆盖父类的方法</li>
</ol>
<h2 id="用标记接口定义类型"><a href="#用标记接口定义类型" class="headerlink" title="用标记接口定义类型"></a>用标记接口定义类型</h2><h3 id="使用时机-40"><a href="#使用时机-40" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="想要标记一个类时，更具体的是正在编写ElementType-Type类型的标记注解的时候"><a href="#想要标记一个类时，更具体的是正在编写ElementType-Type类型的标记注解的时候" class="headerlink" title="想要标记一个类时，更具体的是正在编写ElementType.Type类型的标记注解的时候"></a>想要标记一个类时，更具体的是正在编写ElementType.Type类型的标记注解的时候</h4><p>如果有方法使用标记类型作为参数，使用标记接口更合适，如果没有这样的方式，才使用标记注解<br>标记接口相较标记注解，标记接口能在编译期就能识别被标记的类，而注解必须结合反射在运行时才能发现</p>
<h3 id="注意事项-37"><a href="#注意事项-37" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>标记接口是不包含方法声明的接口，用于标记一个类是否允许被执行某种操作，例如Clonable接口和Serializable接口就是标记接口，用来标记一个类允许被复制和序列化</li>
<li>标记接口其实是接口的一种特殊用法，接口通常是来说明某个类具有某种功能，而不是标记一个允许被用来干什么，标记接口很少有使用机会</li>
<li>接口使用定义类型的，不要定义常量接口。如果要定义类型，优先使用接口而不是抽象类，抽象类只能单继承，很不灵活</li>
</ol>
<h1 id="Lambda和Stream"><a href="#Lambda和Stream" class="headerlink" title="Lambda和Stream"></a>Lambda和Stream</h1><h2 id="Lambda优先于匿名类"><a href="#Lambda优先于匿名类" class="headerlink" title="Lambda优先于匿名类"></a>Lambda优先于匿名类</h2><h3 id="使用时机-41"><a href="#使用时机-41" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="实现单个方法的匿名类的时候"><a href="#实现单个方法的匿名类的时候" class="headerlink" title="实现单个方法的匿名类的时候"></a>实现单个方法的匿名类的时候</h4><p>因为Lambda相比匿名类更简洁</p>
<h3 id="注意事项-38"><a href="#注意事项-38" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>在Java8之前，通常用带有单个方法的接口作为函数类型，它们的实例称作函数对象</li>
<li>Lambda没有名称和文档，如果一个Lambda表达式超过了3行，还是使用匿名类，匿名类的可读性比Lambda好</li>
</ol>
<h2 id="方法引用优于Lambda表达式"><a href="#方法引用优于Lambda表达式" class="headerlink" title="方法引用优于Lambda表达式"></a>方法引用优于Lambda表达式</h2><h3 id="使用时机-42"><a href="#使用时机-42" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="想使用Lambda表达式时"><a href="#想使用Lambda表达式时" class="headerlink" title="想使用Lambda表达式时"></a>想使用Lambda表达式时</h4><p>如果这时有对应的方法引用，使用方法引用更好。因为方法引用比Lambda更简洁</p>
<h3 id="注意事项-39"><a href="#注意事项-39" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>Lambda表达式的可读性比方法引用更好，毕竟多了参数名称。这时可以将Lambda改造成一个新方法中，然后再通过方法名引用</li>
</ol>
<h2 id="坚持使用标准的函数接口"><a href="#坚持使用标准的函数接口" class="headerlink" title="坚持使用标准的函数接口"></a>坚持使用标准的函数接口</h2><h3 id="使用时机-43"><a href="#使用时机-43" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="自己想声明函数接口的时候"><a href="#自己想声明函数接口的时候" class="headerlink" title="自己想声明函数接口的时候"></a>自己想声明函数接口的时候</h4><p>标准的函数接口可以减少学习成本，是类库直接支持的，如果自己编写，别人还要看来你的实现。如果一个函数接口会为了某一个目的被广泛使用，这时可以考虑自己声明函数接口，函数接口名称可以提供一些描述信息，函数接口上还可以写文档</p>
<h3 id="注意事项-40"><a href="#注意事项-40" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>模版方法本质上就是传递一段代码，使用继承或者传递代码实例都行，只不过传递实例更好</li>
<li>不要用带包装类型的基础函数接口来代替基本函数接口。因为基本类型优于装箱基本类型，装箱基本类型的拆箱和装箱会带来严重的性能问题</li>
<li>当自己编写函数接口时，记得使用@FunctionalInterface注解，这样可以让编译器帮忙检查自己的函数接口写的对不对</li>
<li>不要使用重载，重载会使代码的可读性变差</li>
</ol>
<h2 id="谨慎使用Stream"><a href="#谨慎使用Stream" class="headerlink" title="谨慎使用Stream"></a>谨慎使用Stream</h2><h3 id="使用时机-44"><a href="#使用时机-44" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="编写某些特别很难理解的流操作时"><a href="#编写某些特别很难理解的流操作时" class="headerlink" title="编写某些特别很难理解的流操作时"></a>编写某些特别很难理解的流操作时</h4><p>过分使用流会导致代码非常难理解，这时可以把流操作放进一个函数中，用非流的方式来实现。总结来说就是只使用简单的流操作</p>
<h3 id="注意事项-41"><a href="#注意事项-41" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>流非常依赖函数对象，但函数对象比起代码块有很多限制，代码块可以读取和修改范围内的任意局部变量，而函数对象则只能读取final变量，并且不能修改任何局部变量；代码块可以从外围方法return，break和continue到外围循环，或者抛出异常，函数对象则办不到</li>
</ol>
<h2 id="优先选择Stream中无副作用的函数"><a href="#优先选择Stream中无副作用的函数" class="headerlink" title="优先选择Stream中无副作用的函数"></a>优先选择Stream中无副作用的函数</h2><h3 id="使用时机-45"><a href="#使用时机-45" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="使用Steam进行编程的时候"><a href="#使用Steam进行编程的时候" class="headerlink" title="使用Steam进行编程的时候"></a>使用Steam进行编程的时候</h4><p>Steam里面的函数最好是纯函数</p>
<h3 id="注意事项-42"><a href="#注意事项-42" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>纯函数是指结果只取决于输入函数：它不依赖任何可变的状态，也不更新任何状态</li>
<li>forEach操作应该只用于报告Stream计算的结果，而不是执行计算</li>
<li>方法引用也可以进行转型，可以转型成该方法实现的函数接口</li>
</ol>
<h2 id="Stream要优先用Collection作为返回类型"><a href="#Stream要优先用Collection作为返回类型" class="headerlink" title="Stream要优先用Collection作为返回类型"></a>Stream要优先用Collection作为返回类型</h2><h3 id="使用时机-46"><a href="#使用时机-46" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="需要流返回元素序列时"><a href="#需要流返回元素序列时" class="headerlink" title="需要流返回元素序列时"></a>需要流返回元素序列时</h4><p>因为Collection接口是Iterable的子接口，并且有Stream方法，可以同时提供迭代和流。如果集合元素很少，可以放入集合中，可以考虑返回具体实现类，例如ArrayList，HashSet。如果不能返回一个自己实现的特殊集合<br>如果返回元素不能作为Collection返回，例如不好实现Contains和Size方法，这时可以返回Iterable，最好也实现一个Stream</p>
<h3 id="注意事项-43"><a href="#注意事项-43" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>如果不使用流，返回序列的方法通常返回的是集合接口Collection；如果序列不需要进行Collection操作，可以返回Iterable；如果返回类型时基本数据类型，或则对性能要求很高，可以返回数组</li>
<li>实现了Iterable接口才能使用foreach循环</li>
</ol>
<h2 id="谨慎使用Stream并行"><a href="#谨慎使用Stream并行" class="headerlink" title="谨慎使用Stream并行"></a>谨慎使用Stream并行</h2><h3 id="使用时机-47"><a href="#使用时机-47" class="headerlink" title="使用时机"></a>使用时机</h3><h4 id="任何时候都不要使用Stream中的并行"><a href="#任何时候都不要使用Stream中的并行" class="headerlink" title="任何时候都不要使用Stream中的并行"></a>任何时候都不要使用Stream中的并行</h4><p>Stream中的并行流编写非常复杂，很难编写对</p>
<h3 id="注意事项-44"><a href="#注意事项-44" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>如果不得不编写并行流来提高性能，元素个数乘以每个元素需要执行的代码行数大于10万，这时并行流才可能带来性能上的提升</li>
</ol>

    </div>

    
    
    
      <div>
  <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
</div>


    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B%E5%BB%BA%E8%AE%AE/" rel="tag"><i class="fa fa-tag"></i> 编程建议</a>
          </div>
	  <script type="text/javascript">
            var tagsall=document.getElementsByClassName("post-tags")
            for (var i = tagsall.length - 1; i >= 0; i--){
                var tags=tagsall[i].getElementsByTagName("a");
                for (var j = tags.length - 1; j >= 0; j--) {
                    var golden_ratio = 0.618033988749895;
                    var s = 0.5;
                    var v = 0.999;
                    var h = golden_ratio + Math.random()*0.8 - 0.5;
                    var h_i = parseInt(h * 6);
                    var f = h * 6 - h_i;
                    var p = v * (1 - s);
                    var q = v * (1 - f * s);
                    var t = v * (1 - (1 - f) * s);
                    var r, g, b;
                    switch (h_i) {
                        case 0:
                            r = v;
                            g = t;
                            b = p;
                            break;
                        case 1:
                            r = q;
                            g = v;
                            b = p;
                            break;
                        case 2:
                            r = p;
                            g = v;
                            b = t;
                            break;
                        case 3 :
                            r = p;
                            g = q;
                            b = v;
                            break;
                        case 4:
                            r = t;
                            g = p;
                            b = v;
                            break;
                        case 5:
                            r = v;
                            g = p;
                            b = q;
                            break;
                        default:
                            r = 1;
                            g = 1;
                            b = 1;
                      }
                    tags[j].style.background = "rgba("+parseInt(r*255)+","+parseInt(g*255)+","+parseInt(b*255)+","+0.5+")";
                }
            }
            </script>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/08/25/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/SpringBoot/SpringBoot%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E5%92%8C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" rel="prev" title="SpringBoot源码解读和原理分析">
                  <i class="fa fa-chevron-left"></i> SpringBoot源码解读和原理分析
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-leaf"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">霄剑</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">81k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:53</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/55OX5XO55" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
