<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>maven使用</title>
      <link href="/2024/07/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Maven/maven%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/07/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Maven/maven%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>如何使用<code>Maven</code></p><span id="more"></span><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Maven的作用"><a href="#Maven的作用" class="headerlink" title="Maven的作用"></a>Maven的作用</h2><p><code>Maven</code>最主要的两个作用</p><ol><li>项目构建</li><li>项目的依赖管理</li></ol><h2 id="Maven-Make-Ant的对比"><a href="#Maven-Make-Ant的对比" class="headerlink" title="Maven, Make, Ant的对比"></a>Maven, Make, Ant的对比</h2><p>这三个都可以用来构建<code>java</code>代码, 它们之间的对比如下</p><table><thead><tr><th></th><th>编程范式</th><th>依赖管理</th><th>跨平台</th></tr></thead><tbody><tr><td><code>Make</code></td><td>命令式</td><td>不支持</td><td>不支持</td></tr><tr><td><code>Ant</code></td><td>命令式</td><td>不支持</td><td>支持</td></tr><tr><td><code>Maven</code></td><td>声明式</td><td>支持</td><td>支持</td></tr></tbody></table><p><code>Make</code>是命令式的, 需要自己写明先编译什么, 再编译什么, 这样比较麻烦. 同时<code>Make</code>调用的是操作系统的命令, 例如<code>cp</code>, <code>mv</code>等等, 在<code>Linux</code>和<code>Windows</code>是不通用的. </p><p><code>Ant</code>用<code>java</code>实现了操作系统的某些指令, 让<code>Ant</code>可以跨平台使用</p><h2 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h2><p>只需要使用下面的命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate &quot;-DgroupId=com.caicai.maven&quot; &quot;-DartifactId=maven-test&quot; &quot;-DarchetypeArtifactId=maven-archetype-quickstart&quot; &quot;-DinteractiveMode=false&quot;</span><br></pre></td></tr></table></figure><p>这个命令会形成一个这样的目录结构</p><img src="/2024/07/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Maven/maven%E4%BD%BF%E7%94%A8/image-20240720115125547.png" class="" title="image-20240720115125547"><p>也可以自己手动创建创建目录和<code>pom.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.caicai.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>maven-test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以说这个命令其实并没有做什么特殊操作, 就创建了一些目录, <code>pom.xml</code>和简单的<code>java</code>文件(这个不是必须的). 只要有这样的目录结构和<code>pom.xml</code>, 就可以把一个项目称为<code>maven</code>项目了</p><h2 id="如何打包可运行的jar包"><a href="#如何打包可运行的jar包" class="headerlink" title="如何打包可运行的jar包"></a>如何打包可运行的jar包</h2><p>我们首先需要了解一下<code>jar</code>命令, <code>jar</code>命令其实就是一个打包压缩命令, 像<code>zip</code>一样. 只不过会多生成一个<code>META-INF/MANIFEST.MF</code>, 用于描述<code>class</code>. <code>jar</code>打包就是<code>class</code>文件, 其实也可以自己用<code>zip</code>命令打包class, 然后创建<code>MANIFEST</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jar -c[m]f [manifest.mf文件] &quot;jar包的名称&quot; 要打包的目录</span><br><span class="line">-c: 创建</span><br><span class="line">-f: jar包的名称</span><br><span class="line">-m: 使用文件中的内容来生成MEAT-INF/MANIFEST.MF文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tip</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个命令很奇怪, 参数选项的顺序不能随意写</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line">jar -cf &quot;myjar.jar&quot; com</span><br></pre></td></tr></table></figure><p>不可运行的<code>jar</code>的<code>MANIFEST.MF</code></p><img src="/2024/07/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Maven/maven%E4%BD%BF%E7%94%A8/image-20240720131643889.png" class="" title="image-20240720131643889"><p>可运行的<code>jar</code>的<code>MANIFEST.MF</code></p><img src="/2024/07/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Maven/maven%E4%BD%BF%E7%94%A8/image-20240720132016726.png" class="" title="image-20240720132016726"><h3 id="运行jar包"><a href="#运行jar包" class="headerlink" title="运行jar包"></a>运行jar包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jar包</span><br></pre></td></tr></table></figure><h3 id="Maven打包成可执行的jar包"><a href="#Maven打包成可执行的jar包" class="headerlink" title="Maven打包成可执行的jar包"></a>Maven打包成可执行的jar包</h3><p>上面我们编写的可执行<code>java</code>程序没有依赖别的<code>jar</code>包, 用的都是<code>java</code>自己的类. 如果要使用别的<code>jar</code>包, 需要自己把<code>jar</code>包复制出来, 然后在<code>MANIFEST.MF</code>中指定类路径. 这是不使用<code>maven</code>的手动方式, 如果依赖的<code>jar</code>包比较多, 自己就需要一个一个复制, 比较麻烦</p><p><code>Maven</code>可以配置构建插件, 自动复制. 如果不配置构建插件, 依赖的<code>jar</code>包, 不会出现在打包的<code>jar</code>文件中</p><p>配置插件, 会生成两个<code>jar</code>, 一个是带<code>original</code>, 一个是不带的. 带的不包含自己依赖的<code>jar</code>包, 一般是提供给别人用的, 别人的<code>maven</code>会自动下载这些依赖. 不带的, 放入了解压后的<code>jar</code>包, <code>jar</code>包依赖的<code>jar</code>包也会被放入, 是可以运行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">  &lt;plugins&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 使用maven-shade-plugin插件打包 --&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.2.3&lt;/version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;</span><br><span class="line">      &lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">      &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">          &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">          &lt;goals&gt;</span><br><span class="line">            &lt;goal&gt;shade&lt;/goal&gt;</span><br><span class="line">          &lt;/goals&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;transformers&gt;</span><br><span class="line">              &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;</span><br><span class="line">                &lt;mainClass&gt;com.caicai.maven.App&lt;/mainClass&gt;</span><br><span class="line">              &lt;/transformer&gt;</span><br><span class="line">            &lt;/transformers&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">      &lt;/executions&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">  &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h2 id="Maven指定java版本"><a href="#Maven指定java版本" class="headerlink" title="Maven指定java版本"></a>Maven指定java版本</h2><h3 id="为什么Maven需要指定java版本呢"><a href="#为什么Maven需要指定java版本呢" class="headerlink" title="为什么Maven需要指定java版本呢?"></a>为什么<code>Maven</code>需要指定<code>java</code>版本呢?</h3><p>我们已经安装了<code>jdk</code>, 也指定了<code>jdk</code>中<code>javac</code>的<code>path</code>, 这里就已经确定了<code>java</code>的版本, 为什么还有指定<code>java</code>的版本呢? 其中的原因就是高版本的<code>java</code>可以编译出低版本的<code>class</code>文件, 而<code>Maven</code>默认使用的是<code>jdk1.5</code>, 这就意味着, 写的代码不能使用<code>jdk1.5</code>之后的新的特性, 例如<code>jdk1.8</code>的lambda&#96;表达式</p><p>利用高版本<code>jdk</code>编译低版本<code>class</code>的方式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javac.exe -bootclasspath ‪rt.jar -source 1.8 -target 1.8 HelloWorld.java</span><br><span class="line"></span><br><span class="line">-bootclasspath: 用于指定要编译成的版本的核心class, 可以用于校验源代码的方法是否能用于生成目标版本, 其实不指定, 也是会校验的, 只不过只会语法特性, 不会校验方法. 如果源代码使用旧版本的不支持的新方法, 不使用这个选项, 就会编译成功, 但实际上在旧版本上运行时, 又会报错</span><br><span class="line">-source: -source和-target通常相同</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从java1.9开始 javac新增了--release选项, 可以一次性代替上面三个选项</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实最好还是使用对应版本的java版本来编译, 不使用这种方式</span></span><br></pre></td></tr></table></figure><h3 id="Maven指定java版本-1"><a href="#Maven指定java版本-1" class="headerlink" title="Maven指定java版本"></a>Maven指定java版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">  &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">  &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><h2 id="Maven中scope-x3D-provided"><a href="#Maven中scope-x3D-provided" class="headerlink" title="Maven中scope&#x3D;provided"></a>Maven中scope&#x3D;provided</h2><p><code>provided</code>的两种应用场景</p><ol><li><code>servlet-api</code>: 编译时需要, 但运行时也需要, 但你不应该提供, 应该用别人已经提供好的, 否则就会产生冲突</li><li><code>lombok</code>: 自己编译时需要, 别人用你的代码时编译时, 不需要. 生命周期在自己的代码编译成class后, 就已经结束了, 代码中的<code>import</code>已经被移除掉了</li></ol><h3 id="和optional-x3D-true的区别"><a href="#和optional-x3D-true的区别" class="headerlink" title="和optional&#x3D;true的区别"></a>和optional&#x3D;true的区别</h3><blockquote><p>大概意思是说，在A项目依赖B项目提供了一些特性，但又不想让这些特性默认提供，而是作为可以选择的附加功能，默认不提供，需要声明后（主动添加B项目的依赖）才生效，这时用optional；而对于provided，文档侧重提到了<code>运行环境</code>概念，强调只在编译时存在，而运行时不存在的依赖，也就是说，provided的主要用途不是为了考虑依赖是否传递，而是要看项目运行时是不是不应该有这个依赖（是不是需要jvm或者运行容器提供）。</p><p>经常拿scope&#x3D;provided来举例的经典场景之一，就是<code>servlet-api</code>这个依赖了，在代码coding阶段需要使用到它的一些api，而在实际运行时，它的作用要由具体的运行容器来实现，因此编译时可以有它，而打成war包放到tomcat环境下运行时，war包里面不应该有这个<code>servlet-api.jar</code>，否则就会报错了。</p><p>在实际的spring-boot项目中，由于大部分使用了内置的<code>undertow</code>或者<code>tomcat</code>容器，已经不需要特别声明这个jar的provided属性了。事实上，日常中更经常需要被用到的，应该主要就是这个optinal了，比如你要提供一组基础jar包，供项目组中的其他同事在他们的项目中引入依赖使用时，如果你提供的某些依赖了其他jar包来做的功能并不一定会被使用到，便可以用到这个optinal了。特别是用到诸如<code>@ConditionalOnClass</code>这种检测项目中是否存在某个class的判断条件时，更是用optional的好时机。</p><p>而<code>provided</code>的使用场景，除了<code>servlet-api</code>，<code>lombok</code>也很适合：A项目使用lombok做了一些代码生成，完成开发需要deploy到私服仓库之前，记得要将lombok的依赖加上<code>&lt;scope&gt;provided&lt;/scope&gt;</code>，因为它的作用周期已经在A项目打包完成时结束了，对于依赖A项目的其他项目，不需要用到lombok这个玩意儿，它们需要的是A项目提供的功能，而不是附带的帮助自己生成代码的额外功能；也不应该用<code>optional</code>，因为没什么好选择的，它并不是A项目提供的可选功能之一。</p><p>链接：<a href="https://www.jianshu.com/p/4b100150038b">https://www.jianshu.com/p/4b100150038b</a></p></blockquote><p>其实最好不要使用<code>optional</code>, 创建一个新的<code>maven</code>项目提供另一种功能更好, 对于使用者更加友好</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>如果使用了<code>maven</code>来管理项目依赖, 就不要再自己手动添加<code>jar</code>包了. 如果不进行配置, <code>maven</code>看不见你加的<code>jar</code>包的, <code>maven</code>应该只能看到<code>pom</code>里面的依赖</li><li>从<code>Maven</code>仓库下载的<code>jar</code>包, 只会包含自身的<code>class</code>, 不会包含它依赖的<code>jar</code>包, 还会在同级目录的&#96;&#96;pom.xml<code>里面, 会写明自己的依赖, 这样可以让</code>Maven<code>不用每次都下载全量文件, 可以利用之前下载好的</code>jar&#96;包</li><li>一个<code>maven</code>项目中每个<code>jar</code>包只能出现一个版本, 毕竟<code>java</code>只会找类路径, 根本没有版本的概念</li><li><code>Maven</code>跳过测试<code>mvn clean package -Dmaven.test.skip=true</code></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>如何将本地的<code>jar</code>包加入<code>maven</code>的本地仓库呢?</p><p>做不到, 除非自己用源码, 然后再<code>maven install</code>. 只有一个<code>jar</code>包是缺少很多东西的</p></li><li><p><code>maven</code>命令的生命周期</p></li><li><p>为什么<code>spring-core</code>会被<code>maven</code>的<code>dependency:analyze</code>分析为<code>Unused declared dependencies found</code></p><p>这个用<code>lombok</code>可以解释, 字节码中并没有<code>Lombok</code>, 只是源代码中有, 而<code>maven</code>分析的只是字节码, 所以<code>Maven</code>会认为没有使用<code>Lombok</code>, 下面是<code>Maven</code>官网的一段描述, 可以印证我这个猜想</p><blockquote><p>By default, <a href="http://maven.apache.org/shared/maven-dependency-analyzer/">maven-dependency-analyzer</a> is used to perform the analysis, with limitations due to the fact that it works at bytecode level, but any analyzer can be plugged in through <code>analyzer</code> parameter.</p></blockquote><p>那为什么<code>Lombok</code>的<code>scope</code>是<code>provided</code>, 而<code>spring-core</code>的<code>scope</code>是<code>compile</code>呢? 这个我猜是因为运行时, 也要用到<code>spring-core</code>, <code>Lombok</code>运行时是用不到的, 所以, <code>spring-core</code>是编译时需要, 运行时也需要, 那就只能是<code>compile</code>了</p></li><li><p>为什么<code>Lombok</code>可以在编译的时候生成代码呢?</p><p>这个是用到<code>java</code>自己的一些特性, 只有实现<code>AbstractProcessor</code>, 就可以在编译时, 运行一些代码来操作编译时存在的注解了. 这也说明了编译时注解的作用</p></li></ol><h2 id="要看的章节"><a href="#要看的章节" class="headerlink" title="要看的章节"></a>要看的章节</h2><p>第8章</p><p>第12章</p><p>第14章</p><p>第17章</p><p>附录</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
            <tag> Maven实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go的问题</title>
      <link href="/2024/06/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E9%97%AE%E9%A2%98/Go%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/06/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E9%97%AE%E9%A2%98/Go%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Go的问题"><a href="#Go的问题" class="headerlink" title="Go的问题"></a>Go的问题</h1><ol><li><code>itoa</code>是个什么<br>就是一个常量计数器, 只能用于<code>const</code>中. 我觉得没啥用, 一点通用性都没有, 作用也非常有限. 忘记它都可以, <code>java</code>中有这样的东西吗? 好像是有的, 叫什么生成器., 但这个有些用, 也具有通用性. </li><li><code>int</code>和<code>uint</code>有什么用, 已经有<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code><br><code>int</code>和<code>uint</code>应该是在程序内部自己使用的, 如果要调用外部的接口, 也就是别人包里面的东西, 肯定只能用确定位数的数字, 否则大小有可能不匹配, 会吗. <code>go</code>编译的时候应该也会把别人包里面的东西一起编译吧, 会吗? 那<code>go</code>没哟编译好的库吗? 所有的东西都要自己编译吗? <code>java</code>是怎么引入<code>jar</code>包的呢? <code>go</code>语言的包管理是真的乱, 下载的包的位置, 找包的路径, <code>go get</code>这个东西又一直在变, <code>go install</code>又是什么东西, 下载了包为什么还要自己编译, 真是吐了. <code>java</code>如何使用<code>jar</code>包呢. <code>java</code>和<code>go</code>对于编译成包, 和使用包都有些复杂, 复杂吗? 学习这些语言时, 好像都不关心这些东西? 真的不重要吗?</li><li>“如果是在函数外部定义, 那么将在当前包的所有文件中都可以访问”. 包是类或者类的集合, 包中还可以包含包, 包用于组织类或者结构. </li><li><code>go</code>语言中有声明和定义和区别吗? <code>java</code>有吗? <code>go</code>区分函数的声明和定义吗? 现在<code>go</code>函数的定义不需要出现使用之前</li><li><code>go</code>语言不存在未初始化的值, 无论是包级别的变量, 还是函数内部的, 都会被赋零值. 那怎么区分不存在和零值呢? 例如输入空字符串和不输入字符串</li><li>短变量声明只能用于函数内部吗? 为什么不能用于包级别呢? 有没有什么区别?</li><li>当短变量声明对某个变量进行赋值时, 这个变量在函数内还是函数外, 会决定这个是赋值, 还是声明, 这可能会导致不熟悉<code>go</code>语言的人写出<code>bug</code>. <code>java</code>没有这种赋值和定义同时进行的操作, 只能同时定义, <code>int a = 10, b = 20;</code></li><li>为什么<code>go</code>的可运行程序的第一个非注释行必须是<code>package main</code>? <code>go</code>语言中<code>package</code>与文件路径无关, 那它有什么用呢?</li><li><code>go</code>语言允许返回局部变量的地址, 且这个地址是有效的, 不会被覆盖, 这个跟<code>c</code>语言不同, <code>c</code>语言地址里面的值是会被修改, 导致不可用, 这个更像<code>java</code>中的返回函数中<code>new</code> 的对象. 看来<code>go</code>跟<code>c</code>的实现存在明显区别</li><li><code>java</code>没有自带的命令行参数解析库, 需要自己去下载<code>jar</code>包, 这里可以借助<code>maven</code></li><li>如果类型的大小为0, 例如<code>struct&#123;&#125;</code>和<code>[0]int</code>, 可能会有相同的地址, 同时<code>go</code>语言对于大小为0的结构的处理还存在问题, 那为什么不修呢</li><li><code>new</code>只是一个预定义的函数, 不是一个关键字, 我们因此可以将<code>new</code>名字重新定义为别的类型. 这个该说是<code>go</code>语言的有点呢, 还是确定呢? 我认为还是缺点更大一些, 反正都有别的关键字了, 多这一个也不多啊. 也可以认为<code>new</code>并不重要, 毕竟可以通过返回内部变量的地址来达到同样的效果</li><li><code>go</code>语言的每一行不是以分号分隔的, 有一种复杂的规则来认定一行, 值得吗, 为了省一个分号</li><li><code>go</code>自己判断变量是在栈上分配空间还是在堆上分配空间, 不是靠<code>new</code>来决定的, 真是增加了理解程序的难度, 和<code>c</code>语言完全不同</li><li><code>go</code>语言中<code>++</code>和<code>--</code>是语句, 不可以在<code>++</code>和<code>--</code>的同时再进行赋值, 而在<code>java</code>中是允许的, <code>go</code>中这种强制行为, 感觉不灵活, 应该还是缺点更多</li><li><code>go</code>的元组赋值(多变量同时赋值), 比起<code>java</code>多了一种选择</li><li><code>go</code>中返回多个值的函数, 还能用说与返回值个数的变量接收, 导致和全部接收不同的结果. 简直离谱. 例如<code>map</code>的取值操作</li><li><code>go</code>语言只用常量的赋值才会发生隐式类型转换吗? <code>java</code>只有数值类型的赋值和计算才会发生隐式转换, 什么是隐式转换呢?</li><li><code>go</code>语言中<code>type</code>的用法是<code>type 类型名字 底层类型</code>, 与<code>c</code>语言的顺序相反, <code>type</code>就是为了给类型一个别名, 就是为了增加代码可读性吗, 还可以防止类型混用</li><li>打印时的<code>%v</code>, <code>%s</code>, <code>%g</code>有什么区别, 为什么会有这么多种打印一个类型值的方式</li><li><code>float64(1.0)</code>和<code>1.0</code>虽然底层类型时相同的, 但是一个是命名了, 一个是未命名. 未命名的可以用于赋值给 相同底层数据结构的变量(运算符都是支持的)</li><li>直接命名基本数据类型, 还是得到运算操作, 只能说聊生于无吧</li><li><code>go</code>语言中一个目录下只能有一个包, 也就是说<code>package xxx</code>, <code>xxx</code>必须相同, <code>xxx</code>还会作为别的包使用这个包时带的前缀, 同一个包中可以不带前缀. 感觉跟<code>java</code>的包还是有些不同的</li><li><code>go moudle</code>语言对于包导入, 不再依赖<code>$GOPATH</code>, 那它从那里找包呢? <code>go mod</code>文件定义了一个模块名, 导入包时, 以这个模块名开头的路径, 会把不带模块头的路径作为相对路径, 从<code>go mod</code>文件所在文件夹, 开始找包. 感觉比<code>java</code>指定类路径的方式复杂了</li><li><code>go</code>包的初始化, 外部变量循环依赖怎么办, 内部包级变量循环依赖怎么办? 感觉比<code>java</code>的复杂</li><li>一个程序可能包含多个同名的声明, 只要它们在不同的词法域就没有关系. 这个跟<code>c</code>语言是一样的</li><li><code>go</code>语言中<code>if</code>语句的判断条件中可以定义变量, 而且这个变量还可以在整个<code>if</code>和<code>else</code>语句体中使用, 是一个全新的写法, 之前没有任何一种编程语言使用过这种方式, 有增加了复杂度</li><li><code>go</code>语言中包级别的变量按照依赖顺序进行解析和初始化, 局部变量只会按照执行顺序初始化</li><li><code>go</code>语言的<code>main</code>函数的参数是空, 更<code>java</code>和<code>c</code>语言不一样, 如果要使用命令行参数, 就得使用<code>go</code>自带的一个库</li><li><code>go</code>语句只有局部变量会检查是否被使用吗, 包级变量不会吗?</li><li><code>go</code>语言把数据类型分成了四类, 基础数据类型, 复合类型, 引用类型和接口类型. 字符串为什么被归为基础数据类型呢, 它不是一个数组吗. 数组为什么是复合类型, 不是引用类型?, 指针不是一个值吗, 为什么不是基础类型呢, 接口类型不是引用类型吗? <code>go</code>的数据分类的根据是什么呢, 真是看不懂</li><li><code>go</code>语言中<code>int</code>和<code>uint</code>的大小, 不仅和编译器, 还和平台有关系, 我们根本不知道它的大小, 我们该怎么使用它呢. 这是不是说明<code>go</code>编译的程序, 无法在32位和64位上同时运行, 需要同时编译, <code>uintptr</code>的大小也跟平台有关, 是不是用到了, 就得在特定的机器上编译呢? 那有点麻烦, 但是还好, 不用修改源码, 重新编译就行</li><li>为什么<code>rune</code>用<code>int32</code>作为底层, <code>byte</code>用<code>int8</code>作为底层, 一个用有符号数, 一个用符号数, 明明只是一个编码, 不关注数据的正负</li><li><code>go</code>语言有<code>&lt;&lt;</code>和<code>&gt;&gt;</code>, 用的是逻辑位移还是算术位移呢, <code>c</code>的呢, 反正<code>java</code>有<code>&lt;&lt;&lt;</code>和<code>&gt;&gt;&gt;</code>来做区分. <code>go</code>语言中, 在<code>x&lt;&lt;n</code>中, <code>n</code>必须是无符号数, 为什么呢, 正的有符号数不行吗? <code>go</code>语言的<code>&gt;&gt;</code>是算术左移, 但可以通过类型转换来实现首位的填充值, <code>java</code>只有有符号数所以用了两种位移来实现</li><li><code>go</code>语言的<code>&amp;^</code>是啥运算符, 叫做<code>AND NOT</code>, 位清空, 有什么用呢, 别的语言都没有? 通过与, 或, 非, 应该也可以实现吧</li><li><code>go</code>语言中<code>%</code>只能用于整数运算, <code>c</code>语言和<code>java</code>语言也是一样吗? 其实也不用管这些细枝末节的运算细节, 编程中几乎用不到, 通常只会将<code>%</code>用于正整数, 这时这个行为在任何编程语言中都是一致的, 不会有什么差别, 其他的细节, 记还容易记错</li><li><code>go</code>语言多次<code>import</code>一个包, 这个包会被多次初始化吗? 我认为只初始化一次比较合理, 不然没办法共享变量了</li><li><code>go</code>语言中<code>len</code>函数返回的是一个有符号类型, 有符号类型使逆序遍历时, 不会转换为最大的正整数而发生<code>panic</code>. 其实也对无符号数, 太容易变成最大的正整数了, 非常容易出错, 这有可能也是<code>java</code>只用有符号数的原因吧, 所以只在数值的大小没用的时候才使用无符号数, 例如位运算</li><li><code>go</code>语言中, <code>rune</code>变量存的是符号的码表值, 还是经过<code>UTF-8</code>编码后的值呢? 应该是码表值. <code>java</code>中也是一样</li><li><code>go</code>语言除以<code>float</code>变量的<code>0</code>值, 居然不报错, 真是离谱, 但是直接除以<code>0.0</code>又会报错, 就离谱</li><li><code>go</code>语言短变量声明的默认类型为<code>int</code>和<code>float64</code></li><li><code>go</code>语言<code>true</code>不会隐式转换为1, <code>false</code>也不会隐式转换为0, 反之亦然, <code>java</code>也是这样</li><li><code>go</code>语言中字符串是不可变的, 跟<code>java</code>是一样的, 为什么它们都是不可变的呢? 我只能想到一个原因共享提升性能</li><li><code>go</code>中字符串的<code>len</code>返回的是字节的个数, <code>java</code>中返回的字符的个数</li><li>字符串中汉字的自然编码顺序等于拼音的顺序吗? 应该是不等于, 有些非常少用的汉字, 拼音靠前, 不会在65536个常用字符中, 常用字符的编码应该是很小的</li><li><code>go</code>中字符串不能简单的看成字符的数组, 字符串是不可变的, 而数组是会相互影响的</li><li><code>go</code>的字符串支持<code>[]</code>来取值, <code>java</code>不支持<code>[]</code>, 但有<code>charAt</code>函数</li><li><code>go</code>支持`扩起来的原生字符串, <code>java</code>支持吗</li><li><code>UTF-8</code>大小为<code>1</code>到<code>4</code>字节, 那对于4位的<code>unicode</code>码点, 是不是有可能放不下呢?</li><li><code>go</code>语言字符串不是<code>rune</code>的数组, 直接就是<code>UTF-8</code>编码好的字节流,, 跟<code>java</code>完全不一样. 那怎么取第几个字节呢? 使用<code>utf8.DecodeRuneInString</code>来解码, 或使用<code>range</code>, <code>range</code>自动就是按字符读取的, 那我就想取第<code>i</code>个字符呢? 可以将<code>string</code>转为<code>rune</code>数组, 这丫就可以取了, 感觉<code>go</code>语言使用<code>string</code>还是好没必要, 几乎每什么用. 那要向<code>java</code>那样使用字符串, 还要利用<code>string</code>来赋值, 再转乘<code>[]rune</code>来使用, <code>rune</code>可以用字符字面量, <code>unicode</code>码点, 对于小于256的字符, 还可以使用<code>\x</code>, 好像每啥用, <code>string</code>可以字符串字面量, <code>UTF-8</code>字节序列, 和<code>unicode</code>码点序列</li><li><code>go</code>语言和<code>c</code>语言都有<code>scanf</code>, 但<code>java</code>没有, 但<code>java</code>应该有从字符串提取出值的办法</li><li><code>go</code>中每种常量的潜在类型都是基础类型, 那是说只要潜在类型为基础类型的, 就能是常量吗?</li><li><code>go</code>中<code>const</code>和<code>type</code>都可以使用括号来同时定义多个</li><li><code>go</code>中常量间的所有算术运算, 逻辑运算和比较运输的结果也是常量, 对于常量的类型转换操作或部分函数也是常数, 常数就是提升了一点可读性和性能, 好像也没有什么大作用</li><li><code>go</code>中通过<code>%T</code>来打印类型, <code>java</code>可以通过打印类名</li><li><code>go</code>语言常量也一些简化的赋值方式, 还有一个作用相当有限的<code>itoa</code>关键字来赋值, 感觉没有什么必要</li><li><code>go</code>中字面量称为无类型常量, 无类型常量可以自己转为声明的类型, 如果没有声明类型, 就是<code>go</code>定义的规则指定的类型, 算术运算也是同理, 这跟<code>c</code>和<code>java</code>中字面量有默认的类型不同</li><li>零大小的数组有什么用? 零大小的接口和数据结构对于go语言好像有bug</li><li><code>go</code>中<code>var a [3]int</code>和<code>var b [4]int</code>, <code>a</code>和<code>b</code>是不同类型, 不能相互赋值, 在<code>c</code>语言中也是一样. 但在<code>java</code>中长度不会导致数组类型不一样, 而且定义数组变量时, 也没有指定长度. <code>java</code>中数组怎么初始化的呢? 会有默认值吗</li><li><code>go</code>语言中数组的相等判断非常奇怪, 只有数据类型, 长度, 且数据类型能比较的情况下, 数组才能比较, 否则会报错. 当数据长度, 且数据值相等时, 才相等. 能比较的数据结构, 不是只有基础数据结构, 结构体支持吗</li><li><code>go</code>语言传递数组时, 是会挨个复制数组值的, 这个跟<code>c</code>和<code>java</code>都是不一样的. 可以说是多了一种防止修改数组的方式</li><li><code>go</code>对指向数组的指针是可以直接便利的, <code>ptr[i]</code>和<code>(*ptr)[i]</code>的效果是一样的, 在<code>range</code>中<code>ptr</code>和<code>(*ptr)</code>也是一样的, 这很离谱</li><li><code>go</code>语言数组和<code>slice</code>的语法很难区分, 只有定义的时候, <code>slice</code>的<code>[]</code>不写值, 而数组是需要指定大小或者<code>...</code>. <code>len</code>和<code>cap</code>既可以运用于数组, 也可以用于<code>slice</code>. <code>s[i:j]</code>切片操作中<code>j</code>可以超过<code>len</code>, 但不能超过<code>cap</code>, 真的无语, 切片操作可以用在数组和<code>slice</code>上, 切出来是<code>slice</code></li><li><code>go</code>语言的<code>slice</code>不支持比较, <code>java</code>的是支持的, <code>go</code>语言面向对象的特性太差了. 是怕<code>slice</code>自己引用自己吗, <code>java</code>不也有这种问题吗, 那为什么<code>java</code>可以比较. </li><li>不要用可变类型作为<code>map</code>的<code>key</code>, 无论是<code>go</code>还是<code>java</code>, <code>key</code>如果变了, <code>hash没变</code>会导致位置不变, 如果引用了同一个<code>key</code>, 会导致判断不出<code>key</code>已经存在, 或者相等. 放入<code>map</code>后, <code>key</code>的<code>hash</code>值应该是不会在变了, 不然还要<code>watch</code>, <code>key</code>的值变没有, 太消耗性能了, 这只是一个推测还没有自我验证过.</li><li>这本书说了两个理由, 都无法说明<code>go</code>的<code>slice</code>为啥不能比较, 吐了</li><li><code>slice</code>只能和<code>nil</code>比较, 可以用<code>[]int(nil)</code>或<code>nil</code>来赋值给以<code>slice</code>变量, <code>nil</code>可以赋值给指针和引用类型, 接口类型算引用类型吗, 结构体可以用<code>nil</code>赋值吗</li><li><code>go</code>中<code>len</code>和<code>cap</code>为0的<code>slice</code>, 就可以为<code>nil</code>, 也可以不为<code>nil</code>. 为<code>nil</code>的<code>sclie</code>底层没有引用数组,  <code>go</code>中<code>nil</code>有什么用呢???</li><li><code>go</code>的<code>printf</code>怎么用的, 数组怎么打印, 类型怎么打印</li><li><code>go</code>语言中<code>copy</code>函数就只能用于数组的复制吗? 能使用的范围太小了吧,<code>append</code>也只能用于<code>slice</code>吗</li><li><code>go</code>语言中<code>var x, y []int</code>可以声明多个<code>slice</code>, 那声明多个指针呢? 指针能<code>var x, y *int</code>这么写吗</li><li><code>go</code>语言支持可变参数, <code>java</code>支持吗? 可变参数可以用<code>slice</code>来实现, 那直接用<code>slice</code>来传参数不行吗, 就为了调用函数时写起来好看吗</li><li>go程序设计语言没有教<code>delete</code>的用法, 无语, 增删改查, 不应该是最重要的吗, <code>go</code>中数组删除是自己用分片来实现吗? <code>delete</code>是用来删除<code>map</code>中的元素的</li><li><code>go</code>语言中<code>cap</code>有必要让<code>go</code>语言使用者感知到吗? 真不知道有什么用, <code>java</code>是没有让使用者感知到的</li><li><code>go</code>的<code>map</code>中<code>key</code>必须是支持<code>==</code>的, 可是<code>go</code>中结构体支持<code>==</code>吗, 我认为应该必须得支持, 不然<code>map</code>也太鸡肋了, 确认了, 结构体是支持<code>==</code></li><li><code>go</code>中在<code>map</code>中取值时, 如果<code>key</code>不存在, 返回的是零值, 其实也只能这样, 总不能报错吧</li><li><code>go</code>中不能对<code>map</code>中的<code>value</code>取地址, <code>value</code>是会移动, 地址可能会随时失效. 地址的抽象程度太低了, 很容易受别的因素变化</li><li><code>go</code>语言中<code>map</code>的零值是<code>nil</code>, 这时<code>map</code>没有引用任何哈希表, <code>nil</code>的<code>slice</code>和空的<code>slice</code>几乎没有差别, <code>nil</code>的<code>map</code>无法添加值, 毕竟<code>append</code>函数是有能力自己创建新<code>slice</code>的</li><li><code>go</code>语言中<code>map</code>是无法比较的, 除了和<code>nil</code>, 这个是和<code>slice</code>是一致的. <code>java</code>中<code>List</code>和<code>Map</code>是能比较的吗</li><li><code>go</code>语言中<code>len</code>函数可以运用于<code>map</code></li><li><code>go</code>中0个值的聚合体有什么用呢? </li><li><code>go</code>语言中点操作符可以用于指向结构体的指针, 这是什么骚操作, 直接用<code>-&gt;</code>不好吗, 这样很容易把结构体和结构体指针弄混, <code>go</code>语言中指针是不能用<code>-&gt;</code>, 好像都没有这个操作符.</li><li><code>go</code>中调用函数返回的是值, 并不是一个可取地址的变量. 头一次在编程语言中听说这种说法. <code>c</code>语言会有这种问题吗? 应该会有吧, 没有验证过</li><li><code>go</code>中定义结构体时, 成员的顺序不同, 会导致定义的结构体不同, 那这种不同体现在哪里呢? 不是有类型名称来做区分了吗? 简直无法理解</li><li><code>go</code>语言中结构体的导出, 也是根据首字母的大小写来判断的, 导出能在包外访问, 没有导出的, 只能在包内访问</li><li><code>go</code>语言中一个命名为S的结构体类型不能再包含S类型的成员. 但是S类型的结构体可以包含<code>*S</code>指针类型的成员, <code>c</code>和<code>java</code>是怎样的呢</li><li><code>go</code>中为什么结构体字面量可以取地址, 而整数不行? 看不懂看不懂</li><li><code>go</code>语言中结构体的比较, 限制好大, 而且非常不灵活. <code>go</code>要求结构体的所有成员都必须可以比较, 而且必须全部相等, 这比<code>java</code>差太多了</li><li><code>go</code>的匿名成员机制, 也没有啥用呀, 就是为了使用成员时不用写出中间的成员. 如果有多个相同类型的成员呢? 而且结构体的命名还会影响导出, 又是一个鸡肋的东西. 唯一的用处可以获得匿名成员的方法, 其实可以把匿名成员当成继承来用</li><li>编程语言中第一类值或第一公民, 指的是能被赋值, 拥有类型的类型, <code>go</code>中函数是有类型的, <code>c</code>也是, <code>java</code>中函数只能放在<code>class</code>中, 不能被赋值啥的</li><li><code>go</code>中函数值的零值是<code>nil</code>, 当调用<code>nil</code>时会发生<code>panic</code>, 同时函数值是不能比较的, 只能和<code>nil</code>比较. 那是不是<code>go</code>中每种类型都要记一下能不能比较呢, 感觉容易出现混乱. 现在不能比较的是<code>slice</code>, <code>map</code>, 函数</li><li>匿名函数可以访问外部函数的变量, 有点像<code>java</code>的匿名类, 当访问外部变量这种用法, 还是有些高级, 不知到该用在什么地方, 不用这种高级用法, 用传参数可以吗</li><li>闭包是什么意思, <code>go</code>中函数值也被称为闭包, 闭包是一种很底层的概念了吧</li><li><code>go</code>程序设计语言举的例子都不简单, 真的垃圾</li><li><code>go</code>中函数值使用外部的变量的时, 非常容易出现<code>bug</code>, 使用所有值都是地址, 又是一个坑呀</li><li><code>go</code>中<code>Printf</code>是可变参数吗, 为什么它可以任意类型呢? 自己可变参数只能是同一类型的, <code>Printf</code>用的是<code>interface&#123;&#125;</code>类型, 这个类型有点像<code>java</code>中的<code>object</code></li><li>可变参数可以用<code>slice</code>来实现, 那多一种语法其实也没有什么必要, 可以看作是一种语法糖</li><li><code>go</code>语言中<code>defer</code>的作用跟<code>finally</code>差不多, 但是使用的位置是不同的, 同时<code>defer</code>调用的顺序是相反的. <code>defer</code>有一个很独特的操作<code>func ()()</code>, 它只会在函数结束后调用最后一个函数, 前面的函数会在使用<code>defer</code>的地方被调用. 这就实现了, 使用前调用和使用后调用的结果, 很像<code>aop</code>, <code>defer</code>能实现的东西<code>finally</code>也能实现, 但是<code>defer</code>的写法更好看一些</li><li>什么是异常呢? 就是调用者本应该遵守规则去使用某个函数, 但使用时却违反规则去使用. 什么时候使用<code>err</code>, 调用者遵守了规则, 但是实现者发现因为某种原因, 无法给出正确的结果. 说到底, 就是谁负责. </li><li><code>go</code>中结构体的成员和方法共用一个命名空间, 就是成员和方法的名称不能相同. <code>java</code>中成员方法应该是可以同名的吧</li><li><code>go</code>中方法可以被声明到任意类型, 只要不是一个指针或者一个<code>interface</code>, <code>interface</code>不能有方法我能理解, 毕竟自己定义时已经写了, 为什么指针也不能有方法呢? 不明白, 也许设计如此吧</li><li><code>go</code>中调用方法是不是有两种方式, 一种是对象<code>.</code>语法, 另一种是函数类似的调用, 用第一参数作为对象, 应该是有两种的. 为什么有两种呢? 第一种是第二种的语法糖, 这是我认为的, 其实也是非常合理的</li><li><code>go</code>语言中指针可以调用类型的方法, 类型也可以调用指针的方法前提是它是变量, 不是字面量, 那为什么地址字面量可以调用类型的方法呢? 到底什么是字面量啊), 这当中<code>go</code>会存在隐式转换, 语法糖太多了, 让初学者很困惑, 垃圾. 如果指针和类型, 都声明了同名称方法, 这样会有什么后果, 或者这样是在同一个命名中的. 应该是在同一个命名空间中的吧. 验证出来, 是在同一个命名空间中的, 这样挺合理, 不然就太混乱了 </li><li><code>go</code>语言允许类型的<code>nil</code>来调用方法, 跟<code>java</code>不一样, <code>java</code>会报空指针异常的</li><li><code>go</code>中结构体除了能内嵌类型, 还能内嵌指针, 内嵌指针有什么用呢? 其实没有什么区别, 除了利用指针可以共享同一个对象.</li><li><code>go</code>中除了匿名函数, 还有匿名结构, 但是匿名结构没有地方也方法, 不像<code>java</code>匿名类可以在块中写方法. 但是<code>go</code>匿名结构中匿名成员能带来一些方法, 算是一种有效的弥补手段吧. 匿名函数和匿名结构, 一般什么时候会用呢? 一个函数或结构只会被用一次时, 可以懒得取方法, 还是非常有用的, 取名字可太麻烦了</li><li><code>go</code>中接口是隐式实现的, <code>java</code>中需要自己写明, 这两个有什么区别呢? 隐式可以让旧的类实现新实现的方, 但是<code>java</code>可以用适配器模式来实现, 说到底, 其实也没有啥区别是吗? 就是稍微方便点</li><li>面向接口编程是指导思想, <code>LSP</code>是面向接口编程的实现的要求和规则</li><li><code>go</code>中<code>for</code>循环对于<code>string</code>有特殊的操作, <code>slice</code>和<code>string</code>也有特殊操作, <code>[]byte(&quot;霄剑&quot;)</code>可以直接变成<code>UTF8</code>编码的字节<code>slice</code></li><li><code>go</code>中结构体和接口都有内嵌语法, 还有别的类型有这种语法吗? </li><li><code>go</code>值接收器和指针接收器有很多不同的, 太坑了. 既然值接收器会生成一个指针接收器的方法, 那为啥用指针类型调用方法时, 还要编译器来解引用呢? 不是已经生成了指针接收器的方法了吗? 搞不懂</li><li><code>go</code>语言中匿名结构体可以有相同名称的方法, 例如<code>String</code>方法, 如果有两个匿名结构体都有<code>String</code>方法, 编译会报错, 这个有点像多继承带来的问题</li><li><code>go</code>语言结构体字面量可以取地址, <code>c</code>语言不行, 我认为这应该又是<code>go</code>语言的语法糖</li><li><code>go</code>中接口是可以比较的, 但是接口的动态类型不能比较的话, 会报<code>panic</code>, 还有一个问题, 接口比较有什么用呢? 这又是什么骚操作</li><li><code>go</code>中实现排序需要实现三个方法, <code>java</code>中只需要实现一个方法, <code>c</code>语言中是怎么实现的呢? </li><li><code>go</code>中类型断言和转型的语法很像. <code>x.(T)</code>和<code>T(x)</code>, 真的像. 类型断言中<code>x</code>只能是接口, <code>T</code>可以是接口或者类型. 当<code>x</code>为<code>nil</code>时, 会报<code>panic</code>. 类型断言是反多态的, 在<code>java</code>中是非常不值得推荐的. <code>go</code>却非常推荐, 我觉得应该时不值得推荐的, 毕竟违反了多态,当然特例情况也是存在的, 具体类型有更好解决方案时, 可以使用断言</li><li>子类型多态和非参数多态(可识别联合), 子类型多态是抽象, 隐藏细节, 而非参数多态是将接口强制转成特定类型, 那在<code>java</code>中是不是把<code>object</code>接收值再转成各种类型, 只能说很像, 这种做法面向对象不是不提倡吗? 也不是面向对象编程的使用接口的目的, 真是各种用法都有, 只要有用就行. 这种用法在<code>go</code>语言中有一种语法来支持, 叫类型开关, <code>x.(type)</code>, <code>java</code>中有类似的语法吗? </li><li>类型开关在单一类型的<code>case</code>内部, 才会进行类型转换, 在其他情况下都是没有转换之前的值. 行为挺奇怪的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> 问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2024/01/28/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/01/28/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>为什么要使用单例模式</li></ul><span id="more"></span><h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><h3 id="处理资源访问冲突"><a href="#处理资源访问冲突" class="headerlink" title="处理资源访问冲突"></a>处理资源访问冲突</h3><p>多个对象使用同一个资源时, 资源可能发生冲突. 例如多个对象写同一个文件, 写入的东西就有可能会被别人覆盖, 如果只允许一个对象往文件中写, 就不会有冲突. 可以让别的对象只使用一个对象写文件, 这个写对象要加对象级别的锁. </p><h3 id="表示全局唯一类"><a href="#表示全局唯一类" class="headerlink" title="表示全局唯一类"></a>表示全局唯一类</h3><p>例如配置文件, 当配置文件被加入到内存后, 以对象方式存在, 应该只存在一份.</p><h2 id="如何实现一个单例"><a href="#如何实现一个单例" class="headerlink" title="如何实现一个单例"></a>如何实现一个单例</h2>]]></content>
      
      
      <categories>
          
          <category> 编程思想 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引言</title>
      <link href="/2023/12/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(pytorch)/%E5%BC%95%E8%A8%80/"/>
      <url>/2023/12/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(pytorch)/%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评价代码质量的标准</title>
      <link href="/2023/11/26/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AF%84%E4%BB%B7%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84%E6%A0%87%E5%87%86/"/>
      <url>/2023/11/26/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AF%84%E4%BB%B7%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<ul><li>为什么要学习设计模式</li><li>如何评价代码的好坏</li><li>面向对象, 设计原则, 设计模式, 编程规范, 重构都是什么</li><li>面向对象, 设计原则, 设计模式, 编程规范, 重构有何关系</li><li>什么是面向对象编程和面向对象编程语言</li><li>如何判定一门语言是否是面向对象编程语言</li><li>面向对象编程和面向对象编程之间的关系</li><li>什么是面向对象分析和面向对象设计</li><li>面向对象的四大特性是什么, 它们的作用分别是什么</li><li>什么是面向过程编程和面向过程编程语言</li><li>面向对象编程相比面向过程有哪些优势</li><li>有在开发过程中, 有哪些操作是在进行面向过程编程</li><li>为什么在面向对象编程时, 容易写出面向过程的代码</li><li>面向过程编程就真的没有用了吗</li><li>抽象类和接口有什么区别? 分别是为了解决什么问题</li><li>如何用抽象类和普通类模拟接口</li><li>如何决定该用抽象类还是接口</li><li>如何理解”基于接口而非实现编程”中”接口”二字</li><li>如何定义一个好的接口</li><li>是否需要为每个类定义接口</li><li>为什么不推荐继承</li><li>什么是基于贫血模型的开发模式</li><li>什么是基于充血模型的开发模式</li><li>什么是重放攻击</li><li>如何面向对象分析和设计</li><li>如何判断类的职责是否足够单一</li><li>判断类的职责是否单一的几个技巧</li><li>类的职责是否设计得越单一越好</li><li>如何理解”对扩展开放, 修改关闭”</li><li>如何理解”里氏替换”</li><li>“里氏替换”的目的</li><li>如何理解”接口隔离原则”</li><li>“接口隔离原则”的三种应用</li><li>什么是”控制反转”</li><li>什么是”依赖注入”</li><li>什么是”依赖注入框架”</li><li>怎么理解”依赖反转原则”</li><li>什么是<code>KISS</code>原则和<code>YANGI</code>原则</li><li>如何提高代码复用性</li><li>什么是”高内聚”和”松耦合”</li><li>“高内聚”和”松耦合”之间的关系</li><li>什么是”迪米特法则”</li><li>如何实践”高内聚”和”松耦合”</li><li>为什么要重构, 重构的对象是什么, 什么时候进行重构</li><li>什么是单元测试, 为什么要编写单元测试</li><li>什么是代码的可测试性, 常见的测试性不友好的代码</li><li>“解耦”为什么非常重要</li></ul><span id="more"></span><h2 id="为什么说每个程序员都要尽早地学习并掌握设计模式相关知识"><a href="#为什么说每个程序员都要尽早地学习并掌握设计模式相关知识" class="headerlink" title="为什么说每个程序员都要尽早地学习并掌握设计模式相关知识?"></a>为什么说每个程序员都要尽早地学习并掌握设计模式相关知识?</h2><p>如果说数据结构和算法是教你如何写出高效代码, 那设计模式讲的是如何写出可扩展, 可读, 可维护的高质量代码.</p><h3 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h3><ul><li>应对面试中的设计模式相关问题</li><li>提高复杂代码的设计和开发能力</li><li>让读源码, 学框架事半功倍</li><li>为你的职场发展做铺垫</li></ul><h2 id="从哪些维度评价代码质量的好坏-如何具备写出高质量代码的能力"><a href="#从哪些维度评价代码质量的好坏-如何具备写出高质量代码的能力" class="headerlink" title="从哪些维度评价代码质量的好坏? 如何具备写出高质量代码的能力"></a>从哪些维度评价代码质量的好坏? 如何具备写出高质量代码的能力</h2><h3 id="最常用的评价标准有哪几个"><a href="#最常用的评价标准有哪几个" class="headerlink" title="最常用的评价标准有哪几个"></a>最常用的评价标准有哪几个</h3><ul><li><p>可维护性: <strong>可维护性</strong>, 所谓维护就是修改<code>bug</code>, 修改老的代码, 增加新的代码. “代码易维护”就是值能很容易的修改老代码, 在老代码上添加新的功能.</p></li><li><p>可读性: 这个主要是看代码是否符合编码规范. </p></li><li><p>可扩展性: 它表示了我们代码应对未来需求变化的能力, 我们在不修改或少量修改原有代码的情况下, 通过扩展的方式添加新的功能代码.</p></li><li><p>可理解性: 别人能否很容易理解代码. </p></li><li><p>可复用性: 写的代码能否被很多人使用.</p></li></ul><h3 id="如何才能写出高质量的代码"><a href="#如何才能写出高质量的代码" class="headerlink" title="如何才能写出高质量的代码"></a>如何才能写出高质量的代码</h3><p>要写出满足满足可维护性, 可读性, 可扩展性, 可理解性, 可复用性的代码, 我们需要掌握一些更加细化, 更加能落地的编程方法论, 包括面向对象设计思想, 设计原则, 设计模式, 编码规范, 重构技巧等.</p><h2 id="面向对象-设计原则-设计模式-编程规范-重构-这五者有何关系"><a href="#面向对象-设计原则-设计模式-编程规范-重构-这五者有何关系" class="headerlink" title="面向对象, 设计原则, 设计模式, 编程规范, 重构, 这五者有何关系?"></a>面向对象, 设计原则, 设计模式, 编程规范, 重构, 这五者有何关系?</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>主流的编程范式或者时编程风格有三种, 它们分别是面向过程, 面向对象和函数式编程. 面向对象这种编程风格又是这其中最主流的. 现在比较流行的编程语言大部分都是面向对象编程语言. 大部分项目也都是基于面向对象编程风格开发的. 面向对象编程因为其具有丰富的特性(封装, 抽象, 继承, 多态), 可以实现很多复杂的设计思路, 是很多设计原则, 设计模式编码实现的基础.</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p><strong>设计原则</strong>是指导我们代码设计的一些经验总结. </p><p>常用的<strong>设计原则</strong>:</p><ul><li><code>SOLID</code>原则: 单一职责原则</li><li><code>SOLID</code>原则: 开闭原则</li><li><code>SOLID</code>原则: 里氏替换原则</li><li><code>SOLID</code>原则: 接口隔离原则</li><li><code>SOLID</code>原则: 依赖装置原则</li><li><code>DRY</code>原则, <code>KISS</code>原则, <code>YAGNI</code>原则, <code>LOD</code>法则</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><strong>设计模式</strong>是针对软件开发中经常遇到的一些设计问题, 总结出来的一套解决方案或者设计思路.</p><h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><p><strong>编程规范</strong>主要解决的是代码的可读性问题.</p><h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>在软件开发过程中, 只要软件在不停地迭代, 就没有一劳永逸的设计. 随着需求的变化, 代码的不停堆砌, 原有的设计必定会存在这样那样的问题. 针对这些问题, 我们就需要进行代码重构. <strong>重构</strong>是软件开发过程中非常重要的一个环节. 持续重构是保持代码质量不下降的有效手段, 能有效比买呢代码腐化到无可救药的地步. </p><h3 id="五者之间的关系"><a href="#五者之间的关系" class="headerlink" title="五者之间的关系"></a>五者之间的关系</h3><ol><li><p><strong>面向对象编程</strong>因为具有丰富的特性(封装, 抽象, 继承, 多态), 可以实现很多复杂的设计思路, 是很多设计原则, 设计模式等编码实现的基础.</p></li><li><p><strong>设计原则</strong>是指导我们代码设计的一些经验总结.</p></li><li><p><strong>设计模式</strong>是针对软件开发过程中遇到的一些问题, 总结出来的一套解决方案或者设计思路. 应用设计模式的主要目的是提高代码的可扩展性. 从抽象程度上来讲, 设计原则比设计默哀时更加抽象. 设计模式更加juti,更加可执行.</p></li><li><p><strong>编程规范</strong>主要解决的是代码的可读性问题.</p></li><li><p><strong>重构</strong>作为保持代码质量不下降的有效手段, 利用的就是面向对象, 设计原则, 设计模式, 编程规范这些理论.</p></li></ol><h2 id="理论一-当讨论面向对象的时候-我们到底在谈论什么"><a href="#理论一-当讨论面向对象的时候-我们到底在谈论什么" class="headerlink" title="理论一: 当讨论面向对象的时候, 我们到底在谈论什么?"></a>理论一: 当讨论面向对象的时候, 我们到底在谈论什么?</h2><h3 id="什么是面向对象编程和面向对象编程语言"><a href="#什么是面向对象编程和面向对象编程语言" class="headerlink" title="什么是面向对象编程和面向对象编程语言?"></a>什么是面向对象编程和面向对象编程语言?</h3><p><strong>面向对象编程</strong>是一种编程范式或编程风格. 它以类或者对象作为组织代码的基本单元, 并将封装, 继承, 多态三个特性, 作为代码设计和实现的基石.</p><p><strong>面向对象编程语言</strong>是支持类或者对象的语法机制, 并有现成的语法机制, 能方便地实现面向对象三大特性的编程语言. </p><h3 id="如何判定一个编程语言是否是面向对象编程语言"><a href="#如何判定一个编程语言是否是面向对象编程语言" class="headerlink" title="如何判定一个编程语言是否是面向对象编程语言"></a>如何判定一个编程语言是否是面向对象编程语言</h3><p>如果严格按照定义, 需要有现成的语法支持类, 对象, 三大特性才能叫作面向对象编程语言. 如果放宽要求的话, 只要某种编程语言支持类, 对象语法机制, 那基本上就可以说这种编程语言是面向对象编程语言了, 并不一定非得要求具有所有的三大特性.</p><h3 id="面向对象编程和面向对象编程语言之间有何关系"><a href="#面向对象编程和面向对象编程语言之间有何关系" class="headerlink" title="面向对象编程和面向对象编程语言之间有何关系"></a>面向对象编程和面向对象编程语言之间有何关系</h3><p>面向对象编程一般使用面向对象变成语言来进行, 但是, 不用面向对象编程语言, 我们照样可以进行面向对象编程. 反过来说, 即便我们使用面向对象编程语言, 写出来的代码也不一定是面向对象编程风格的, 也有可能是面向过程编程风格的. </p><h3 id="什么是面向对象分析和面向对象设计"><a href="#什么是面向对象分析和面向对象设计" class="headerlink" title="什么是面向对象分析和面向对象设计"></a>什么是面向对象分析和面向对象设计</h3><p>简单点讲, 面向对象分析就是要搞清楚做做什么, 面向对象设计就是要搞清楚怎么做. 两个阶段最终的产出就是类的设计, 包括程序被拆解为哪些类, 每个类有哪些属性方法, 类与类之间如何交互等等. </p><h2 id="封装-抽象-继承-多态分别可以解决哪些编程问题"><a href="#封装-抽象-继承-多态分别可以解决哪些编程问题" class="headerlink" title="封装, 抽象, 继承, 多态分别可以解决哪些编程问题"></a>封装, 抽象, 继承, 多态分别可以解决哪些编程问题</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装</strong>也叫做信息隐藏或者数据访问保护. 类通过暴露有限的访问接口, 授权外部仅能通过类提供的方式(或者叫函数)来访问信息或者数据. </p><p>如果我们对类中属性的访问不做限制, 那任何代码都可以访问, 修改类中的属性, 虽然这样看起来很灵活, 但从另一方面来说, 过度灵活也意味着不可控, 属性可以随意被各种奇葩的方式修改.</p><p>除此之外, 类仅仅通过有限的方法暴露必要的操作, 也能提供类的易用性. 如果我们把类属性都暴露给类的调用者, 调用者想要正确地操作这些属性, 就势必要对业务细节有足够的了解. 而这对于调用者来说也是一种负担. 相反, 如果我们将属性分装起来, 暴露少许的几个必要的方法给调用者, 调用者就不需要了解太多背后的细节业务, 用错的概率就减少很多.</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p><strong>封装</strong>主要讲的是如何隐藏信息, 保护数据, 而抽象讲的是如何隐藏方法的具体实现, 让调用者只需要关心方法提供了哪些功能, 并不需要知道这些功能是如何实现的.</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承</strong>最大的好处就是代码复用. 我们也可以通过其他方式来解决这个代码复用的问题, 比如利用组合.</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态</strong>是指, 子类可以替换父类或接口, 在实际运行过程中, 调用子类实现的方法. 除了利用”继承加方法重写”这种实现方式外, 我们还有其他两种比较常见的实现方式, 一个是利用接口类语法, 另一个是利用<code>duck-typing</code>语法.</p><p><code>duck-typing</code>是编程语言中动态类型语言中的一种设计风格, 一个对象的特性不是由父类决定的, 而是通过对象的方法决定.</p><p><strong>多态</strong>特性能提高代码的可扩展性和复用性, 是很多设计原则, 设计模式的基础.</p><h2 id="理论三-面向对象相比面向过程有哪些优势-面向过程真的过时了吗"><a href="#理论三-面向对象相比面向过程有哪些优势-面向过程真的过时了吗" class="headerlink" title="理论三: 面向对象相比面向过程有哪些优势? 面向过程真的过时了吗?"></a>理论三: 面向对象相比面向过程有哪些优势? 面向过程真的过时了吗?</h2><h3 id="什么是面向过程编程与面向过程编程语言"><a href="#什么是面向过程编程与面向过程编程语言" class="headerlink" title="什么是面向过程编程与面向过程编程语言"></a>什么是面向过程编程与面向过程编程语言</h3><p><strong>面向过程编程</strong>也是一种编程范式或编程风格. 它以函数作为组织代码的基本单元, 以数据与方法相分离为主要的特点. 面向过程风格是一种流程化的编程风格, 通过拼接一组顺序执行的方法来操作数据完成一项功能.</p><p><strong>面向过程编程语言</strong>最大的特点时不支持类和对象两个语法概念, 不直接支持面向对象编程的特性(比如封装, 继承, 多态).</p><h3 id="面向对象编程相比面向过程编程有哪些优势"><a href="#面向对象编程相比面向过程编程有哪些优势" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势"></a>面向对象编程相比面向过程编程有哪些优势</h3><ul><li>OOP更能够应对大规模复杂程序的开发: 面向对象编程是以类为思考对象. 在面向对象编程的时候, 我们并不是一上来就去思考, 如何将复杂的流程拆解为一个一个方法, 而是先思考如何给业务建模, 如何将需求翻译为类, 如何给类之间建立交互关系, 而完成这些工作完全不需要思考错综复杂的处理流程. 当我们有了类的设计之后, 然后再像搭积木一样, 按照处理流程, 将类组织起来形成整个程序. 这种开发模式, 思考问题的方式, 能让我们在应对复杂程序开发的时候, 思路更加清晰. 除此之外, 免洗那个对象编程还提供了一种更加清晰的, 更加模块化的代码组织思路.</li><li>OOP风格更易复用, 易扩展, 易维护: 继承可以提高复用性, 多态可以让程序更扩展, 同时还能提高复用性, 封装让程序容易维护.</li></ul><h2 id="理论四-哪些代码设计看似时面向对象-实际是面向过程"><a href="#理论四-哪些代码设计看似时面向对象-实际是面向过程" class="headerlink" title="理论四: 哪些代码设计看似时面向对象, 实际是面向过程?"></a>理论四: 哪些代码设计看似时面向对象, 实际是面向过程?</h2><h3 id="哪些代码设计看似时面向对象-实际是面向过程"><a href="#哪些代码设计看似时面向对象-实际是面向过程" class="headerlink" title="哪些代码设计看似时面向对象, 实际是面向过程?"></a>哪些代码设计看似时面向对象, 实际是面向过程?</h3><h4 id="滥用getter-setter方法"><a href="#滥用getter-setter方法" class="headerlink" title="滥用getter, setter方法"></a>滥用<code>getter</code>, <code>setter</code>方法</h4><p>面向对象封装的定义是: 通过访问权限控制, 隐藏内部数据, 外部仅能通过类提供的游戏爱你接口访问, 修改内部数据. 所以, 暴露不应该暴露的<code>setter</code>方法, 明显违反了面向对象的封装特性. 数据没有访问权限控制, 任何代码都可以随意修改它, 代码就退化成面向过程编程风格的了.</p><h4 id="滥用全局变量和全局方法"><a href="#滥用全局变量和全局方法" class="headerlink" title="滥用全局变量和全局方法"></a>滥用全局变量和全局方法</h4><p>在面向对象编程中, 常见的全局变量有单例类对象, 静态成员, 常量等, 常见的方法有静态方法. 全局变量可以被很多对象访问, 没有办法进行权限访问控制, 而静态方法也没有和数据绑定, 可以操作很多静态变量.</p><p><code>Constants</code>类和<code>Utils</code>类是最常见的全局变量和全局方法, 它们其实是几乎是无法避免的. <code>Constants</code>类其实并不会带来太问题, 做好分类或者把常量定义在要使用的类中. <code>Utils</code>类是用来防止以写通用的静态方法, 这些方法要操作很多个类中的数据, 但这些类又不好抽象出一个父类, 这时可以把这些方法放在一起, 作为一个<code>Utils</code>类. 当然, 也可以可以把这些类中的数据抽象出一个父类, 把静态方法写为成员方法也行.</p><h4 id="定义数据和方法相分离的类"><a href="#定义数据和方法相分离的类" class="headerlink" title="定义数据和方法相分离的类"></a>定义数据和方法相分离的类</h4><p>在编写WEB项目时, 通常会定义定义<code>BO(Business)</code>, <code>Entity</code>类, 这些类中通常只会定义数据, 不会定义操作它们的方法, 所有操作这些数据的业务逻辑都定义在对应的<code>Controller</code>类, <code>Service</code>类, <code>Repository</code>类中, 这样数据和方法相分离了. 实际上, 这种开发模式叫做基于贫血模型的开发模式.</p><h3 id="在面向对象编程中-为什么容易写出面向过程风格代码"><a href="#在面向对象编程中-为什么容易写出面向过程风格代码" class="headerlink" title="在面向对象编程中, 为什么容易写出面向过程风格代码?"></a>在面向对象编程中, 为什么容易写出面向过程风格代码?</h3><p>因为人做一件事情时, 通常是先干什么, 再干什么, 这就是面向过程的思考方式, 自然而然, 也就很容写出面向过程的代码. 而面向对象编程, 是一种自底向上的思考方式, 先把任务分解成子任务, 在组合子任务, 这种模式适合复杂的事情, 人思考简单的事情时, 不会特意思考去分解任务.</p><h3 id="面向过程编程就真的没有用了吗"><a href="#面向过程编程就真的没有用了吗" class="headerlink" title="面向过程编程就真的没有用了吗?"></a>面向过程编程就真的没有用了吗?</h3><p>在编写简单的功能时, 使用面向过程编程更方便, 也更快捷. 面向对象编程中编写方法时, 其实就是在使用面向过程编程.</p><h2 id="理论五-接口VS抽象类的区别-如何用普通的类模拟抽象类和接口"><a href="#理论五-接口VS抽象类的区别-如何用普通的类模拟抽象类和接口" class="headerlink" title="理论五: 接口VS抽象类的区别? 如何用普通的类模拟抽象类和接口"></a>理论五: 接口<code>VS</code>抽象类的区别? 如何用普通的类模拟抽象类和接口</h2><p>在面向对象编程中, 抽象类和接口是两个经常被用到的语法概念, 是面向对象四大特性, 以及很多设计模式, 设计思想, 设计原则编程思想的基础. 比如, 我们可以使用借口来实现面向对象的抽象特性, 多态特性和基于接口而非实现的设计原则, 使用抽象类来实现面向对象继承特性和模版设计模式等等.</p><h3 id="抽象类和接口区别在哪里"><a href="#抽象类和接口区别在哪里" class="headerlink" title="抽象类和接口区别在哪里?"></a>抽象类和接口区别在哪里?</h3><p>从语法特性上来说, 接口不能拥有成员属性, 所有属性都是静态属性. 在java8之前, 接口不能拥有方法体, 8和8之后支持了静态方法和默认方法, 可以有方法体. 继承要求必须实现抽象方法, 而接口要求实现所有方法. 同时, 一个类只能继承一个类, 但是可以实现多个接口. 继承关系是一种<code>is-a</code>关系, 接口表示一种<code>has-a</code>关系, 表示具有某些功能.</p><h3 id="抽象类和接口能解决什么编程问题"><a href="#抽象类和接口能解决什么编程问题" class="headerlink" title="抽象类和接口能解决什么编程问题?"></a>抽象类和接口能解决什么编程问题?</h3><p>抽象类会被继承, 可以用来解决代码复用问题, 相比继承普通类, 可以实现自己不实现方法, 但要求子类必须实现的功能, 这种情况在设计父类时经常遇到.</p><p>抽象类更多是为了代码复用, 而接口更强调解耦, 隔离接口和具体实现, 提高代码的扩展性. 接口的实现对调用者透明, 不让调用者知道具体实现, 减少调用者使用方法的难度, 也让实现者更自由. 接口中没有成员属性, 只有方法, 因此定义了实现类能有怎样的行为, 是对行为的一种抽象. </p><h3 id="如何模拟抽象类和接口两个语法概念"><a href="#如何模拟抽象类和接口两个语法概念" class="headerlink" title="如何模拟抽象类和接口两个语法概念"></a>如何模拟抽象类和接口两个语法概念</h3><p>接口中没有成员变量, 只有方法声明, 没有方法实现, 实现接口的类必须实现接口中的所有方法.. 只要满足这样几点, 从设计的角度上来说, 我们就可以把它称为接口. 也就是抽象类没有成员方法, 所有方法都是抽象方法. 这时从语法特性上来说, 这个抽象类就相当于一个接口.</p><p>如果没有抽象类, 如何实现接口呢? 首先, 普通类没有成员属性, 所有的方法直接抛出异常来告诉实现类必须实现这些方法, 最后将构造器设置为<code>protected</code>, 来防止被包外的类初始化.</p><h3 id="如何决定该用抽象类还是接口"><a href="#如何决定该用抽象类还是接口" class="headerlink" title="如何决定该用抽象类还是接口"></a>如何决定该用抽象类还是接口</h3><p>实际上, 判断的标准很简单. 如果我们要表示一种<code>is-a</code>的关系, 并且是为了解决代码复用问题, 我们就用抽象类; 如果我们要表示一种<code>has-a</code>关系, 并且是为了解决抽象而非代码复用的问题, 那我们就可以使用接口.</p><p>从类的继承层次上来看, 抽象类是一种自下而上的设计思路, 先有子类的代码重复, 然后再抽象成上层父类. 而接口正好相反, 它是一种自上而下的设计思路. </p><p>我们在编程的时候, 一般都是先设计接口, 再考虑具体的实现, 发现有子类代码重复, 然后抽象成父类或抽象类.</p><h2 id="理论六-为什么基于接口而非实现编程-有必要为每个类都定义接口吗"><a href="#理论六-为什么基于接口而非实现编程-有必要为每个类都定义接口吗" class="headerlink" title="理论六: 为什么基于接口而非实现编程? 有必要为每个类都定义接口吗?"></a>理论六: 为什么基于接口而非实现编程? 有必要为每个类都定义接口吗?</h2><h3 id="如何解读原则中的”接口”二字"><a href="#如何解读原则中的”接口”二字" class="headerlink" title="如何解读原则中的”接口”二字"></a>如何解读原则中的”接口”二字</h3><p>“接口”就是一组”协议”或者”约定”, 是功能提供者提供给使用者的一个功能列表. 从编程语言上来说, 接口可以理解为接口类或者抽象类.</p><p>这条原则能非常有效地提高代码质量, 之所以这么说, 那是因为, 应用这条原则, 可以将接口和实现相分离, 封装不稳定的实现, 暴露稳定的接口. 上游系统面向接口而非实现编程, 不依赖不稳定的实现细节, 这样当实现发生变化的时候, 上游系统的代码基本不需要做改动, 以此来降低耦合性, 提高扩展性.</p><h3 id="如何设计一个好的接口"><a href="#如何设计一个好的接口" class="headerlink" title="如何设计一个好的接口"></a>如何设计一个好的接口</h3><p>在设计接口的时候, 我们要多思考一下, 这样的接口设计是否足够通用, 时是否能做到在替换具体的接口实现的时候, 不需要任何接口定义的改动.</p><h3 id="是否需要为每个类定义接口"><a href="#是否需要为每个类定义接口" class="headerlink" title="是否需要为每个类定义接口"></a>是否需要为每个类定义接口</h3><p>如果上游系统非常稳定, 实现的代码只可能有一种, 这时就没有必要去设计接口, 因为这时接口的实现只有这一种, 并不会体现接口带来的扩展性. 如果上游系统可以依赖多种实现, 这时才需要设计接口.</p><h2 id="理论七-为何说要多用组合少用继承-如何决定该用组合还是继承"><a href="#理论七-为何说要多用组合少用继承-如何决定该用组合还是继承" class="headerlink" title="理论七: 为何说要多用组合少用继承? 如何决定该用组合还是继承"></a>理论七: 为何说要多用组合少用继承? 如何决定该用组合还是继承</h2><h3 id="为什么不推荐使用继承"><a href="#为什么不推荐使用继承" class="headerlink" title="为什么不推荐使用继承"></a>为什么不推荐使用继承</h3><p>当一些类需要增加一些特性, 但是另外一些类又不需要增加这些特性时, 如果使用继承, 就需要新增加一个有这些特性的父类. 如果这样的场景很多, 就会有很多这样的父类, 会导致类的继承层次越来深, 继承关系会越来越复杂. 同时, 如果一个类既需要A特性, 也需要B特性, 在不支持多继承的语言中, 会有重复代码.</p><h2 id="实战一-上-业务开发常用的基于贫血模型的MVC架构违背OOP吗"><a href="#实战一-上-业务开发常用的基于贫血模型的MVC架构违背OOP吗" class="headerlink" title="实战一(上): 业务开发常用的基于贫血模型的MVC架构违背OOP吗?"></a>实战一(上): 业务开发常用的基于贫血模型的MVC架构违背OOP吗?</h2><h3 id="什么是基于贫血模型的开发模式"><a href="#什么是基于贫血模型的开发模式" class="headerlink" title="什么是基于贫血模型的开发模式"></a>什么是基于贫血模型的开发模式</h3><p>将<code>Entity</code>, <code>BO</code>, <code>VO</code>与<code>Repository</code>, <code>Business</code>, <code>Controller</code> 相互分离. <code>Entity</code>, <code>BO</code>, <code>VO</code>是纯粹的数据结构, 只包含数据, 不包含任何业务逻辑. 它们的操作都放在<code>Repository</code>, <code>Business</code>, <code>Controller</code>中, 这样的模型就是贫血模型. 这种贫血模型将数据与操作分离, 破坏了面向对象的封装特性, 是一种典型的面向过程的编程风格.</p><h3 id="什么是基于充血模型的开发模式"><a href="#什么是基于充血模型的开发模式" class="headerlink" title="什么是基于充血模型的开发模式"></a>什么是基于充血模型的开发模式</h3><p>在贫血模型中, 数据和业务逻辑被分割到不同的类中. 充血模型正好相反, 数据和对应的业务逻辑被封装到同一个类中. 因此, 这种充血模型满足面向对象的封装特性, 是典型的面向对象编程风格.</p><p>在基于贫血的传统开发模式中, <code>Service</code>层包含<code>Service</code>和<code>BO</code>类两个部分, <code>BO</code>是贫血模型, 只包含数据, 不包含具体的业务逻辑. 业务逻辑集中在<code>Service</code>类中. 在基于充血模型的开发模式中, <code>Service</code>层包含<code>Service</code>类中<code>Domain</code>类两部分. <code>Domain</code>就相当于贫血模型中的<code>BO</code>. 不过, <code>Domain</code>与<code>BO</code>的区别在于它是基于充血模型开发的, 既包含数据, 也包含业务逻辑. 而<code>Service</code>类变得非常单薄. 总结一下就是, 基于贫血模型的传统的开发模式, 重<code>Service</code>轻<code>BO</code>; 基于充血模型的开发模式, 轻<code>Service</code>重<code>Domain</code>.</p><h2 id="实战一-下-如何利用充血模型开发一个虚拟钱包系统"><a href="#实战一-下-如何利用充血模型开发一个虚拟钱包系统" class="headerlink" title="实战一(下): 如何利用充血模型开发一个虚拟钱包系统"></a>实战一(下): 如何利用充血模型开发一个虚拟钱包系统</h2><ol><li><p>将不用依赖别的<code>Domain</code>的业务逻辑放在<code>Domain</code>中.</p></li><li><p>使<code>Service</code>类负责与<code>Repository</code>交流.</p></li></ol><h2 id="实战二-上-如何对接口鉴权这样一个功能开发做面向对象分析"><a href="#实战二-上-如何对接口鉴权这样一个功能开发做面向对象分析" class="headerlink" title="实战二(上): 如何对接口鉴权这样一个功能开发做面向对象分析"></a>实战二(上): 如何对接口鉴权这样一个功能开发做面向对象分析</h2><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>拿着完全一样的信息, 发送请求. 这个信息可以不从通信过程中获得. 如果使用了<code>https</code>, 别人是无法获得这些信息的. 重放攻击无法避免, 服务器只能通过信息来判断, 如果信息完全相同, 服务器是无法知道发送方还是不是原来那个. 但是重放攻击可以减轻, 减少信息的有效时间, 可以防止别人拿这个信息一直用.</p><h2 id="实战二-下-如何利用面向对象设计和编程开发接口鉴权功能"><a href="#实战二-下-如何利用面向对象设计和编程开发接口鉴权功能" class="headerlink" title="实战二(下): 如何利用面向对象设计和编程开发接口鉴权功能"></a>实战二(下): 如何利用面向对象设计和编程开发接口鉴权功能</h2><p>面向对象分析的产出是详细的需求描述. 面向对象设计的产出是类. </p><h2 id="如何面向对象分析和设计"><a href="#如何面向对象分析和设计" class="headerlink" title="如何面向对象分析和设计"></a>如何面向对象分析和设计</h2><p>根据需求描述, 找到其中涉及的功能点, 一个一个罗列出来, 识别其中的动词, 作为候选方法. 然后在把功能点中涉及的名词, 作为候选属性. 然后把操作相同的属性的功能点, 看是否能归位一个类.</p><h2 id="理论一-对于单一职责原则-如何判定某个类的职责是否足够”单一”"><a href="#理论一-对于单一职责原则-如何判定某个类的职责是否足够”单一”" class="headerlink" title="理论一: 对于单一职责原则, 如何判定某个类的职责是否足够”单一”?"></a>理论一: 对于单一职责原则, 如何判定某个类的职责是否足够”单一”?</h2><h3 id="如何理解单一职责原则"><a href="#如何理解单一职责原则" class="headerlink" title="如何理解单一职责原则"></a>如何理解单一职责原则</h3><p>一个类只负责完成一个职责或者功能. 不要设计大而全的类, 要设计粒度小, 功能单一的类. 单一职责原则是为了实现代码高内聚, 低耦合, 提高代码的复用性, 可读性, 可维护性.</p><h3 id="如何判断类的职责是否足够单一"><a href="#如何判断类的职责是否足够单一" class="headerlink" title="如何判断类的职责是否足够单一"></a>如何判断类的职责是否足够单一</h3><p>不同的应用场景, 不同阶段的需求背景下, 对同一个类的职责是否单一的判定, 可能都是不一样的. 在某种应用场景或者当下的需求背景下, 一个类的设计可以已经满足单一职责原则了, 但如果换个应用场景或者在未来的某个需求背景下, 可能就不满足了, 需要继续拆分成粒度更细的类.</p><p>评价一个类的职责是否足够单一, 我们并没有一个非常明确的, 可以量化的标准, 可以说, 这是件非常主观, 仁者见仁智者见智的事情. 实际上, 在真正的软件开发中, 我们也没有必要过于未雨绸缪, 过度设计. 所以, 我们可以先写一个粗粒度的类, 满足业务需求. 随着业务的发展, 如果粗粒度的类越来越庞大, 代码越来越多, 这个时候, 我们就可以将这个粗粒度的类, 拆分成几个粒度更细的类. 这就是所谓的持续重构.</p><h3 id="判断类的职责是否足够单一的几个技巧"><a href="#判断类的职责是否足够单一的几个技巧" class="headerlink" title="判断类的职责是否足够单一的几个技巧"></a>判断类的职责是否足够单一的几个技巧</h3><ul><li>类中的代码行数, 函数或属性过多, 会影响代码的可读性和可维护性, 我们就需要考虑对类进行拆分.</li><li>类依赖的其他类过多, 不符合高内聚, 低耦合的设计思想, 我们就需要考虑对类进行拆分.</li><li>比较难给类起一个合适的名字, 很难用一个业务名词概括, 或者只能用一些笼统的<code>Manager</code>, <code>Context</code>之类的词语来命名, 这就说明类的职责定义得可能不够清晰.</li><li>类中大量的方法都是集中操作类中的某几个属性, 那就可以考虑将这几个属性和对应的方法拆出来.</li></ul><h3 id="类的职责是否设计得越单一越好"><a href="#类的职责是否设计得越单一越好" class="headerlink" title="类的职责是否设计得越单一越好"></a>类的职责是否设计得越单一越好</h3><p>比如说一个类有编码和解码两个方法, 你可以说这是两个功能, 给它分别放入到编码类和解码类中. 但是编码和解码通常是有联系的, 用一种方式编码, 就只能用特定的方式解码, 如果分开就有可能出现编码和解码不匹配的情况. 这个就是不满足高内聚带来的后果.</p><h2 id="理论二-如何做到”对扩展开放-修改关闭”-扩展和修改各指什么"><a href="#理论二-如何做到”对扩展开放-修改关闭”-扩展和修改各指什么" class="headerlink" title="理论二: 如何做到”对扩展开放, 修改关闭”? 扩展和修改各指什么?"></a>理论二: 如何做到”对扩展开放, 修改关闭”? 扩展和修改各指什么?</h2><h3 id="如何理解”对扩展开放-修改关闭”"><a href="#如何理解”对扩展开放-修改关闭”" class="headerlink" title="如何理解”对扩展开放, 修改关闭”"></a>如何理解”对扩展开放, 修改关闭”</h3><p>具体一点来说就是, 添加一个新的功能应该是, 在已有代码基础上扩展代码(新增模块, 类, 方法等), 而非修改已有代码(修改模块, 类, 方法等). 开闭原则并不是完全杜绝修改, 而是以最小的修改代码的代价来完成新功能的开发. 同时, 同样的代码改动, 在粗代码粒度下, 可能被认定为”修改”; 在细代码粒度下, 可能又被认定为”扩展”.</p><h2 id="理论三-里氏替换跟多态有何区别-哪些代码违背了里氏替换"><a href="#理论三-里氏替换跟多态有何区别-哪些代码违背了里氏替换" class="headerlink" title="理论三: 里氏替换跟多态有何区别? 哪些代码违背了里氏替换?"></a>理论三: 里氏替换跟多态有何区别? 哪些代码违背了里氏替换?</h2><h3 id="如何理解”里氏替换”"><a href="#如何理解”里氏替换”" class="headerlink" title="如何理解”里氏替换”"></a>如何理解”里氏替换”</h3><p>子类对象能替换程序中父类对象出现的任何地方, 并且保证原来程序的正确性不被破坏. 从定义描述和代码实现上看, 多态和里氏替换有点类似, 但它们关注的角度是不一样的. 多态面向对象语言的一种语法, 我们可以使用它来解决问题, 是一种代码实现的思路. 里氏替换是一种设计原则, 是用来指导继承关系中子类该如何设计, 子类的设计要保证在替换父类的时候, 不改变原有程序的逻辑以及破坏原有程序的正确性.</p><h3 id="“里氏替换”的目的"><a href="#“里氏替换”的目的" class="headerlink" title="“里氏替换”的目的"></a>“里氏替换”的目的</h3><p>里氏替换是为了要求子类遵守父类方法的功能描述.</p><h2 id="理论四-接口隔离原则有哪三种应用-原则中的”接口”该如何理解"><a href="#理论四-接口隔离原则有哪三种应用-原则中的”接口”该如何理解" class="headerlink" title="理论四: 接口隔离原则有哪三种应用? 原则中的”接口”该如何理解?"></a>理论四: 接口隔离原则有哪三种应用? 原则中的”接口”该如何理解?</h2><h3 id="如何理解”接口隔离原则”"><a href="#如何理解”接口隔离原则”" class="headerlink" title="如何理解”接口隔离原则”?"></a>如何理解”接口隔离原则”?</h3><p>客户端不应该强迫依赖它不需要的接口. 接口隔离原则可以看作实现单一职责的一种方式, 通过调用者如何使用接口来间接地判定. 如果调用者只使用部分”接口”或”接口”的部分功能, 那”接口”的设计就不够职责单一.</p><h3 id="接口隔离原则的三种应用"><a href="#接口隔离原则的三种应用" class="headerlink" title="接口隔离原则的三种应用"></a>接口隔离原则的三种应用</h3><ul><li>把”接口”认为是模块或类提供的一组<code>api</code>.</li><li>把”接口”认为是语言中类实现的接口.</li><li>把”接口”认为是一个方法声明.</li></ul><h2 id="理论五-控制反转-依赖反转-依赖注入-这三者有何区别和联系"><a href="#理论五-控制反转-依赖反转-依赖注入-这三者有何区别和联系" class="headerlink" title="理论五: 控制反转, 依赖反转, 依赖注入, 这三者有何区别和联系?"></a>理论五: 控制反转, 依赖反转, 依赖注入, 这三者有何区别和联系?</h2><h3 id="什么是”控制反转”"><a href="#什么是”控制反转”" class="headerlink" title="什么是”控制反转”"></a>什么是”控制反转”</h3><p>框架提供了一个扩展的代码骨架, 用来组装对象, 管理整个执行流程. 程序员利用框架进行开发的时候, 只需要往预留的扩展点上, 添加跟自己业务相关的代码, 就可以利用框架来驱动整个程序流程的执行.</p><p>这里的”控制”指的是对程序执行流程的控制, 而”反转”指的是在没有使用框架之前, 程序员自己控制整个程序的执行. 在使用框架之后, 整个程序的执行流程可以通过框架来控制. 流程的控制权从程序员”反转”到了框架.</p><p>实际上, 实现控制反转的方法很多, 除了刚才例子中所示的类似于模版设计模式的方法之外, 还有依赖注入等方法. 所以, 控制反转并不是一种具体的实现技巧, 而是一个比较笼统的设计思想, 一般用来指导框架层面的设计.</p><h3 id="什么是”依赖注入”"><a href="#什么是”依赖注入”" class="headerlink" title="什么是”依赖注入”"></a>什么是”依赖注入”</h3><p>依赖注入和控制反转恰恰相反, 它是一种具体的编码技巧.不通过<code>new()</code>的方式在类内部创建依赖类的对象, 而是将依赖的类对象在外部创建好之后, 通过构造函数, 函数参数等方式传递(或注入)给类使用.</p><h3 id="什么是”依赖注入框架”"><a href="#什么是”依赖注入框架”" class="headerlink" title="什么是”依赖注入框架”"></a>什么是”依赖注入框架”</h3><p>在采用依赖注入实现的类中, 虽然我们不需要用类似<code>hard code</code>的方式, 在类内部通过<code>new</code>来创建依赖对象, 但是, 这个创建对象, 组装(或注入)对象的工作仅仅是被移动到更上层代码而已, 还是需要我们程序员自己来实现.</p><p>在实际的软件开发中, 一些项目可能会涉及几十, 上百, 甚至几百个类, 类对象的创建和依赖注入会非常复杂. 如果这部分工作都是靠程序员自己写代码来完成, 容易出错且开发成本也比较高. 而对象创建和依赖注入的工作, 本身跟具体的业务无关, 我们完全可以抽象成框架来自动完成.</p><p>这个框架就是”依赖注入框架”. 我们只要通过依赖注入框架提供的扩展点, 简单配置一下所有需要创建的类对象, 类和类之间的依赖关系, 就可以实现有框架来自动创建对象, 管理对象的生命周期, 依赖注入等原本需要程序员来做的事情.</p><h3 id="怎么理解”依赖反转原则”"><a href="#怎么理解”依赖反转原则”" class="headerlink" title="怎么理解”依赖反转原则”"></a>怎么理解”依赖反转原则”</h3><p>高层模块不要依赖低层模块. 高层模块和低层模块应该通过抽象来相互依赖. 除此之外, 抽象不要依赖具体实现细节, 具体实现细节依赖抽象.</p><h3 id="“依赖注入”和”基于接口而非实现编程”的区别和联系"><a href="#“依赖注入”和”基于接口而非实现编程”的区别和联系" class="headerlink" title="“依赖注入”和”基于接口而非实现编程”的区别和联系"></a>“依赖注入”和”基于接口而非实现编程”的区别和联系</h3><p>依赖注入是一种具体的编程技巧, 关注的是对象创建和类之间的关系, 提高了代码的扩展性, 我们可以灵活地替换依赖的类.</p><p>基于接口而非实现编程是一种设计原则, 关注抽象和实现, 上下游调用的稳定性, 目的是降低耦合性, 提高扩展性.</p><p>它们都是基于开闭原则思路, 提高代码扩展性.</p><h2 id="理论六-我为何说KISS-YANGI原则看似简单-却经常被用错"><a href="#理论六-我为何说KISS-YANGI原则看似简单-却经常被用错" class="headerlink" title="理论六: 我为何说KISS, YANGI原则看似简单, 却经常被用错?"></a>理论六: 我为何说<code>KISS</code>, <code>YANGI</code>原则看似简单, 却经常被用错?</h2><h3 id="什么是KISS和YANGI原则"><a href="#什么是KISS和YANGI原则" class="headerlink" title="什么是KISS和YANGI原则"></a>什么是<code>KISS</code>和<code>YANGI</code>原则</h3><p><code>KISS</code>原则做事情尽量保持简单, <code>YANGI</code>原则你不需要它, 遇到现在不需要做的事情就不要做, 留下扩展点就行.</p><h2 id="理论七-重复的代码就一定违背DRY吗-如何提高代码的复用性"><a href="#理论七-重复的代码就一定违背DRY吗-如何提高代码的复用性" class="headerlink" title="理论七: 重复的代码就一定违背DRY吗? 如何提高代码的复用性?"></a>理论七: 重复的代码就一定违背<code>DRY</code>吗? 如何提高代码的复用性?</h2><p><code>DRY</code>不用重复你自己. 重复的代码通常违背<code>DRY</code>原则, 可以先用一个, 如何以后有特殊处理, 在抽出来就行.</p><h3 id="如何提高代码复用性"><a href="#如何提高代码复用性" class="headerlink" title="如何提高代码复用性"></a>如何提高代码复用性</h3><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>业务代码和业务代码逻辑分离</li><li>继承, 多态, 抽象, 封装</li><li>应用模版等设计模式</li></ul><h2 id="理论八-如何利用迪米特法则实现”高内聚-松耦合”"><a href="#理论八-如何利用迪米特法则实现”高内聚-松耦合”" class="headerlink" title="理论八: 如何利用迪米特法则实现”高内聚, 松耦合”?"></a>理论八: 如何利用迪米特法则实现”高内聚, 松耦合”?</h2><h3 id="什么是”高内聚-松耦合”"><a href="#什么是”高内聚-松耦合”" class="headerlink" title="什么是”高内聚, 松耦合”"></a>什么是”高内聚, 松耦合”</h3><p>所谓”高内聚”, 就是指相近的功能应该放到同一个类中, 不相近的功能不要放到同一个类中. 相近的功能放在一起, 容易管理和维护. 单一职责原则就是实现”高内聚”非常有效的手段.</p><p>所谓”松耦合”, 在代码中, 类与类之间的依赖关系简单清晰, 同时, 即使两个类之间有依赖关系, 一个类的改动不会或者很少导致依赖类的代码改动. 依赖注入, 接口隔离, 基于接口而非实现编程, 以及迪米特法则, 都是为了实现代码的松耦合.</p><h3 id="“高内聚”和”松耦合”之间的关系"><a href="#“高内聚”和”松耦合”之间的关系" class="headerlink" title="“高内聚”和”松耦合”之间的关系"></a>“高内聚”和”松耦合”之间的关系</h3><p>“高内聚”是用来指导类本身的设计, “松耦合”是用来指导类于类之间依赖的关系, 这两者并非完全独立不相干. 高内聚有助于松耦合, 松耦合又需要高内聚的支持.</p><h3 id="什么是”迪米特法则”"><a href="#什么是”迪米特法则”" class="headerlink" title="什么是”迪米特法则”"></a>什么是”迪米特法则”</h3><p>每个模块只应该了解那些与它关系密切的模块的有限知识. 具体一点说, 不该有直接依赖关系的类之间, 不要有依赖; 有依赖关系的类之间, 尽量只依赖必要的接口.</p><h3 id="如何实践”高内聚”和”松耦合”"><a href="#如何实践”高内聚”和”松耦合”" class="headerlink" title="如何实践”高内聚”和”松耦合”"></a>如何实践”高内聚”和”松耦合”</h3><ol><li>当两个类之间不应该有直接联系时, 使用一个中间类来联系两个类</li><li>当一个类要求”高耦合”, 但别的类又要求”松耦合”时, 可以通过实现接口来实现</li></ol><h2 id="理论一-什么情况下要重构-到底重构些什么-又该如何重构"><a href="#理论一-什么情况下要重构-到底重构些什么-又该如何重构" class="headerlink" title="理论一: 什么情况下要重构? 到底重构些什么? 又该如何重构?"></a>理论一: 什么情况下要重构? 到底重构些什么? 又该如何重构?</h2><h3 id="重构的目的-为什么要重构"><a href="#重构的目的-为什么要重构" class="headerlink" title="重构的目的: 为什么要重构?"></a>重构的目的: 为什么要重构?</h3><p><strong>重构</strong>是一种对软件内部结构的改善, 目的是在不改变软件的可见行为的情况下, 使其更易理解, 修改成本更低.</p><p><strong>重构</strong>是为了保证代码的质量. 防止代码质量差导致出现很多问题, 同时重构还可以提升代码质量, 让最初代码的质量变得越来越好.</p><h3 id="重构的对象-到底重构什么"><a href="#重构的对象-到底重构什么" class="headerlink" title="重构的对象: 到底重构什么?"></a>重构的对象: 到底重构什么?</h3><p>根据重构的规模, 我们可以笼统地分为大规模高层次重构(“大型重构”)和小规模低层次的重构(“小型重构”).</p><p><strong>大型重构</strong>指的是对顶层代码设计的重构, 包括: 系统, 模块, 代码结构, 类与类之间的关系等的重构, 重构的手段有: 分层, 模块化, 抽象可复用组件等等. 这类重构的工具就是设计思想, 原则和模式.</p><p><strong>小型重构</strong>指的是对代码细节的重构, 主要是针对类, 函数, 变量等代码级别的重构, 比如规范命名, 规范注释, 消除超大类和函数, 提取重复代码等等. 小型重构更多利用的是<strong>编程规范</strong>.</p><h3 id="重构的时机-什么时候重构"><a href="#重构的时机-什么时候重构" class="headerlink" title="重构的时机: 什么时候重构?"></a>重构的时机: 什么时候重构?</h3><p>提倡的重构策略是持续重构. 平时没有事情的时候, 可以看看项目中有哪些写得不够好的, 可以优化的代码, 主动去重构一下. 或者, 在修改, 添加某个功能的时候, 也可以顺手把不符合代码规范, 不好的设计重构一下. 总之, 就像把单元测试, 代码检视作为开发的一部分, 如果能把持续重构作为开发的一部分, 成为一种开发习惯, 对项目, 对自己都会很有好处.</p><h2 id="理论二-为了保证重构不出错-有哪些非常能落地的技术手段"><a href="#理论二-为了保证重构不出错-有哪些非常能落地的技术手段" class="headerlink" title="理论二: 为了保证重构不出错, 有哪些非常能落地的技术手段?"></a>理论二: 为了保证重构不出错, 有哪些非常能落地的技术手段?</h2><p>如何保证重构不出错, 熟悉掌握各种设计思想, 原则, 模式, 还需要对所重构的业务和代码有足够的了解. 除了这些个人能力因素之外, 最可落地执行, 最有效的保证重构不出错的手段是<strong>单元测试</strong>. 当重构完成之后, 如果新的代码仍能通过单元测试, 那就说明代码原有逻辑的正确性未被破坏, 原有的外部可见行为未变. 当然, 这需要之前的单元测试存在且有效. 还有一个手段是<strong>代码检视</strong>.</p><h3 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试?"></a>什么是单元测试?</h3><p><strong>单元测试</strong>有研发工程师自己编写, 用来测试自己写的代码的正确性. 我们通常将它跟集成测试放到一块来对比. 单元测试相对集成测试来说, 测试的粒度更小一些. 集成测试的对象是整个系统或者某个功能模块, 比如测试用户注册, 登录功能是否正常, 是一种端到端的测试. 而单元测试的测试对象是类或者函数, 用来测试一个类和函数是否都按照预期的逻辑执行. 这是代码层级的测试.</p><h3 id="为什么要写单元测试"><a href="#为什么要写单元测试" class="headerlink" title="为什么要写单元测试?"></a>为什么要写单元测试?</h3><ul><li>单元测试相当于一次”自我代码检视”, 能有效地帮你发现代码中的<code>bug</code>和代码设计上的不合理</li><li>单元测试可以通过<code>桩</code>很轻松写出某些集成测试不好测试的场景, 是对集成测试的有力补充</li><li>单元测试是重构的基础, 没有单元测试, 重构无法保证正确性</li></ul><h2 id="理论三-什么是代码的可测试性-如何写出可测试性好的代码"><a href="#理论三-什么是代码的可测试性-如何写出可测试性好的代码" class="headerlink" title="理论三: 什么是代码的可测试性? 如何写出可测试性好的代码?"></a>理论三: 什么是代码的可测试性? 如何写出可测试性好的代码?</h2><h3 id="什么是代码的可测试性"><a href="#什么是代码的可测试性" class="headerlink" title="什么是代码的可测试性"></a>什么是代码的可测试性</h3><p>粗略地讲, 所谓代码的可测试性, 就是针对代码编写单元测试的难易程度. 对于一段代码, 如果很难为其编写单元测试, 或者单元测试写起来很费劲, 需要依靠单元测试框架中很高级的特性, 那往往就意味着代码设计得不够合理, 代码的可测试性不好. </p><p>编写可测试性代码的最有效的手段是依赖注入, 通过依赖注入, 在写单元测试时, 可以通过<code>mock</code>的方法解决外部依赖.</p><h3 id="常见的测试性不友好的代码"><a href="#常见的测试性不友好的代码" class="headerlink" title="常见的测试性不友好的代码"></a>常见的测试性不友好的代码</h3><ul><li>代码中包含未决逻辑行为</li><li>滥用可变全局变量</li><li>滥用静态方法</li><li>使用复杂的继承关系</li><li>高度耦合的代码</li></ul><h2 id="理论四-如何通过封装-抽象-模块化-中间层等解耦代码"><a href="#理论四-如何通过封装-抽象-模块化-中间层等解耦代码" class="headerlink" title="理论四: 如何通过封装, 抽象, 模块化, 中间层等解耦代码?"></a>理论四: 如何通过封装, 抽象, 模块化, 中间层等解耦代码?</h2><h3 id="“解耦”为什么非常重要"><a href="#“解耦”为什么非常重要" class="headerlink" title="“解耦”为什么非常重要?"></a>“解耦”为什么非常重要?</h3><p>不管阅读代码还是修改代码, “高内聚, 松耦合”的特性能让我们聚焦在某一模块或类中, 不需要了解太多其他模块或类的代码, 让我们的焦点不至于过于发散, 降低阅读和修改代码的难度. 而且, 因为依赖关系简单, 耦合小, 修改代码不至于牵一发而动全身, 代码改动比较集中, 引入<code>bug</code>的风险也就减少了很多. 同时, “高内聚, 松耦合”的代码可测试性也更加好, 容易<code>mock</code>或者很少需要<code>mock</code>外部依赖的模块或者类.</p>]]></content>
      
      
      <categories>
          
          <category> 编程思想 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保障集群内节点和网络安全</title>
      <link href="/2023/10/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E4%BF%9D%E9%9A%9C%E9%9B%86%E7%BE%A4%E5%86%85%E8%8A%82%E7%82%B9%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
      <url>/2023/10/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E4%BF%9D%E9%9A%9C%E9%9B%86%E7%BE%A4%E5%86%85%E8%8A%82%E7%82%B9%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="保障集群内节点和网络安全"><a href="#保障集群内节点和网络安全" class="headerlink" title="保障集群内节点和网络安全"></a>保障集群内节点和网络安全</h1><h2 id="在pod中使用宿主节点的Linux命名空间"><a href="#在pod中使用宿主节点的Linux命名空间" class="headerlink" title="在pod中使用宿主节点的Linux命名空间"></a>在<code>pod</code>中使用宿主节点的<code>Linux</code>命名空间</h2><p>部分<code>pod</code>(特别是系统<code>pod</code>)需要在宿主节点的默认命名空间中运行, 以允许它们看到和操作节点级别的资源和设备. </p><h3 id="绑定宿主节点上的端口而不使用宿主节点的网络命名空间"><a href="#绑定宿主节点上的端口而不使用宿主节点的网络命名空间" class="headerlink" title="绑定宿主节点上的端口而不使用宿主节点的网络命名空间"></a>绑定宿主节点上的端口而不使用宿主节点的网络命名空间</h3><p>这可以通过配置<code>pod</code>的<code>spec.containers.ports</code>字段中某个容器某一个端口的<code>hostPort</code>属性来实现. </p><p>如果一个<code>pod</code>绑定了宿主节点上的一个特定端口, 每个宿主节点只能调度一个这样的<code>pod</code>实例, 因为两个进程不能绑定宿主机上的同一个端口. 调度器在调度<code>pod</code>时会考虑这一点, 所以它不会把这样的两个<code>pod</code>调度到同一个节点上. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">some/image</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;pod的名称&gt;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="number">9000</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure><p><code>hostPort</code>功能最初是用于暴露通过<code>DeamonSet</code>部署在每个节点上的系统服务的. </p><h2 id="配置节点的安全上下文"><a href="#配置节点的安全上下文" class="headerlink" title="配置节点的安全上下文"></a>配置节点的安全上下文</h2><p>安全上下文中可配置的内容:</p><ul><li>指定容器中运行进程的用户(用户<code>ID</code>)</li><li>阻止容器使用<code>root</code>用于运行(容器的默认运行用户通常在其镜像中指定, 所以可能需要阻止容器以<code>root</code>用户运行)</li><li>使用特权模式运行容器, 使其对宿主节点的内核具有完全的访问权限</li><li>与以上相反, 通过添加或禁用内容功能, 配置细粒度的内核访问权限</li><li>设置<code>SELinux</code>选项, 加强对容器的限制</li><li>阻止进程写入容器的根文件系统</li></ul><h3 id="使用指定用户运行容器"><a href="#使用指定用户运行容器" class="headerlink" title="使用指定用户运行容器"></a>使用指定用户运行容器</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sleep&quot;</span>, <span class="string">&quot;999999&quot;</span>]</span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">runAsUser:</span> <span class="number">405</span></span><br></pre></td></tr></table></figure><h3 id="阻止容器以root用户运行"><a href="#阻止容器以root用户运行" class="headerlink" title="阻止容器以root用户运行"></a>阻止容器以<code>root</code>用户运行</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sleep&quot;</span>, <span class="string">&quot;999999&quot;</span>]</span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">runAsNonRoot:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="使用特权模式运行pod"><a href="#使用特权模式运行pod" class="headerlink" title="使用特权模式运行pod"></a>使用特权模式运行<code>pod</code></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sleep&quot;</span>, <span class="string">&quot;999999&quot;</span>]</span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="为容器单独添加内核功能"><a href="#为容器单独添加内核功能" class="headerlink" title="为容器单独添加内核功能"></a>为容器单独添加内核功能</h3><p>相比于让容器运行在特权模式下以给予其无限的权限, 一个更加安全地做法是只给予它使用真正需要的内核功能的权限. <code>Kubernetes</code>允许为特定的容器添加内核功能, 或禁止部分内核功能, 以允许对容器进行更加细致的权限控制, 限制攻击者潜在侵入的影响. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sleep&quot;</span>, <span class="string">&quot;999999&quot;</span>]</span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">add:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SYS_TIME</span></span><br></pre></td></tr></table></figure><h3 id="在容器中禁用内核功能"><a href="#在容器中禁用内核功能" class="headerlink" title="在容器中禁用内核功能"></a>在容器中禁用内核功能</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sleep&quot;</span>, <span class="string">&quot;999999&quot;</span>]</span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">drop:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CHOWN</span></span><br></pre></td></tr></table></figure><h3 id="阻止对容器跟文件系统的写入"><a href="#阻止对容器跟文件系统的写入" class="headerlink" title="阻止对容器跟文件系统的写入"></a>阻止对容器跟文件系统的写入</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">alpine</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sleep&quot;</span>, <span class="string">&quot;999999&quot;</span>]</span><br><span class="line">    <span class="attr">securityContext:</span></span><br><span class="line">      <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="容器使用不同用户时共享存储卷"><a href="#容器使用不同用户时共享存储卷" class="headerlink" title="容器使用不同用户时共享存储卷"></a>容器使用不同用户时共享存储卷</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">fsGroup:</span> <span class="number">555</span></span><br><span class="line">    <span class="attr">supplementalGroups:</span> [<span class="number">666</span>, <span class="number">777</span>]</span><br></pre></td></tr></table></figure><h2 id="限制pod使用安全相关的特性"><a href="#限制pod使用安全相关的特性" class="headerlink" title="限制pod使用安全相关的特性"></a>限制<code>pod</code>使用安全相关的特性</h2><h3 id="PodSecurityPolicy资源介绍"><a href="#PodSecurityPolicy资源介绍" class="headerlink" title="PodSecurityPolicy资源介绍"></a><code>PodSecurityPolicy</code>资源介绍</h3><p><code>PodSecuriyPolicy</code>是一种集群级别(无命名空间)的资源, 它定义了用户能否在<code>pod</code>中使用各种安全相关的特性. 维护<code>PodSecurityPolicy</code>资源中配置策略的工作由集成在<code>API</code>服务器中的<code>PodSercurityPolicy</code>准入控制插件完成. </p><h4 id="PodSecurityPolicy可以做的事"><a href="#PodSecurityPolicy可以做的事" class="headerlink" title="PodSecurityPolicy可以做的事"></a><code>PodSecurityPolicy</code>可以做的事</h4><ul><li>是否允许<code>pod</code>使用宿主节点的<code>PID</code>, <code>IPC</code>, 网络命名空间</li><li><code>pod</code>允许绑定的宿主节点的端口</li><li>容器运行时允许使用的用户<code>ID</code></li><li>是否允许拥有特权模式容器的<code>pod</code></li><li>允许添加哪些内核功能, 默认添加哪些内核功能, 总是禁用哪些内核功能</li><li>允许容器使用哪些<code>SELinux</code>选项</li><li>容器是否允许使用可写的根文件系统</li><li>允许容器在哪些文件系统组下运行</li><li>允许<code>pod</code>使用哪些类型的存储卷</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodSecurityPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hostIPC:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hostPID:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">hostPorts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">10000</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">11000</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">13000</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">14000</span></span><br><span class="line">  <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">runAsUser:</span></span><br><span class="line">  <span class="attr">rule:</span> <span class="string">RunAsAny</span></span><br><span class="line">  <span class="attr">fsGroup:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">RunAsAny</span></span><br><span class="line">  <span class="attr">supplementalGroups:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">RunAsAny</span></span><br><span class="line">  <span class="attr">seLinux:</span></span><br><span class="line">    <span class="attr">rule:</span> <span class="string">RunAsAny</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="了解runAsUser-fsGroup和supplementGroup策略"><a href="#了解runAsUser-fsGroup和supplementGroup策略" class="headerlink" title="了解runAsUser, fsGroup和supplementGroup策略"></a>了解<code>runAsUser</code>, <code>fsGroup</code>和<code>supplementGroup</code>策略</h3><p>如果需要限制容器可以使用的用户和用户组<code>ID</code>, 可以将规则改为<code>MustRunAs</code>, 并指定允许使用的<code>ID</code>范围. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">runAsUser:</span></span><br><span class="line">  <span class="attr">rule:</span> <span class="string">MustRunAs</span></span><br><span class="line">  <span class="attr">ranges:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">fsGroup:</span></span><br><span class="line">  <span class="attr">rule:</span> <span class="string">MustRunAs</span></span><br><span class="line">  <span class="attr">ranges:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">10</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">30</span></span><br><span class="line"><span class="attr">supplementalGroups:</span></span><br><span class="line">  <span class="attr">rule:</span> <span class="string">MustRunAs</span></span><br><span class="line">  <span class="attr">ranges:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">10</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">min:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">max:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>如果<code>pod spec</code>试图将其中的任一字段设置为该范围之外的值, 这个<code>pod</code>将不会被<code>API</code>服务器接收. </p><h4 id="部署镜像中用户ID在指定范围之外的pod"><a href="#部署镜像中用户ID在指定范围之外的pod" class="headerlink" title="部署镜像中用户ID在指定范围之外的pod"></a>部署镜像中用户<code>ID</code>在指定范围之外的<code>pod</code></h4><p><code>PodSecurityPolicy</code>会将硬编码覆盖到镜像中的用户<code>ID</code>. </p><h4 id="在runAsUser字段中使用mustRunAsNonRoot规则"><a href="#在runAsUser字段中使用mustRunAsNonRoot规则" class="headerlink" title="在runAsUser字段中使用mustRunAsNonRoot规则"></a>在<code>runAsUser</code>字段中使用<code>mustRunAsNonRoot</code>规则</h4><p><code>runAsUser</code>字段中还可以使用另一种规则: <code>mustRunAsNonRoot</code>. 它将阻止用户部署以<code>root</code>用户运行的容器. 在这种情况下, <code>spec</code>容器中必须指定<code>runAsUser</code>字段, 并且不能为0, 或者容器的镜像本身指定了一个用非0的用户<code>ID</code>运行. </p><h3 id="配置允许-默认添加-禁止使用的内核功能"><a href="#配置允许-默认添加-禁止使用的内核功能" class="headerlink" title="配置允许, 默认添加, 禁止使用的内核功能"></a>配置允许, 默认添加, 禁止使用的内核功能</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PodSecurityPolicy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="string">allowedCapabilities</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SYS_TIME</span></span><br><span class="line">  <span class="string">defaultAddCapabilities</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">CHOWN</span></span><br><span class="line">  <span class="string">requiredDropCapabilities</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SYS_ADMIN</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SYS_MODULES</span></span><br></pre></td></tr></table></figure><h3 id="对不同的用户与组分配不同的PodSecurityPolicy"><a href="#对不同的用户与组分配不同的PodSecurityPolicy" class="headerlink" title="对不同的用户与组分配不同的PodSecurityPolicy"></a>对不同的用户与组分配不同的<code>PodSecurityPolicy</code></h3><p><code>PodSecurityPolicy</code>是集群级别的资源, 这意味着它不能存储和应用在某一特定的命名空间上. 对不同用户分配不同<code>PodSecurityPolicy</code>是通过<code>RBAC</code>机制实现的. 这个方式是, 创建你需要的<code>PodSecurityPolicy</code>资源, 然后创建<code>ClusterRole</code>资源并通过名称将它们指向不同的策略, 以此使<code>PodSecurityPolicy</code>资源中的策略对不同的用户或组生效. 通过<code>ClusterRoleBinding</code>资源将特定的用户组绑定到<code>ClusterRole</code>上, 当<code>PodSecurityPolicy</code>访问控制插件需要决定是否接纳一个<code>pod</code>时, 它只会考虑创建<code>pod</code>的用户可以访问到的<code>PodSecurityPolicy</code>中的策略. </p><h2 id="隔离pod的网络"><a href="#隔离pod的网络" class="headerlink" title="隔离pod的网络"></a>隔离<code>pod</code>的网络</h2><p>一个<code>NetworkPolicy</code>会应用在匹配它的标签选择器的<code>pod</code>上, 指明这些允许访问这些<code>pod</code>的源地址, 或这些<code>pod</code>可以访问的目标地址. 这些分别由入向<code>ingress</code>和出向<code>egress</code>规则指定. 这两种规则都可以匹配由标签选择器选出的<code>pod</code>, 或者一个<code>namespace</code>中的所有<code>pod</code>, 或者通过无类别域间路由(<code>CIDR</code>)指定的<code>IP</code>地址段. </p><h4 id="在一个命名空间中阻止所有访问"><a href="#在一个命名空间中阻止所有访问" class="headerlink" title="在一个命名空间中阻止所有访问"></a>在一个命名空间中阻止所有访问</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">default-deny</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br></pre></td></tr></table></figure><p>空的标签选择器匹配命名空间中的所有<code>pod</code>. </p><h4 id="允许同一命名空间中的部分pod访问一个服务端pod"><a href="#允许同一命名空间中的部分pod访问一个服务端pod" class="headerlink" title="允许同一命名空间中的部分pod访问一个服务端pod"></a>允许同一命名空间中的部分<code>pod</code>访问一个服务端<code>pod</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">postgres-netpolicy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">database</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">webserver</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">5432</span></span><br></pre></td></tr></table></figure><h4 id="在不同Kubernetes命名空间之间进行网络隔离"><a href="#在不同Kubernetes命名空间之间进行网络隔离" class="headerlink" title="在不同Kubernetes命名空间之间进行网络隔离"></a>在不同<code>Kubernetes</code>命名空间之间进行网络隔离</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">shoppingcart-netpolicy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">shopping-cart</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">tenant:</span> <span class="string">manning</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h4 id="使用CIDR隔离网络"><a href="#使用CIDR隔离网络" class="headerlink" title="使用CIDR隔离网络"></a>使用<code>CIDR</code>隔离网络</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ingress:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">      <span class="attr">cidr:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure><h4 id="限制pod的对外访问流量"><a href="#限制pod的对外访问流量" class="headerlink" title="限制pod的对外访问流量"></a>限制<code>pod</code>的对外访问流量</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">webserver</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">database</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubernetes in Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从应用访问pod元数据以及其他资源</title>
      <link href="/2023/10/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/"/>
      <url>/2023/10/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E4%BB%8E%E5%BA%94%E7%94%A8%E8%AE%BF%E9%97%AEpod%E5%85%83%E6%95%B0%E6%8D%AE%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="从应用访问pod元数据以及其他资源"><a href="#从应用访问pod元数据以及其他资源" class="headerlink" title="从应用访问pod元数据以及其他资源"></a>从应用访问<code>pod</code>元数据以及其他资源</h1>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubernetes in Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ConfigMap和Secret</title>
      <link href="/2023/10/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/ConfigMap%E5%92%8CSecret/"/>
      <url>/2023/10/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/ConfigMap%E5%92%8CSecret/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="ConfigMap和Secret"><a href="#ConfigMap和Secret" class="headerlink" title="ConfigMap和Secret"></a><code>ConfigMap</code>和<code>Secret</code></h1><h2 id="向容器传递命令行参数"><a href="#向容器传递命令行参数" class="headerlink" title="向容器传递命令行参数"></a>向容器传递命令行参数</h2><h3 id="在Docker中定义命令与参数"><a href="#在Docker中定义命令与参数" class="headerlink" title="在Docker中定义命令与参数"></a>在<code>Docker</code>中定义命令与参数</h3><p>容器中运行的完整指令由两部分组成, 命令与参数. </p><h4 id="了解ENTRYPOINT与CMD"><a href="#了解ENTRYPOINT与CMD" class="headerlink" title="了解ENTRYPOINT与CMD"></a>了解<code>ENTRYPOINT</code>与<code>CMD</code></h4><p><code>ENTRYPOINT</code>定义容器启动时被调用的可执行程序. </p><p><code>CMD</code>指定传递给<code>ENTRYPOINT</code>的参数. </p><h4 id="了解shell与exec形式的区别"><a href="#了解shell与exec形式的区别" class="headerlink" title="了解shell与exec形式的区别"></a>了解<code>shell</code>与<code>exec</code>形式的区别</h4><p><code>shell</code>形式–如<code>ENTRYPOINT node app.js</code>. </p><p><code>exec</code>形式– 如<code>ENTRYPONT [&quot;node&quot;, &quot;app.js&quot;]</code>. </p><p>两者的区别在于指定的命令是否在<code>shell</code>中被调用, 确定<code>PID</code>为1的进程是谁. </p><h3 id="在Kubernetes中覆盖命令和参数"><a href="#在Kubernetes中覆盖命令和参数" class="headerlink" title="在Kubernetes中覆盖命令和参数"></a>在<code>Kubernetes</code>中覆盖命令和参数</h3><p>在<code>Kubernetes</code>中定义容器时, 镜像的<code>ENTRYPOINT</code>和<code>CMD</code>均可以被覆盖, 仅需要在容器定义中设置属性<code>command</code>和<code>args</code>的值. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">some/image</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/command&quot;</span>]</span><br><span class="line">    <span class="attr">args:</span> [<span class="string">&quot;args1&quot;</span>, <span class="string">&quot;args2&quot;</span>, <span class="string">&quot;args3&quot;</span>]</span><br></pre></td></tr></table></figure><p>绝大多数情况下, 只需要设置自定义参数. 命令一般很少被覆盖, 除非针对一些未定义<code>ENTRYPINT</code>的通用镜像, 例如<code>busybox</code>. </p><p><code>command</code>和<code>args</code>字段在<code>pod</code>创建后无法被修改. </p><h2 id="为容器设置环境变量"><a href="#为容器设置环境变量" class="headerlink" title="为容器设置环境变量"></a>为容器设置环境变量</h2><p><code>Kubernetes</code>允许为<code>pod</code>中每一个容器都指定自定义的环境变量集合. </p><p>与容器的命令和参数设置相同, 环境变量列表无法在<code>pod</code>创建后被修改. </p><h3 id="在容器定义中指定环境变量"><a href="#在容器定义中指定环境变量" class="headerlink" title="在容器定义中指定环境变量"></a>在容器定义中指定环境变量</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">luksa/fortune:env</span></span><br><span class="line">    <span class="attr">env:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">INTERVAL</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;30&quot;</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">html-generator</span></span><br></pre></td></tr></table></figure><p>在每个容器中, <code>Kubernetes</code>会自动暴露相同命名空间下每个<code>service</code>对应的黄金变量. 这些环境变量基本上可以被看作自动注入的配置. </p><h3 id="了解硬编码环境变量的不足之处"><a href="#了解硬编码环境变量的不足之处" class="headerlink" title="了解硬编码环境变量的不足之处"></a>了解硬编码环境变量的不足之处</h3><p><code>pod</code>定义硬编码意味着需要有效区分生产环境与开发过程中的<code>pod</code>定义. 为了能在多个环境下复用<code>pod</code>的定义, 需要将配置从<code>pod</code>定义描述中解耦出来. </p><h2 id="利用ConfigMap解耦配置"><a href="#利用ConfigMap解耦配置" class="headerlink" title="利用ConfigMap解耦配置"></a>利用<code>ConfigMap</code>解耦配置</h2><p>应用配置的关键在于能够在多个环境中区分配置选项, 将配置从应用程序源码中分离, 可频繁变更配置值. </p><h3 id="ConfigMap介绍"><a href="#ConfigMap介绍" class="headerlink" title="ConfigMap介绍"></a><code>ConfigMap</code>介绍</h3><p><code>Kubernetes</code>允许将配置选项分离到单独的资源对象<code>ConfigMap</code>中, 本质上就是一个键<code>/</code>值对映射, 值可以是短字面量, 也可以是完整的配置文件. </p><p>应用无须直接读取<code>ConfigMap</code>, 甚至根本不需要知道其是否存在. 映射的内容通过环境变量或者卷文件的形式传递给容器, 而非直接传递给容器. 命令行参数的定义中可以通过<code>$(ENV_VAR)</code>语法引用环境变量, 因而可以达到将<code>ConfigMap</code>条目当作命令行参数传递给进程的效果. </p><p>当然, 应用程序同样可以通过<code>Kubernetes Rest API</code>按需直接读取<code>ConfigMap</code>的内容. 不过除非是需求如此, 应尽可能使你的应用保持对<code>Kubernetes</code>的无感知. </p><h3 id="创建ConfigMap"><a href="#创建ConfigMap" class="headerlink" title="创建ConfigMap"></a>创建<code>ConfigMap</code></h3><h4 id="使用指令kubectl创建ConfigMap"><a href="#使用指令kubectl创建ConfigMap" class="headerlink" title="使用指令kubectl创建ConfigMap"></a>使用指令<code>kubectl</code>创建<code>ConfigMap</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap &lt;configMap的名字&gt; --from-literal=&lt;键&gt;=&lt;值&gt;</span><br></pre></td></tr></table></figure><p>键只能包含数字, 字母, 破折号, 下画线以及圆点. <code>--from-literal</code>参数用于指定多个条目. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;configMap的名字&gt;</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">&lt;键&gt;:</span> <span class="string">&lt;值&gt;</span> </span><br></pre></td></tr></table></figure><h4 id="从文件内容创建ConfigMap条目"><a href="#从文件内容创建ConfigMap条目" class="headerlink" title="从文件内容创建ConfigMap条目"></a>从文件内容创建<code>ConfigMap</code>条目</h4><p><code>ConfigMap</code>同样可以存储粗粒度的配置数据, 比如完整的配置文件. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap &lt;configmap的名字&gt; --from-file=&lt;配置文件名&gt;</span><br></pre></td></tr></table></figure><p>运行上述命令时, <code>kubectl</code>会在当前目录下查找配置文件, 并将文件内容存储在<code>ConfigMap</code>中以配置文件名为键名的条目下. 也可以手动指定键名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap &lt;configmap的名字&gt; --from-file=&lt;键&gt;=&lt;配置文件名&gt;</span><br></pre></td></tr></table></figure><h4 id="从文件夹创建ConfigMap"><a href="#从文件夹创建ConfigMap" class="headerlink" title="从文件夹创建ConfigMap"></a>从文件夹创建<code>ConfigMap</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create configmap &lt;configmap的名字&gt; --from-file=/path/to/dir</span><br></pre></td></tr></table></figure><p>这种情况下, <code>kubectl</code>会为文件夹中的每个文件单独创建条目, 仅限于那些文件名可作为合法<code>ConfigMap</code>键名的文件. </p><h3 id="给容器传递ConfigMap条目作为环境变量"><a href="#给容器传递ConfigMap条目作为环境变量" class="headerlink" title="给容器传递ConfigMap条目作为环境变量"></a>给容器传递<code>ConfigMap</code>条目作为环境变量</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">&lt;Pod名称&gt;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">some/image</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&lt;环境变量名&gt;</span></span><br><span class="line">      <span class="attr">valueFrom:</span></span><br><span class="line">        <span class="attr">configMapKeyRef:</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">&lt;configMap的名称&gt;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">&lt;configMap的值&gt;</span></span><br></pre></td></tr></table></figure><p>引用不存在<code>ConfigMap</code>的容器会启动失败. 当之后创建了这个缺失的<code>ConfigMap</code>, 失败的容器会自动启动, 无须重新创建<code>pod</code>. </p><p>可以标记对<code>ConfigMap</code>的引用时可选的(设置<code>configMapKeyRef.optional: true</code>). 这样, 即便<code>ConfigMap</code>不存在, 容器也能正常启动. </p><h3 id="一次性传递ConfigMap的所有条目作为环境变量"><a href="#一次性传递ConfigMap的所有条目作为环境变量" class="headerlink" title="一次性传递ConfigMap的所有条目作为环境变量"></a>一次性传递<code>ConfigMap</code>的所有条目作为环境变量</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">some-image</span></span><br><span class="line">    <span class="attr">envFrom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">prefix:</span> <span class="string">CONFIG_</span></span><br><span class="line">      <span class="attr">configMapRef:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&lt;configMap的名称&gt;</span></span><br></pre></td></tr></table></figure><p>前缀设置是可选的, 若不设置前缀值, 环境变量的名称与<code>ConfigMap</code>中的键名相同. </p><h3 id="传递Configmap条目作为命令行参数"><a href="#传递Configmap条目作为命令行参数" class="headerlink" title="传递Configmap条目作为命令行参数"></a>传递<code>Configmap</code>条目作为命令行参数</h3><p>在字段<code>pod.spec.containers.args</code>中无法直接引用<code>ConfigMap</code>的条目, 但是可以利用<code>ConfigMap</code>条目初始化某个环境变量, 然后再在参数字段中引用该环境变量. </p><h3 id="使用ConfigMap卷将条目暴露为文件"><a href="#使用ConfigMap卷将条目暴露为文件" class="headerlink" title="使用ConfigMap卷将条目暴露为文件"></a>使用<code>ConfigMap</code>卷将条目暴露为文件</h3><p>环境变量或者命令行参数值作为配置值通常适用于变量值较短的场景. </p><p><code>configMap</code>卷会将<code>ConfigMap</code>中每个条目均暴露成一个文件. 运行在容器中的进程可通过读取文件内容获得对应的条目值. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">  <span class="attr">configMap:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;configMap的名称&gt;</span></span><br></pre></td></tr></table></figure><h4 id="卷内暴露指定的ConfigMap条目"><a href="#卷内暴露指定的ConfigMap条目" class="headerlink" title="卷内暴露指定的ConfigMap条目"></a>卷内暴露指定的<code>ConfigMap</code>条目</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">  <span class="attr">configMap:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;configMap的名称&gt;</span>      </span><br><span class="line">    <span class="attr">items:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&lt;configMap中的键&gt;</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">&lt;cofigMap中键的新名称&gt;</span></span><br></pre></td></tr></table></figure><h4 id="ConfigMap独立条目作为文件被挂载且不隐藏文件夹中的其他文件"><a href="#ConfigMap独立条目作为文件被挂载且不隐藏文件夹中的其他文件" class="headerlink" title="ConfigMap独立条目作为文件被挂载且不隐藏文件夹中的其他文件"></a>ConfigMap独立条目作为文件被挂载且不隐藏文件夹中的其他文件</h4><p>假设拥有一个包含文件<code>myconfig.conf</code>的<code>configMap</code>卷, 希望能将奇添加为<code>/etc</code>文件夹下的文件<code>someconfig.conf</code>. 通过属性<code>subPath</code>可以将该文件挂载的同时又不影响文件夹中的其他文件. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">some/image</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">myvolume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/etc/someconfig.conf</span></span><br><span class="line">      <span class="attr">subPath:</span> <span class="string">myconfig.conf</span></span><br></pre></td></tr></table></figure><p>挂载任意一种卷时均可以使用<code>subPath</code>属性. 可以选择挂载部分卷而不是挂载完整的卷. 捕获这种独立文件的挂载方式会带来文件更新上的缺陷. </p><h4 id="为configMap卷中的文件设置权限"><a href="#为configMap卷中的文件设置权限" class="headerlink" title="为configMap卷中的文件设置权限"></a>为<code>configMap</code>卷中的文件设置权限</h4><p><code>configMap</code>卷中所有文件的权限默认被设置为644. 可以通过卷规格定义中的<code>defaultMode</code>属性改变默认权限. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">  <span class="attr">configMap:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;configMap的名称&gt;</span></span><br><span class="line">    <span class="attr">defaultMode:</span> <span class="string">&quot;6600&quot;</span></span><br></pre></td></tr></table></figure><h3 id="更新应用配置且不重启应用程序"><a href="#更新应用配置且不重启应用程序" class="headerlink" title="更新应用配置且不重启应用程序"></a>更新应用配置且不重启应用程序</h3><p>使用环境变量或命令行参数作为配置源的弊端在于无法在进程运行时更新配置. 将<code>ConfigMap</code>暴露为卷可以达到配置热更新的效果, 无须重新创建<code>pod</code>或者重启容器. </p><p><code>ConfigMap</code>被更新之后, 卷中引用它的所有文件也会相应更新, 进程发现文件被改变之后进行重载(这要进程自己实现). </p><h4 id="挂载至已存在文件夹的文件不会更新"><a href="#挂载至已存在文件夹的文件不会更新" class="headerlink" title="挂载至已存在文件夹的文件不会更新"></a>挂载至已存在文件夹的文件不会更新</h4><p>如果挂载的是容器中的单个文件而不是完整的卷, <code>ConfigMap</code>更新之后对应的文件不会被更新. </p><p>如果现在你需要挂载单个文件并且在修改源<code>ConfigMap</code>的同时会自动修改这个文件, 一种方案是挂载完整卷至不同的文件夹并创建指向文件的符号链接. 符号链接可以原生创建在容器镜像中, 也可以在容器启动时创建. </p><h2 id="使用Secret给容器传递敏感数据"><a href="#使用Secret给容器传递敏感数据" class="headerlink" title="使用Secret给容器传递敏感数据"></a>使用<code>Secret</code>给容器传递敏感数据</h2><p><code>Secret</code>与<code>ConfigMap</code>相似, 均是键<code>/</code>值对的映射, 但用于保存一些敏感数据. </p><h3 id="默认令牌Secret介绍"><a href="#默认令牌Secret介绍" class="headerlink" title="默认令牌Secret介绍"></a>默认令牌<code>Secret</code>介绍</h3><p>每个<code>pod</code>都会默认自动挂载上一个<code>Secret</code>卷, 引用一个默认的<code>Secret</code>. </p><h4 id="为二进制数据创建Secret"><a href="#为二进制数据创建Secret" class="headerlink" title="为二进制数据创建Secret"></a>为二进制数据创建<code>Secret</code></h4><p>采用<code>Base64</code>编码的原因很简单. <code>Secret</code>的条目可以涵盖二进制数据, 而不仅仅是纯文本. <code>Base64</code>编码可以将二进制数据转换为纯文本, 以<code>YAML</code>或<code>JSON</code>格式展示. </p><p><code>Secret</code>甚至可以被用来存储非敏感二进制数据, <code>Secret</code>的大小限于<code>1MB</code>. </p><h4 id="stringData字段介绍"><a href="#stringData字段介绍" class="headerlink" title="stringData字段介绍"></a><code>stringData</code>字段介绍</h4><p>由于并非所有敏感数据都是二进制形式, <code>Kubernetes</code>允许通过<code>Secret</code>的<code>stringData</code>字段设置条目的纯文本值. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">stringData:</span> </span><br><span class="line">  <span class="attr">fool:</span> <span class="string">plain</span> <span class="string">text</span></span><br><span class="line"><span class="attr">data:</span> </span><br><span class="line">  <span class="attr">https.cert:</span> <span class="string">LSOtLSAAA</span></span><br><span class="line">  <span class="attr">https.key:</span> <span class="string">LSOtLSAAA</span></span><br></pre></td></tr></table></figure><p>通过<code>kubectl get -o yaml</code>查看<code>Secret</code>时, <code>stringData</code>会出现在<code>data</code>字段. </p><h4 id="在pod中读取Secret条目"><a href="#在pod中读取Secret条目" class="headerlink" title="在pod中读取Secret条目"></a>在<code>pod</code>中读取<code>Secret</code>条目</h4><p>通过<code>secret</code>卷将<code>Secret</code>暴露给容器之后, <code>Secret</code>条目的值会被解码并以真实形式(纯文本或二进制)写入对应的文件. 通过环境变量暴露<code>Secret</code>条目也是如此. 应用程序无序主动解码, 可直接读取文件内容或查找环境变量. </p><h4 id="Secret卷存储于内存"><a href="#Secret卷存储于内存" class="headerlink" title="Secret卷存储于内存"></a><code>Secret</code>卷存储于内存</h4><p><code>Secret</code>卷采用内存文件系统列出容器的挂载点, 由于使用的是<code>tmpfs</code>, 存储在<code>Secret</code>中的数据不会写入磁盘, 这就无法被窃取. </p><h4 id="通过环境变量暴露Secret条目"><a href="#通过环境变量暴露Secret条目" class="headerlink" title="通过环境变量暴露Secret条目"></a>通过环境变量暴露<code>Secret</code>条目</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FOO_SECRET</span></span><br><span class="line">  <span class="attr">valueFrom:</span></span><br><span class="line">    <span class="attr">secretKeyRef:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&lt;secret的名字&gt;</span></span><br><span class="line">      <span class="attr">key:</span> <span class="string">&lt;secret的键&gt;</span></span><br></pre></td></tr></table></figure><p><code>kubernetes</code>允许通过环境变量暴露<code>Secret</code>, 然而此特性的使用往往不是一个好注意. 应用程序通常会在错误报告时转储环境变量, 或者是在启动时打印在应用日志中, 无意中暴露了<code>Secret</code>信息.</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubernetes in Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卷</title>
      <link href="/2023/10/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%8D%B7/"/>
      <url>/2023/10/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%8D%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h1><p><code>pod</code>的每个容器都有自己独立的文件系统, 因为文件系统来自容器镜像. 如果想要共享磁盘, <code>container</code>需要自己进行挂载. </p><p><code>Kubernetes</code>定义了存储卷, 它们被定义为<code>pod</code>的一部分, 并和<code>pod</code>共享相同的声明周期. 这意味着在<code>pod</code>启动时创建卷, 并在删除<code>pod</code>时销毁卷. 因此, 在容器重新启动期间, 卷的内容将保持不变, 在重新启动容器之后, 新容器可以识别前一个容器写入卷的所有文件. </p><h2 id="通过卷在容器之间共享数据"><a href="#通过卷在容器之间共享数据" class="headerlink" title="通过卷在容器之间共享数据"></a>通过卷在容器之间共享数据</h2><h3 id="使用emptyDir卷"><a href="#使用emptyDir卷" class="headerlink" title="使用emptyDir卷"></a>使用<code>emptyDir</code>卷</h3><p>卷从一个空目录开始, 运行在<code>pod</code>内的应用程序可以写入它需要的任何文件. 因为卷的生存周期与<code>pod</code>的生存周期相关联, 所以当删除<code>pod</code>时, 卷的内容就会丢失. </p><h4 id="指定用于EMPTYDIR的介质"><a href="#指定用于EMPTYDIR的介质" class="headerlink" title="指定用于EMPTYDIR的介质"></a>指定用于<code>EMPTYDIR</code>的介质</h4><p>作为卷来使用的<code>emptyDir</code>, 是在承载<code>pod</code>的工作节点的实际磁盘上创建的, 因此其性能取决于节点的磁盘类型. 但我们可以通知<code>Kubernetes</code>在<code>tmfs</code>文件系统(存在内存而非硬盘)上创建<code>emptyDir</code>. 因此, 将<code>emptyDir</code>的<code>medium</code>设置为<code>Memory</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">emptyDir:</span></span><br><span class="line">    <span class="attr">medium:</span> <span class="string">Memory</span></span><br></pre></td></tr></table></figure><h3 id="使用Git仓库作为存储卷"><a href="#使用Git仓库作为存储卷" class="headerlink" title="使用Git仓库作为存储卷"></a>使用<code>Git</code>仓库作为存储卷</h3><p><code>gitRepo</code>卷基本上也是一个<code>emptyDir</code>卷, 它通过克隆<code>Git</code>仓库并在<code>pod</code>启动时(但在创建容器之前)检出特定版本类填充数据. </p><p>在创建<code>gitRepo</code>卷之后, 它并不能和对应<code>repo</code>保持同步. 当向<code>Git</code>仓库推送新增的提交时, 卷中的文件将不会被更新. </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">gitRepo:</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">https://github.com/luksa/kubia-website-example.git</span></span><br><span class="line">      <span class="attr">directory:</span> <span class="string">.</span> </span><br></pre></td></tr></table></figure><h4 id="介绍sidercar容器"><a href="#介绍sidercar容器" class="headerlink" title="介绍sidercar容器"></a>介绍<code>sidercar</code>容器</h4><p><code>sidecar container</code>, 它是一种容器, 增加了对<code>pod</code>主容器的操作. 可以将一个<code>sidecar</code>添加到<code>pod</code>中, 这样就可以使用现有的容器镜像, 而不是将附加逻辑填入主应用程序的代码中, 这会使它过于复杂和不可用. </p><h2 id="访问工作节点文件系统上的文件"><a href="#访问工作节点文件系统上的文件" class="headerlink" title="访问工作节点文件系统上的文件"></a>访问工作节点文件系统上的文件</h2><p>大多数<code>pod</code>应该忽略它们的主机节点, 因此它们不应该访问节点文件系统上的任何文件. 但是某系系统级别的<code>pod</code>(切记, 这些通常由<code>DaemonSet</code>管理)确实需要读取节点的文件或使用节点文件系统来访问节点设备. <code>Kubernetes</code>通过<code>hostPath</code>卷实现了这一点. </p><h3 id="介绍hostPath卷"><a href="#介绍hostPath卷" class="headerlink" title="介绍hostPath卷"></a>介绍<code>hostPath</code>卷</h3><p><code>hostPath</code>卷是持久性存储, 因为<code>gitRepo</code>和<code>emptyDir</code>卷的内容都会在<code>pod</code>被删除时被删除, 而<code>hostPath</code>卷的内容则不会被删除. 如果删除了一个<code>pod</code>, 并且下一个<code>pod</code>使用了指向主机上相同路径的<code>hostPath</code>卷, 则新<code>pod</code>将会发现上一个<code>pod</code>留下的数据, 但前提是必须将其调度到与第一个<code>pod</code>相同的节点上. </p><h2 id="使用持久化存储"><a href="#使用持久化存储" class="headerlink" title="使用持久化存储"></a>使用持久化存储</h2><p>当运行在一个<code>pod</code>中的应用程序需要将数据保存到磁盘上, 并且即使该<code>pod</code>重新调度到另一个节点时也要求具有相同的数据可用. 这就不能使用<code>emptyDir</code>, <code>gitRepo</code>和<code>hostPath</code>, 由于这些数据需要从任何集群节点访问, 因此必须将其存储在某种类型的网络储存中. </p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubernetes in Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes编排原理</title>
      <link href="/2023/10/02/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/Kubernetes%E7%BC%96%E6%8E%92%E5%8E%9F%E7%90%86/"/>
      <url>/2023/10/02/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/Kubernetes%E7%BC%96%E6%8E%92%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes编排原理"><a href="#Kubernetes编排原理" class="headerlink" title="Kubernetes编排原理"></a><code>Kubernetes</code>编排原理</h1><h2 id="为什么我们需要Pod"><a href="#为什么我们需要Pod" class="headerlink" title="为什么我们需要Pod"></a>为什么我们需要<code>Pod</code></h2><p><code>Pod</code>是<code>Kubernetes</code>项目中最小的<code>API</code>对象. 更专业的表述是: <code>Pod</code>是<code>Kubernetes</code>项目的原子调度单位. </p><p>容器的”单进程模型”并不是指容器里只能运行”一个”进程, 而是指容器无法管理多个进程. 这是因为容器里<code>PID=1</code>的进程就是应用本身, 其他进程都是这个<code>PID=1</code>进程的子进程. 可是, 用户编写的应用并不像正常操作系统里的<code>init</code>进程或者<code>systemd</code>那样拥有进程管理的功能. </p><p>在<code>Kubernetes</code>项目里, <code>Pod</code>的实现需要使用一个中间容器, 这个容器叫作<code>Infra</code>容器. 在这个<code>Pod</code>中, <code>Infra</code>容器永远是第一个被创建的容器, 用户定义的其他容器则通过<code>Join Network Namespace</code>的方式与<code>Infra</code>容器关联在一起. </p><h2 id="Pod对象使用进阶"><a href="#Pod对象使用进阶" class="headerlink" title="Pod对象使用进阶"></a><code>Pod</code>对象使用进阶</h2><p>在<code>Kubernetes</code>中有几种特殊的<code>Volume</code>, 它们存在的意义不是为了存放容器里的数据, 也不是用于容器和宿主机之间的数据交换, 而是为容器提供预先定义好的数据. </p><h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a><code>Secret</code></h3><p><code>Secret</code>的作用是帮你把<code>Pod</code>想要访问的加密数据存放在<code>etcd</code>中, 你就可以通过在<code>Pod</code>的容器里挂载<code>Volume</code>的方式访问这些<code>Secret</code>里保存的信息了. </p><p>像这样通过挂载方式进入容器里的<code>Secret</code>, 一旦其对应的<code>etcd</code>里的数据更新, 这些<code>Volume</code>里的文件内容也会更新. 其实, 这是<code>kubelet</code>组件在定时维护这些<code>Volume</code>. </p><p>需要注意的是, 这个更新可能会有一定的延时. 所以在编写应用程序时, 在发起数据库连接的代码处写好重试和超时的逻辑, 绝对是个好习惯. </p><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a><code>ConfigMap</code></h3><p><code>ConfigMap</code>与<code>Secret</code>类似, 区别在于<code>ConfigMap</code>保存的是无需加密的, 应用所需要的配置信息. </p><h3 id="DownwardAPI"><a href="#DownwardAPI" class="headerlink" title="DownwardAPI"></a><code>DownwardAPI</code></h3><p><code>DownwardAPI</code>的作用是让<code>Pod</code>里的容器能够直接获取这个<code>PodAPI</code>对象本身的信息. </p><p>不过, 需要注意的是, <code>DownwardAPI</code>能够获取的信息一定是<code>Pod</code>里的容器进程启动之前就能确定下来的信息. 如果你想要获得<code>Pod</code>容器运行后才会出现的信息, 比如容器进程的<code>PID</code>, 就肯定不能使用<code>DownwardAPI</code>了, 而应该考虑在<code>Pod</code>里定义一个<code>sidecar</code>容器. </p><h3 id="ServiceAccountToken"><a href="#ServiceAccountToken" class="headerlink" title="ServiceAccountToken"></a><code>ServiceAccountToken</code></h3><p><code>Service Account</code>对象的作用就是<code>Kubernetes</code>系统内置的一种”服务账户”, 它是<code>Kubernetes</code>进行权限分配的对象. 比如, <code>Service Account A</code>可以只被允许对<code>Kubernetes</code>进行<code>GET</code>操作, 而<code>Service Account B</code>可以有<code>Kubernetes API</code>的所有操作的权限. </p><p>像这样的<code>Service Account</code>的授权信息和文件, 实际上保存在它所绑定的一个特殊的<code>Secret</code>对象里. 这个特殊的<code>Secret</code>对象叫作<code>ServiceAccountToken</code>. 任何在<code>Kubernetes</code>集群上运行的应用, 都必须使用<code>ServiceAccountToken</code>里保存的授权信息(也就是<code>token</code>), 才可以合法访问<code>API Server</code>. </p><h2 id="容器健康检查和恢复机制"><a href="#容器健康检查和恢复机制" class="headerlink" title="容器健康检查和恢复机制"></a>容器健康检查和恢复机制</h2><p><code>Kubernetes</code>中的重启, 实际上却是重新创建了容器. 这个功能就是<code>Kubernetes</code>里的<code>Pod</code>恢复机制, 也叫<code>restartPolicy</code>. </p><p>一定要强调的是, <code>Pod</code>的恢复过程永远发生在当前节点上, 而不会跑到别的节点上. 事实上, 一旦一个<code>Pod</code>与一个节点绑定, 除非这个绑定关系发生了变化<code>pod.spec.node</code>字段被修改, 否则它永远不会离开这个节点. </p><p>如果你想让<code>Pod</code>出现在其他的可用节点上, 就必须使用<code>Deployment</code>这样的”控制器”来管理<code>Pod</code>, 哪怕你只需要一个<code>Pod</code>副本. </p><p>如果你关心这个容器退出后的上下文环境, 比如容器退出后的日志, 文件和目录, 就需要将<code>restartPolicy</code>设置为<code>Never</code>. 这是因为一旦容器被自动重新创建, 这些内容就有可能丢失(被垃圾回收了). </p><p>只要<code>Pod</code>的<code>restartPolicy</code>指定的策略允许重启异常的容器, 那么这个<code>Pod</code>就会保持<code>Running</code>状态并重启容器, 否则<code>Pod</code>会进入<code>Failed</code>状态. </p><p>对于包含多个容器的<code>Pod</code>, 只有其中所有的容器都进入异常状态后, <code>Pod</code>才会进入<code>Failed</code>状态. </p><h2 id="PodPreset"><a href="#PodPreset" class="headerlink" title="PodPreset"></a><code>PodPreset</code></h2><p><code>PodPreset</code>里定义的内容只会在<code>Pod API</code>对象被创建之前追加在这个对象上, 而不会影响任何<code>Pod</code>的控制器的定义. 比如, 现在提交的是一个<code>nginx-deployment</code>, 那么这个<code>Deployment</code>对象永远不会被<code>PodPreset</code>改变, 被修改的只是这个<code>Deployment</code>创建出来的所有<code>Pod</code>. </p><p>如果你定义了同时作用于一个<code>Pod</code>对象的多个<code>PodPreset</code>, 会发生什么呢?</p><p>实际上, <code>Kubernetes</code>项目会帮你合并这两个<code>PodPreset</code>要做的修改, 而如果它们要做的有冲突的话, 这些冲突字段就不会被修改. </p><h2 id="谈谈”控制器”思想"><a href="#谈谈”控制器”思想" class="headerlink" title="谈谈”控制器”思想"></a>谈谈”控制器”思想</h2><p>像<code>Deployment</code>定义的<code>template</code>字段, 在<code>Kubernetes</code>项目中有一个专属的名字, 叫作<code>PodTemplate</code>(<code>Pod</code>模版). </p><h2 id="作业副本与水平扩展"><a href="#作业副本与水平扩展" class="headerlink" title="作业副本与水平扩展"></a>作业副本与水平扩展</h2><p>如果你更新了<code>Deployment</code>的<code>Pod</code>模版, 那么<code>Deployment</code>就需要遵循一种叫作滚动更新的方式, 来升级现有容器. </p><p>创建<code>Deployment</code>时建议指定<code>--record</code>参数, 因此创建回滚版本的时候执行的<code>kubectl</code>命令都会被记录下来, 否则通过<code>kubectl rollout history</code>命令查看历史版本时, <code>CHANGE-CAUSE</code>这一栏会是空. </p><h2 id="深入理解StatefulSet-一-拓扑状态"><a href="#深入理解StatefulSet-一-拓扑状态" class="headerlink" title="深入理解StatefulSet(一): 拓扑状态"></a>深入理解<code>StatefulSet(一)</code>: 拓扑状态</h2><p>这种实例之间有不对等关系, 以及实例对外部是数据有依赖关系的应用, 就称为有状态应用. </p><p><code>StatefulSet</code>的设计其实非常容易理解, 它把现实世界里的应用状态抽象为了两种情况. </p><h3 id="拓扑状态"><a href="#拓扑状态" class="headerlink" title="拓扑状态"></a>拓扑状态</h3><p>应用的多个实例之间不是完全对等的. 这些应用实例必须按照某种顺序启动, 比如应用的主节点A要先于从节点B启动. 而如果删除A和B两个<code>Pod</code>, 它们再次被创建出来时也必须严格按照这个顺序运行. 并且, 新创建出来的<code>Pod</code>必须和原来<code>Pod</code>的网络标识一样, 这丫原先的访问者才能使用同样的方法访问到这个新的<code>Pod</code>. </p><h3 id="存储状态"><a href="#存储状态" class="headerlink" title="存储状态"></a>存储状态</h3><p>应用的多个实际分别绑定了不同的存储数据. 对于这些应用实例来说, <code>Pod A</code>第一次读取到的数据和隔了10分钟之后再此读取到数据应该是同一份, 哪怕在此期间<code>Pod A</code>被创建过. </p><p><code>StatefulSet</code>的核心功能, 就是通过某种方式记录这些状态, 然后在<code>Pod</code>被重新创建时, 能够为新的<code>Pod</code>恢复这些状态. </p><h4 id="Service如何被访问的"><a href="#Service如何被访问的" class="headerlink" title="Service如何被访问的"></a>Service如何被访问的</h4><p>第一种是以<code>Service</code>的<code>VIP</code>(<code>virtual IP</code>, 虚拟IP)方式.</p><p>第二种是以<code>Service</code>的<code>DNS</code>方式. </p><p>在第二种<code>Service DNS</code>的方式下, 具体又可以分为两种处理方法. </p><p>第一种处理方法是<code>Normal Service</code>.</p><p>第二种处理方法是<code>Headless Service</code>. <code>Headless Service</code>中<code>cluster IP</code>字段是的值是<code>None</code>, 即这个<code>Service</code>没有一个<code>VIP</code>作为”头”. 这个<code>Service</code>被创建后并不会被分配一个<code>VIP</code>, 而是会以<code>DNS</code>记录的方式暴露出它所代理的<code>Pod</code>. </p><p>通过这种方法, <code>Kubernetes</code>就成功地将<code>Pod</code>的拓扑状态(比如哪个节点先启动, 哪个节点后启动), 按照<code>Pod</code>的”名字+编号”的方式固定下来. 此外, <code>Kubernetes</code>还为每个<code>Pod</code>提供了一个固定且唯一的访问入口, 即这个<code>Pod</code>对应的<code>DNS</code>记录. 这些状态在<code>StatefulSet</code>的整个生命周期里都保持不变, 绝不会因为对应<code>Pod</code>的删除或者重新创建而失败. </p><p><code>DNS</code>记录本身不会变, 但它解析到的<code>Pod</code>的<code>IP</code>地址并不是固定的. 这就意味着, 对于有状态应用实例的访问, 必须使用<code>DNS</code>记录或者<code>hostname</code>的方式, 而绝不应该直接访问这些<code>Pod</code>的<code>IP</code>地址. </p><h2 id="深入理解StatefulSet-二-存储状态"><a href="#深入理解StatefulSet-二-存储状态" class="headerlink" title="深入理解StatefulSet(二): 存储状态"></a>深入理解<code>StatefulSet(二)</code>: 存储状态</h2><p><code>StatefulSet</code>的控制器直接管理的是<code>Pod</code>. <code>Kubernetes</code>通过<code>Headless Service</code>为这些有编号的<code>Pod</code>, 在<code>DNS</code>服务器中生成带有相同编号的<code>DNS</code>编号. <code>StatefulSet</code>还为每一个<code>Pod</code>分配并创建了一个相同编号的<code>PVC</code>. </p><h2 id="容器化守护进程-DaemonSet"><a href="#容器化守护进程-DaemonSet" class="headerlink" title="容器化守护进程: DaemonSet"></a>容器化守护进程: <code>DaemonSet</code></h2><p>跟其他编排对象不同, <code>DaemonSet</code>开始运行的时候很多时候要比整个<code>Kubernetes</code>集群出现的时机要早. </p><p>在<code>Kubernetes</code>项目中, 当一个节点的网络插件尚未安装时, 该节点就会被自动加上名为<code>node.kubernetes.io/network-unavailable</code>的”污点”. 而通过这样一个<code>Toleration</code>, 调度器在调度这个<code>Pod</code>时就会忽略当前节点上的”污点”, 从而成功地将网络插件的<code>Agent</code>组件调度到这台机器上启动起来. </p><h2 id="撬动离线业务-Job和CronJob"><a href="#撬动离线业务-Job和CronJob" class="headerlink" title="撬动离线业务: Job和CronJob"></a>撬动离线业务: <code>Job</code>和<code>CronJob</code></h2><p>事实上, <code>restartPolicy</code>在<code>Job</code>对象里只允许设置为<code>Never</code>和<code>OnFailure</code>; 而在<code>Deployment</code>对象里, <code>restartPolicy</code>只允许设置为<code>Always</code>. </p><p>如果<code>restartPolicy=Never</code>, 那么离线业务失败后<code>Job Controller</code>就会不断尝试创建一个新<code>Pod</code>. 如果<code>restartPolicy=OnFailure</code>, 那么离线业务失败后, <code>Job Controller</code>就不会尝试创建新的<code>Pod</code>, 而是不断尝试重启<code>Pod</code>里的容器. </p><p><code>CronJob</code>是一个专门用来管理<code>Job</code>对象的控制器. </p><h2 id="基于角色的权限控制-RBAC"><a href="#基于角色的权限控制-RBAC" class="headerlink" title="基于角色的权限控制: RBAC"></a>基于角色的权限控制: <code>RBAC</code></h2><p>我们知道, <code>Kubernetes</code>中所有<code>API</code>对象都保存在<code>etcd</code>里. 可是, 对这些<code>API</code>对象的操作一定都是通过访问<code>kube-apiserver</code>实现的. 其中一个非常重要的原因是, 需要<code>API Server</code>来帮忙做授权工作. 而在<code>Kubernetes</code>项目中, 负责完成授权工作的机制是<code>RBAC</code>. </p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 深入剖析Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务</title>
      <link href="/2023/09/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/09/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p><code>pod</code>需要一种寻找其他<code>pod</code>的方法来使用其他<code>pod</code>提供的服务, 不想在没有<code>Kubernetes</code>的世界, 系统管理员要在用户端配置文件中明确指出服务的精确IP地址或主机名来配置每个服务短应用. </p><h2 id="介绍服务"><a href="#介绍服务" class="headerlink" title="介绍服务"></a>介绍服务</h2><p><code>Kubernetes</code>服务是一种为一组功能相同的<code>pod</code>提供单一不变的接入点的资源. 当服务存在是, 它的<code>IP</code>地址和端口不会改变. 客户端通过<code>IP</code>地址和端口号建立连接, 这些连接会被路由到提供该服务的任意一个<code>pod</code>上. 通过这种方式, 客户端不需要知道每个单独的提供服务的<code>pod</code>的地址, 这样这些<code>pod</code>就可以在集群中随时被创建或移除. </p><h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>服务的后端可以有不止一个<code>pod</code>. 服务的连接对所有的后端<code>pod</code>是负载均衡的. </p><p><code>CLUSTER-IP</code>只能在集群内部可以被访问, 是为了让集群内部的其他<code>pod</code>可以访问当前这组<code>pod</code>. </p><h4 id="在运行的容器中远程执行命令"><a href="#在运行的容器中远程执行命令" class="headerlink" title="在运行的容器中远程执行命令"></a>在运行的容器中远程执行命令</h4><p>嗯可以使用<code>kubectl exec</code>命令远程地在一个已经存在的<code>pod</code>容器上执行任何命令. 这样就可以很方便地了解<code>pod</code>的内容, 状态及环境. <code>--</code>代表着命令项的结束. </p><h4 id="配置服务的回话亲和性"><a href="#配置服务的回话亲和性" class="headerlink" title="配置服务的回话亲和性"></a>配置服务的回话亲和性</h4><p>如果希望特定客户端产生的所有请求每次都指向同一个<code>pod</code>, 可以设置服务的<code>sessionAffinity</code>属性为<code>ClientIP</code>(而不是<code>None</code>, <code>None</code>是默认值). </p><h4 id="同一个服务暴露多个端口"><a href="#同一个服务暴露多个端口" class="headerlink" title="同一个服务暴露多个端口"></a>同一个服务暴露多个端口</h4><p>在创建一个有多个端口的服务的时候, 必须给每个端口指定名字. </p><h4 id="使用命名的端口"><a href="#使用命名的端口" class="headerlink" title="使用命名的端口"></a>使用命名的端口</h4><p>服务中可以通过数字来指定端口, 也可以通过名称来指定. </p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>客户端<code>pod</code>如何知道服务的<code>IP</code>和端口. <code>Kubernetes</code>为客户端提供了发现服务的<code>IP</code>和端口的方式. </p><h4 id="通过环境变量发现服务"><a href="#通过环境变量发现服务" class="headerlink" title="通过环境变量发现服务"></a>通过环境变量发现服务</h4><p>在<code>pod</code>开始运行的时候, <code>Kubernetes</code>会初始化一系列的环境变量指向现在存在的服务. 如果你创建的服务中早于客户端<code>pod</code>的创建, <code>pod</code>上的进程可以根据环境变量获得服务的<code>IP</code>地址和端口号. </p><h4 id="通过DNS发现服务"><a href="#通过DNS发现服务" class="headerlink" title="通过DNS发现服务"></a>通过<code>DNS</code>发现服务</h4><p><code>kube-dns</code>运行<code>DNS</code>服务, 在集群中的其他<code>pod</code>都被配置成使用其作为<code>dns</code>(<code>Kubernetes</code>通过修改每个容器的<code>/etc/resolv.conf</code>文件实现). 运行在<code>pod</code>上的进程<code>DNS</code>查询都会被<code>Kubernetes</code>自身的<code>DNS</code>服务器响应, 该服务器知道系统中运行的所有服务. </p><p><code>pod</code>是否使用内部的<code>DNS</code>服务器是根据<code>pod</code>中的<code>spec</code>的<code>dnsPolicy</code>属性来决定的. </p><p>每个服务从内部<code>DNS</code>服务器中获得一个<code>DNS</code>条目, 客户端的<code>pod</code>在知道服务名称的情况下可以通过全限定域名来访问, 而不是诉诸于环境变量. </p><h4 id="通过全限定域名连接服务"><a href="#通过全限定域名连接服务" class="headerlink" title="通过全限定域名连接服务"></a>通过全限定域名连接服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;服务名&gt;.&lt;服务的命名空间&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure><p>客户端仍然必须知道服务的端口后. 如果不是标准端口, 客户端可以从环境变量中获取端口号. </p><h2 id="连接集群外部的服务"><a href="#连接集群外部的服务" class="headerlink" title="连接集群外部的服务"></a>连接集群外部的服务</h2><h3 id="介绍服务endpoint"><a href="#介绍服务endpoint" class="headerlink" title="介绍服务endpoint"></a>介绍服务<code>endpoint</code></h3><p>服务并不是和<code>pod</code>直接相连的. 相反, 有一种资源介于两者之间<code>--</code>它就是<code>Endpoint</code>资源. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get endpoints &lt;服务名&gt;</span><br></pre></td></tr></table></figure><h3 id="手动配置服务的endpoint"><a href="#手动配置服务的endpoint" class="headerlink" title="手动配置服务的endpoint"></a>手动配置服务的<code>endpoint</code></h3><p>服务的<code>endpoint</code>与服务解耦后, 可以分别配置和更新它们. </p><p><code>Endpoint</code>对象需要与服务具有相同的名称. </p><h2 id="将服务暴露给外部客户端"><a href="#将服务暴露给外部客户端" class="headerlink" title="将服务暴露给外部客户端"></a>将服务暴露给外部客户端</h2><h3 id="使用NodePort类型的服务"><a href="#使用NodePort类型的服务" class="headerlink" title="使用NodePort类型的服务"></a>使用<code>NodePort</code>类型的服务</h3><p>通过创建<code>NodePort</code>服务, 可以让<code>Kubernetes</code>在其所有节点上保留一个端口(所有节点都使用相同的端口), 并将传入的连接转发给作为服务部分的<code>pod</code>. </p><h3 id="通过负载均衡器将服务暴露出来"><a href="#通过负载均衡器将服务暴露出来" class="headerlink" title="通过负载均衡器将服务暴露出来"></a>通过负载均衡器将服务暴露出来</h3><h4 id="回话亲和性和Web浏览器"><a href="#回话亲和性和Web浏览器" class="headerlink" title="回话亲和性和Web浏览器"></a>回话亲和性和<code>Web</code>浏览器</h4><p>浏览器使用<code>keep-alive</code>连接, 并通过单个连接发送所有请求, 而<code>curl</code>每次都会打开一个新连接. 服务在连接级别工作, 所以当首次打开服务的连接时, 会选择一个随机集群, 然后将属于该连接的所有网络数据包全部发送到单个集群. 即使会话亲和性设置为<code>None</code>, 用户也会始终使用相同的<code>pod</code>(直到连接关闭). </p><h2 id="通过Ingress暴露服务"><a href="#通过Ingress暴露服务" class="headerlink" title="通过Ingress暴露服务"></a>通过<code>Ingress</code>暴露服务</h2><h4 id="为什么需要Ingress"><a href="#为什么需要Ingress" class="headerlink" title="为什么需要Ingress"></a>为什么需要Ingress</h4><p>一个重要的原因是每个<code>LoadBalancer</code>服务都需要自己的负载均衡器, 以及独有的公有<code>IP</code>地址, 而<code>Ingress</code>只需要一个公网<code>IP</code>就能为许多服务提供访问. 当客户端向<code>Ingress</code>发送<code>HTTP</code>请求时, <code>Ingress</code>会根据请求的主机名和路径决定请求转发到的服务. </p><h4 id="了解Ingress的工作原理"><a href="#了解Ingress的工作原理" class="headerlink" title="了解Ingress的工作原理"></a>了解<code>Ingress</code>的工作原理</h4><p><code>Ingress</code>控制器不会将请求转发给该服务, 只用它来选择一个<code>pod</code>. </p><h2 id="pod就绪后发出信号"><a href="#pod就绪后发出信号" class="headerlink" title="pod就绪后发出信号"></a><code>pod</code>就绪后发出信号</h2><h3 id="介绍就绪探针"><a href="#介绍就绪探针" class="headerlink" title="介绍就绪探针"></a>介绍就绪探针</h3><p>就绪探针器会定期调用, 并确定特定的<code>pod</code>是否接收客户端请求. 当容器的准备就绪探测返回成功时, 表示容器已经准备好接收请求. </p><h4 id="了解就绪探针的操作"><a href="#了解就绪探针的操作" class="headerlink" title="了解就绪探针的操作"></a>了解就绪探针的操作</h4><p>启动容器时, 可以为<code>Kubernetes</code>配置一个等待时间, 经过等待时间后才可以执行第一次就绪检查. 之后, 它会周期性地调用探针, 并根据就绪探针的结果采取行动. 如果某个<code>pod</code>报告它尚未准备就绪, 则会从该服务中删除该<code>pod</code>. 如果<code>pod</code>再次准备就绪, 则重新添加<code>pod</code>. </p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubernetes in Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>副本机制和其他控制器</title>
      <link href="/2023/09/23/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E5%92%8C%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>/2023/09/23/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E5%92%8C%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="副本机制和其他控制器-部署托管的pod"><a href="#副本机制和其他控制器-部署托管的pod" class="headerlink" title="副本机制和其他控制器: 部署托管的pod"></a>副本机制和其他控制器: 部署托管的<code>pod</code></h1><h2 id="保持pod健康"><a href="#保持pod健康" class="headerlink" title="保持pod健康"></a>保持<code>pod</code>健康</h2><p>只要<code>pod</code>调度到某个节点, 该节点上的<code>Kubelet</code>就会运行<code>pod</code>的容器, 从此只要该<code>pod</code>存在, 就会保持运行. 如果容器的主进程崩溃, <code>Kubelet</code>将重启容器. </p><p>程序可以能因为无限循环或死锁而停止响应, 为确保应用程序在这种情况下可以重新启动, 必须从外部检查应用程序的运行状态, 而不是依赖于应用的内部检测. </p><h4 id="介绍存活探针"><a href="#介绍存活探针" class="headerlink" title="介绍存活探针"></a>介绍存活探针</h4><p><code>Kubernetes</code>可以通过存活探针(liveness probe)检查容器是否还在运行. 可以为<code>pod</code>中每个容器单独指定存活探针, 如果检测失败, <code>Kubernetes</code>将定期执行探针并重启容器. </p><p><code>Kubernetes</code>有以下三种检测容器的机制:</p><p><code>HTTP GET</code>探针对容器的<code>IP</code>地址(你指定的端口和路径)执行<code>HTTP GET</code>请求. 如果探测器收到响应, 并且响应码不代表错误, 则认为探测成功. 如果服务器返回错误响应码或者根本没有响应, 那么特测被认为是失败的, 容器将被重新启动. </p><p><code>TCP</code>套接字探针尝试与容器指定端口建立<code>TCP</code>连接. 如果连接成功建立, 则探测成功. 否则, 容器重新启动. </p><p><code>Exec</code>探针在容器内执行任意命令, 并检查命令的退出状态码. 如果状态码是<code>0</code>, 则探测成功. 所有其他状态码都认为失败. </p><h3 id="创建基于HTTP的存活探针"><a href="#创建基于HTTP的存活探针" class="headerlink" title="创建基于HTTP的存活探针"></a>创建基于<code>HTTP</code>的存活探针</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">liveness:</span></span><br><span class="line"><span class="attr">httpGet:</span></span><br><span class="line"><span class="attr">path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>该<code>pod</code>的描述文件定义了一个<code>httpGet</code>探针, 该探针告诉<code>Kubernetes</code>定期在端口<code>8080</code>路径上执行<code>HTTP GET</code>请求, 以确定容器是否健康. </p><h3 id="使用存活探针"><a href="#使用存活探针" class="headerlink" title="使用存活探针"></a>使用存活探针</h3><h4 id="获取崩溃容器的应用日志"><a href="#获取崩溃容器的应用日志" class="headerlink" title="获取崩溃容器的应用日志"></a>获取崩溃容器的应用日志</h4><p>如果容器重启, <code>Kubectl logs</code>命令将显示当前容器的日志. 当你想知道前一个容器为什么终止时. 可以通过添加<code>--previous</code>选项. </p><p>容器被强行终止时, 会创建一个全新的容器<code>--</code>而不是重启原来的容器. </p><h3 id="配置存活探针的附加属性"><a href="#配置存活探针的附加属性" class="headerlink" title="配置存活探针的附加属性"></a>配置存活探针的附加属性</h3><p>除了明确指定的存活探针选项, 还可以看到其他属性, 例如delay, timeout, period等. </p><p>请务必记得设置一个初始延时来说明应用程序的启动时间. </p><h3 id="创建有效的存活探针"><a href="#创建有效的存活探针" class="headerlink" title="创建有效的存活探针"></a>创建有效的存活探针</h3><p>对于在生产中运行的<code>pod</code>, 一定要定义一个存活探针. 没有探针的话, <code>Kubernetes</code>无法知道你的应用是否还活着. 只要进程还存在, <code>Kubernetes</code>会认为容器是健康的. </p><h2 id="了解ReplicationController"><a href="#了解ReplicationController" class="headerlink" title="了解ReplicationController"></a>了解<code>ReplicationController</code></h2><p><code>ReplicationController</code>是一种<code>Kubernetes</code>资源, 可确保它的<code>pod</code>始终保持运行状态. </p><h3 id="ReplicationController的操作"><a href="#ReplicationController的操作" class="headerlink" title="ReplicationController的操作"></a><code>ReplicationController</code>的操作</h3><p><code>RelicationController</code>会持续监控正在运行的<code>pod</code>列表, 并保证相应”类型”的<code>pod</code>的数目与期望的相符. </p><h4 id="介绍控制器的协调流程"><a href="#介绍控制器的协调流程" class="headerlink" title="介绍控制器的协调流程"></a>介绍控制器的协调流程</h4><p><code>ReplicationController</code>的工作是确保<code>pod</code>的数量始终与其标签选择器匹配. 如果不匹配, 则<code>ReplicationController</code>将根据所需, 采取适当地操作来协调<code>pod</code>的数量. </p><h2 id="使用DaemonSet在每个节点上运行一个pod"><a href="#使用DaemonSet在每个节点上运行一个pod" class="headerlink" title="使用DaemonSet在每个节点上运行一个pod"></a>使用<code>DaemonSet</code>在每个节点上运行一个<code>pod</code></h2><h2 id="运行执行单个任务的pod"><a href="#运行执行单个任务的pod" class="headerlink" title="运行执行单个任务的pod"></a>运行执行单个任务的<code>pod</code></h2><h3 id="介绍Job资源"><a href="#介绍Job资源" class="headerlink" title="介绍Job资源"></a>介绍<code>Job</code>资源</h3><p>在发生节点故障时, 该节点上由<code>Job</code>管理的<code>pod</code>将按照<code>ReplicaSet</code>的<code>pod</code>的方式, 重新安排到其他节点. 如果进程本身异常退出(进程返回错误退出代码时), 可以将<code>Job</code>配置为重新启动容器. </p><h2 id="安排Job定期运行或在将来运行一次"><a href="#安排Job定期运行或在将来运行一次" class="headerlink" title="安排Job定期运行或在将来运行一次"></a>安排<code>Job</code>定期运行或在将来运行一次</h2><p><code>Job</code>资源在创建时会立即运行<code>pod</code>. 但是许多批处理任务需要在特定时间运行, 或者在指定的时间间隔內重复运行. 在<code>Linux</code>和类<code>UNIX</code>操作系统中, 这些任务通常被称为<code>cron</code>任务. </p><h3 id="了解计划任务的运行方式"><a href="#了解计划任务的运行方式" class="headerlink" title="了解计划任务的运行方式"></a>了解计划任务的运行方式</h3><p>在正常情况下, <code>CronJob</code>总是计划为配置中的每个执行创建一个<code>Job</code>, 但是可能会同时创建两个<code>Job</code>, 或者根本没有创建. 为了解决第一个问题, 你的任务应该是幂等的. 对于第二个问题, 请确保下一个任务完成本应该由上一次的(错过的)运行完成的工作. </p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubernetes in Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行于Kubernetes中的容器</title>
      <link href="/2023/09/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E8%BF%90%E8%A1%8C%E4%BA%8EKubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/09/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E8%BF%90%E8%A1%8C%E4%BA%8EKubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="运行于Kubernetes中的容器"><a href="#运行于Kubernetes中的容器" class="headerlink" title="运行于Kubernetes中的容器"></a>运行于<code>Kubernetes</code>中的容器</h1><h2 id="介绍pod"><a href="#介绍pod" class="headerlink" title="介绍pod"></a>介绍<code>pod</code></h2><p>在实际应用中我们不会单独部署容器, 更多的是针对一组<code>pod</code>的容器进行部署和操作. </p><h3 id="为何需要pod"><a href="#为何需要pod" class="headerlink" title="为何需要pod"></a>为何需要<code>pod</code></h3><h4 id="为何多个容器比单个容器包含多个进程要好"><a href="#为何多个容器比单个容器包含多个进程要好" class="headerlink" title="为何多个容器比单个容器包含多个进程要好"></a>为何多个容器比单个容器包含多个进程要好</h4><p>容积被设计为每个容器只运行一个进程(除非进程本身产生进程). 如果在单个容器中运行多个不相关的进程, 那么保持所有进程运行, 管理它们的日志等将会是我们的责任. </p><h3 id="了解pod"><a href="#了解pod" class="headerlink" title="了解pod"></a>了解<code>pod</code></h3><h4 id="同一pod中容器之间的部分隔离"><a href="#同一pod中容器之间的部分隔离" class="headerlink" title="同一pod中容器之间的部分隔离"></a>同一<code>pod</code>中容器之间的部分隔离</h4><p>容器之间彼此是完全隔离的, 但是此时我们期望的是隔离容器组, 而不是单个容器, 并让每个容器组内的容器共享一些资源, 而不是全部. <code>Kubernetes</code>通过配置<code>Docker</code>来让一个<code>pod</code>内的所有容器共享相同的<code>Linux</code>命名空间, 而不是每个容器都有自己的一组命名空间. </p><h4 id="容器如何共享相同的IP和端口空间"><a href="#容器如何共享相同的IP和端口空间" class="headerlink" title="容器如何共享相同的IP和端口空间"></a>容器如何共享相同的IP和端口空间</h4><p>由于一个<code>pod</code>中的容器运行于相同的<code>Network</code>命名空间中, 因此它们共享相同的<code>IP</code>地址和端口空间. 有可能会产生端口冲突, 但这只涉及同一个<code>pod</code>中的容器. </p><h4 id="介绍平坦pod间网络"><a href="#介绍平坦pod间网络" class="headerlink" title="介绍平坦pod间网络"></a>介绍平坦<code>pod</code>间网络</h4><p><code>Kubernetes</code>集群中的所有<code>pod</code>都在同一个共享网络地址空间中, 这意味着每个<code>pod</code>都可以通过其他<code>pod</code>的<code>IP</code>地址来实现相互访问. </p><h3 id="通过pod合理管理容器"><a href="#通过pod合理管理容器" class="headerlink" title="通过pod合理管理容器"></a>通过<code>pod</code>合理管理容器</h3><p>将多层应用分散到多个<code>pod</code>中, 同时基于扩缩容考虑而分割到多个<code>pod</code>中. 当应用可能由一个主进程和一个或多个辅助进程时, 才有可能将多个容器添加到单个<code>pod</code>中. </p><h4 id="决定何时在pod中使用多个容器"><a href="#决定何时在pod中使用多个容器" class="headerlink" title="决定何时在pod中使用多个容器"></a>决定何时在<code>pod</code>中使用多个容器</h4><p>当决定是将两个容器放入到一个<code>pod</code>还是两个独立的<code>pod</code>时, 我们可以问自己以下几个问题: </p><ol><li>它们需要一起运行还是可以在不同的主机上运行?</li><li>它们代表的是一个整体还是相互独立的组件?</li><li>它们必须一起进行扩缩容还是可以分别进行?</li></ol><h2 id="以YAML或JSON描述文件创建pod"><a href="#以YAML或JSON描述文件创建pod" class="headerlink" title="以YAML或JSON描述文件创建pod"></a>以<code>YAML</code>或<code>JSON</code>描述文件创建<code>pod</code></h2><p><code>pod</code>和其他<code>Kubernetes</code>资源通常是通过向<code>Kubernetes REST API</code>提供<code>JSON</code>或<code>YAML</code>描述文件来创建的. 此外还有其他更简单的创建资源的方法, 比如<code>kubectl run</code>命令, 但这些方法通常只允许你配置一组有限的属性. </p><h3 id="检查现有pod的YAML描述文件"><a href="#检查现有pod的YAML描述文件" class="headerlink" title="检查现有pod的YAML描述文件"></a>检查现有<code>pod</code>的<code>YAML</code>描述文件</h3><p>获得<code>pod</code>的<code>yaml</code>信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods &lt;pod名称&gt; -o yaml</span><br></pre></td></tr></table></figure><h4 id="介绍pod定义的主要部分"><a href="#介绍pod定义的主要部分" class="headerlink" title="介绍pod定义的主要部分"></a>介绍<code>pod</code>定义的主要部分</h4><p><code>pod</code>定义由这么几个部分组成: 首先是<code>YAML</code>中使用的<code>Kubernetes API</code>版本和<code>YAML</code>描述的资源类型; 其次是几乎在所有<code>Kubernetes</code>资源中都可以找到的三大重要部分:</p><ol><li><code>metedata</code>包括名称, 命名空间, 标签和关于该容器的其他信息</li><li><code>spec</code>包含<code>pod</code>内容的实际说明, 例如<code>pod</code>的容器, 卷和其他数据.</li><li><code>status</code>包含运行中的<code>pod</code>的当前信息, 例如<code>pod</code>所处的条件, 每个容器的描述和状态, 以及内部<code>IP</code>和其他基本信息.</li></ol><h3 id="为pod创建一个简单的YAML描述文件"><a href="#为pod创建一个简单的YAML描述文件" class="headerlink" title="为pod创建一个简单的YAML描述文件"></a>为<code>pod</code>创建一个简单的<code>YAML</code>描述文件</h3><h4 id="使用kubectl-explain来发现可能的API对象字段"><a href="#使用kubectl-explain来发现可能的API对象字段" class="headerlink" title="使用kubectl explain来发现可能的API对象字段"></a>使用<code>kubectl explain</code>来发现可能的<code>API</code>对象字段</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain pods</span><br><span class="line"></span><br><span class="line">kubectl explain pod.spec</span><br></pre></td></tr></table></figure><h3 id="使用kubectl-create来创建pod"><a href="#使用kubectl-create来创建pod" class="headerlink" title="使用kubectl create来创建pod"></a>使用<code>kubectl create</code>来创建<code>pod</code></h3><p><code>kubectl create -f</code>命令用于从<code>yaml</code>或<code>json</code>文件中创建任何资源(不只是<code>pod</code>).</p><h3 id="查看应用程序日志"><a href="#查看应用程序日志" class="headerlink" title="查看应用程序日志"></a>查看应用程序日志</h3><p>容器化的应用程序通常会将日志记录到标准输出和标准错误流, 而不是将其写入文件. </p><p>容器运行时将这些流重定向到文件, 并允许我们运行以下命令来获取容器的日志:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;container id&gt;</span><br></pre></td></tr></table></figure><p>使用<code>ssh</code>命令登录到<code>pod</code>正在运行的节点, 并使用<code>docker logs</code>命令查看其日志, 但<code>Kubernetes</code>提供了一种更为简单的方法. </p><h4 id="使用kubectl-logs命令获取pod日志"><a href="#使用kubectl-logs命令获取pod日志" class="headerlink" title="使用kubectl logs命令获取pod日志"></a>使用<code>kubectl logs</code>命令获取<code>pod</code>日志</h4><p>为了查看<code>pod</code>的日志(更准确地说是容器的日志), 只需要在本地机器上运行以下命令(不需要<code>ssh</code>到任何地方): </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod名称&gt;</span><br></pre></td></tr></table></figure><h4 id="获取多容器pod的日志时指定容器名称"><a href="#获取多容器pod的日志时指定容器名称" class="headerlink" title="获取多容器pod的日志时指定容器名称"></a>获取多容器<code>pod</code>的日志时指定容器名称</h4><p>如果我们的<code>pod</code>包含多个容器, 在运行<code>kubectl logs</code>命令时则必须通过包含<code>-c &lt;容器名称&gt;</code>选项来显示指定容器名称. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod名称&gt; -c &lt;容器名称&gt;</span><br></pre></td></tr></table></figure><p>我们只能获取仍然存在的<code>pod</code>的日志. 当一个<code>pod</code>被删除时, 它的日志也会被删除. 如果希望在<code>pod</code>删除之后仍然可以获取其日志, 我们需要设置中心化的, 集群范围的日志系统, 将所有日志存储到中心存储中. </p><h3 id="向pod发送请求"><a href="#向pod发送请求" class="headerlink" title="向pod发送请求"></a>向<code>pod</code>发送请求</h3><h4 id="将本地网络端口转发到pod中的端口"><a href="#将本地网络端口转发到pod中的端口" class="headerlink" title="将本地网络端口转发到pod中的端口"></a>将本地网络端口转发到<code>pod</code>中的端口</h4><p>如果想要在不通过<code>service</code>的情况下与某个特定的<code>pod</code>进行通信(出于调试或其他原因), <code>Kubernetes</code>将允许我们配置端口转发到该<code>pod</code>. 可以通过<code>kubectl port-forward</code>命令完成上述操作. 例如以下命名会将机器的本地端口<code>8888</code>转发到目标<code>pod</code>的端口<code>8080</code>: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward &lt;pod名称&gt; 8888:8080</span><br></pre></td></tr></table></figure><h2 id="使用标签组织pod"><a href="#使用标签组织pod" class="headerlink" title="使用标签组织pod"></a>使用标签组织<code>pod</code></h2><p>我们需要一种能够基于任意标准将上述<code>pod</code>组织成更小群体的方式. 此外, 我们希望通过一次操作对属于某个组的所有<code>pod</code>进行操作, 而不必单独为每个<code>pod</code>执行操作. </p><p>通过标签来组织<code>pod</code>和所有其他<code>Kubernetes</code>对象. </p><h3 id="介绍标签"><a href="#介绍标签" class="headerlink" title="介绍标签"></a>介绍标签</h3><p>标签是一种简单却功能强大的<code>Kubernetes</code>特性, 不仅可以组织<code>pod</code>, 也可以组织所有其他的<code>Kubernetes</code>资源. 详细来说, 标签是可以附加到任意资源的任意键值对, 用以选择具有该确切标签的资源(这是通过标签选择器完成的). 只要标签的<code>key</code>在资源内是唯一的, 一个资源便可以拥有多个标签. 通常我们创建资源时就会将标签附加到资源上, 但之后我们也可以在添加其他标签, 或者修改现有标签的值, 而无须重新创建资源. </p><p>金丝雀发布是指在部署新版本时, 先只让小部分用户体验新版本以观察新版本的表现, 然后再向所有用户进行推广, 这样可以防止暴露有问题的版本给过多的用户. </p><h3 id="创建pod时指定标签"><a href="#创建pod时指定标签" class="headerlink" title="创建pod时指定标签"></a>创建<code>pod</code>时指定标签</h3><h4 id="显示所有标签"><a href="#显示所有标签" class="headerlink" title="显示所有标签"></a>显示所有标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --show-labels</span><br></pre></td></tr></table></figure><h4 id="显示特定标签"><a href="#显示特定标签" class="headerlink" title="显示特定标签"></a>显示特定标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -L &lt;label1的key&gt;,&lt;label2的key&gt;</span><br></pre></td></tr></table></figure><h3 id="修改现有pod的标签"><a href="#修改现有pod的标签" class="headerlink" title="修改现有pod的标签"></a>修改现有<code>pod</code>的标签</h3><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label po &lt;pod的名称&gt; &lt;新label的key&gt;=&lt;新label的value&gt; </span><br></pre></td></tr></table></figure><h4 id="修改标签"><a href="#修改标签" class="headerlink" title="修改标签"></a>修改标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label po &lt;pod的名称&gt; &lt;已存在label的key&gt;=&lt;label的值&gt;</span><br></pre></td></tr></table></figure><h2 id="通过标签选择器列出pod子集"><a href="#通过标签选择器列出pod子集" class="headerlink" title="通过标签选择器列出pod子集"></a>通过标签选择器列出<code>pod</code>子集</h2><p>标签选择器允许我们选择标记有特定标签的<code>pod</code>子集, 并对这些<code>pod</code>执行操作. 可以说标签选择器是一种能够根据是否包含具有特定值的特定标签来过滤资源的准则. </p><p>标签选择器根据资源的以下条件来选择资源:</p><p>包含(或不包含)使用特定键的标签</p><p>包含具有特定键和值的标签</p><p>包含就有特定值的标签, 但其值与我们指定的不同</p><h3 id="使用标签选择器列出pod"><a href="#使用标签选择器列出pod" class="headerlink" title="使用标签选择器列出pod"></a>使用标签选择器列出<code>pod</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po -l &#x27;&lt;label的key&gt;&#x27;</span><br><span class="line">kubectl get po -l &#x27;!&lt;label的key&gt;&#x27;</span><br><span class="line">kubectl get po -l &lt;label的key&gt;=&lt;label的value&gt;</span><br><span class="line">kubectl get po -l &lt;label的key&gt;!=&lt;label的value&gt;</span><br><span class="line">kubectl get po -l &lt;label的key&gt;in (&lt;label的value&gt;, &lt;label的value&gt;)</span><br><span class="line">kubectl get po -l &lt;label的key&gt;notin (&lt;label的value&gt;, &lt;label的value&gt;)</span><br></pre></td></tr></table></figure><h3 id="在标签选择器中使用多个条件"><a href="#在标签选择器中使用多个条件" class="headerlink" title="在标签选择器中使用多个条件"></a>在标签选择器中使用多个条件</h3><p>在包含多个逗号分隔的情况下, 可以在标签选择器中同时使用多个条件, 此时资源需要全部匹配才算成功匹配了选择器. </p><h2 id="使用标签和选择器来约束pod调度"><a href="#使用标签和选择器来约束pod调度" class="headerlink" title="使用标签和选择器来约束pod调度"></a>使用标签和选择器来约束<code>pod</code>调度</h2><h3 id="使用标签分类工作节点"><a href="#使用标签分类工作节点" class="headerlink" title="使用标签分类工作节点"></a>使用标签分类工作节点</h3><p>标签可以附加到任何<code>kubernetes</code>对象上, 包括节点. </p><h3 id="将pod调度到特定节点"><a href="#将pod调度到特定节点" class="headerlink" title="将pod调度到特定节点"></a>将<code>pod</code>调度到特定节点</h3><p>为了让调度器只在合适节点上进行选择, 我们需要在<code>pod</code>的<code>YAML</code>文件中添加一个节点选择器. 我们只是在<code>spec</code>部分添加了一个<code>nodeSelector</code>字段. </p><h3 id="调度到一个特定节点"><a href="#调度到一个特定节点" class="headerlink" title="调度到一个特定节点"></a>调度到一个特定节点</h3><p>同样地, 我们也可以将<code>pod</code>调度到某个确定的节点, 由于每个节点都有一个唯一标签, 其中键为<code>kubernetes.io/hostname</code>, 值为该节点的实际主机名, 因此我们也可以将<code>pod</code>调度到某个确定的节点. 我们绝不应该考虑单个节点, 而是应该通过标签选择器考虑符合特定标准的逻辑节点组. </p><h2 id="注解pod"><a href="#注解pod" class="headerlink" title="注解pod"></a>注解<code>pod</code></h2><p>除标签外, <code>pod</code>和其他对象还可以包含注解. 注解也是键值对, 所以它们本质上与标签非常相似. 但与标签不同, 注解并不是为了保存标识信息而存在的, 它们不能像标签一样用于对对象进行分组. </p><p>大量使用注解可以为每个<code>pod</code>或其他<code>API</code>对象添加说明, 以便每个使用该集群的人都可以快速查找有关每个单独对象的信息. </p><h3 id="查找对象的注解"><a href="#查找对象的注解" class="headerlink" title="查找对象的注解"></a>查找对象的注解</h3><p>为了查看注解, 我们需要获取<code>pod</code>的完整<code>YAML</code>文件或使用<code>kubectl describe</code>命令. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po &lt;pod的名称&gt; -o yaml</span><br><span class="line"></span><br><span class="line">kubectl describe</span><br></pre></td></tr></table></figure><h3 id="添加和修改注解"><a href="#添加和修改注解" class="headerlink" title="添加和修改注解"></a>添加和修改注解</h3><p>和标签一样, 注解可以在创建是就添加到<code>pod</code>中, 也可以在之后再对现有的<code>pod</code>进行添加或修改. 其中将注解添加到现有对象的最简单的方式是通过<code>kubectl annotate</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl annotate pod &lt;pod的名称&gt; &lt;注解的键&gt;=&lt;注解的值&gt;</span><br></pre></td></tr></table></figure><h2 id="使用命名空间对资源进行分组"><a href="#使用命名空间对资源进行分组" class="headerlink" title="使用命名空间对资源进行分组"></a>使用命名空间对资源进行分组</h2><p><code>Kubernetes</code>命名空间简单地为对象名称提供了一个作用域. 此时我们并不会将所有资源都放在同一个命名空间中, 而是将它们组织到多个命名空间中, 这样可以允许我们多次使用相同的资源名称. </p><h3 id="发现其他命名空间及其pod"><a href="#发现其他命名空间及其pod" class="headerlink" title="发现其他命名空间及其pod"></a>发现其他命名空间及其<code>pod</code></h3><p>列出命名空间: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ns</span><br></pre></td></tr></table></figure><p>当使用<code>kubectl get</code>命令列出资源时, 我们从未明确指定命名空间, 因此<code>kubectl</code>总是默认为<code>default</code>命名空间, 只显示该命名空间下的对象. </p><p>得到指定命名空间下的对象: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po -n &lt;命名空间&gt;</span><br></pre></td></tr></table></figure><p><code>namespace</code>使我们能够将不属于一组的资源分到不重叠的组中. 如果有多个用户或用户组正在使用同一个<code>Kubernetes</code>集群, 并且它们都各自管理自己独特的资源集合, 那么它们就应该使用各自的命名空间. 这样一来, 它们就不用特别担心无意中修改或删除其他用户的资源, 也无须关心名称冲突. 如前所述, 命名空间为资源名称提供了一个作用域. </p><p>除了隔离资源, 命名空间还可用于仅允许某些用户访问特定资源, 甚至限制单个用户可用的计算资源数量. </p><h3 id="创建一个命名空间"><a href="#创建一个命名空间" class="headerlink" title="创建一个命名空间"></a>创建一个命名空间</h3><p>命名空间是一种和其他资源一样的<code>Kubernetes</code>资源, 因此可以通过将<code>YAML</code>文件提交到<code>Kubernetes API</code>服务器来创建该资源. </p><p>还可以使用<code>kubectl create namespace</code>命令创建命名空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace &lt;命名空间&gt;</span><br></pre></td></tr></table></figure><p>命名空间只能包含字母, 数字, 横杠</p><h3 id="管理其他命名空间中的对象"><a href="#管理其他命名空间中的对象" class="headerlink" title="管理其他命名空间中的对象"></a>管理其他命名空间中的对象</h3><p>如果想在指定的命名空间中创建资源, 可以选择在<code>metedata</code>字段中添加一个<code>namespace: custom-namespace</code>属性, 也可以使用<code>kubectl create</code>命令创建资源时指定命名空间: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f 模版 -n &lt;命名空间&gt;</span><br></pre></td></tr></table></figure><p>在列出, 描述, 修改或删除其他命名空间中的对象时, 需要给<code>kubectl</code>命令传递<code>--namespace</code>(或<code>-n</code>)选项. 如果不指定命名空间, <code>kubectl</code>将在当前上下文中配置的默认命名空间中执行操作. </p><h3 id="命名空间提供的隔离"><a href="#命名空间提供的隔离" class="headerlink" title="命名空间提供的隔离"></a>命名空间提供的隔离</h3><p>尽管命名空间将对象分隔到不同组, 只允许你对属于特定命名空间的对象进行操作, 但实际上命名空间之间并不提供对正在运行的对象的任何隔离. </p><h2 id="停止和移除pod"><a href="#停止和移除pod" class="headerlink" title="停止和移除pod"></a>停止和移除<code>pod</code></h2><h3 id="按名称删除pod"><a href="#按名称删除pod" class="headerlink" title="按名称删除pod"></a>按名称删除<code>pod</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete po &lt;po的名称&gt; [&lt;pod名称&gt;...]</span><br></pre></td></tr></table></figure><p>在删除<code>pod</code>的过程中, 实际上我们在指示<code>Kubernetes</code>终止该<code>pod</code>中的所有容器. <code>Kubernetes</code>向进程发送一个<code>SIGTERM</code>信号并等待一定的秒数(默认为30), 使其正常关闭. 如果它没有及时关闭, 则通过<code>SIGKILL</code>终止该进程. 因此, 为了确保你的进程总是正常关闭, 进程需要正确处理<code>SIGTERM</code>信号. </p><h3 id="使用标签选择器删除pod"><a href="#使用标签选择器删除pod" class="headerlink" title="使用标签选择器删除pod"></a>使用标签选择器删除<code>pod</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete po -l &lt;label的名称&gt;=&lt;label的值&gt;</span><br></pre></td></tr></table></figure><h3 id="通过删除整个命名空间来删除pod"><a href="#通过删除整个命名空间来删除pod" class="headerlink" title="通过删除整个命名空间来删除pod"></a>通过删除整个命名空间来删除<code>pod</code></h3><p>可以通过删除整个命名空间来删除这个命名空间, 以及这个命名空间下的<code>pod</code>. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete ns &lt;命名空间&gt;</span><br></pre></td></tr></table></figure><h3 id="删除命名空间中所有pod-当保留命名空间"><a href="#删除命名空间中所有pod-当保留命名空间" class="headerlink" title="删除命名空间中所有pod, 当保留命名空间"></a>删除命名空间中所有<code>pod</code>, 当保留命名空间</h3><p>删除当前命名空间中的所有<code>pod</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete po --all</span><br></pre></td></tr></table></figure><h3 id="删除命名空间中的-几乎-所有资源"><a href="#删除命名空间中的-几乎-所有资源" class="headerlink" title="删除命名空间中的(几乎)所有资源"></a>删除命名空间中的(几乎)所有资源</h3><p>通过使用单个命令删除当前命名空间中的所有资源:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete all --all</span><br></pre></td></tr></table></figure><p>使用<code>all</code>关键字删除所有内容并不是真的删除所有内容. 一些资源会被保留下来, 并且需要被明确指定删除. </p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubernetes in Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始使用Kubernetes和Docker</title>
      <link href="/2023/09/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Kubernetes%E5%92%8CDocker/"/>
      <url>/2023/09/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Kubernetes%E5%92%8CDocker/</url>
      
        <content type="html"><![CDATA[<h1 id="开始使用Kubernetes和Docker"><a href="#开始使用Kubernetes和Docker" class="headerlink" title="开始使用Kubernetes和Docker"></a>开始使用<code>Kubernetes</code>和<code>Docker</code></h1><h2 id="在Kubernetes上运行第一个应用"><a href="#在Kubernetes上运行第一个应用" class="headerlink" title="在Kubernetes上运行第一个应用"></a>在<code>Kubernetes</code>上运行第一个应用</h2><h3 id="部署Node-js应用"><a href="#部署Node-js应用" class="headerlink" title="部署Node.js应用"></a>部署<code>Node.js</code>应用</h3><p>部署应用程序最简单的方式是使用<code>kubectl run</code>命令, 该命令可以创建所有必要的组件而无需<code>JSON</code>或<code>YAML</code>. </p><h4 id="介绍pod"><a href="#介绍pod" class="headerlink" title="介绍pod"></a>介绍<code>pod</code></h4><p>一个<code>pod</code>是一组紧密相关的容器, 它们总是运行在同一个工作节点上, 以及同一个<code>Linux</code>命名空间中. 每个<code>pod</code>就像一个独立的逻辑机器, 拥有自己的IP, 主机名, 进程等, 运行一个独立的应用程序. </p><h4 id="列出pod"><a href="#列出pod" class="headerlink" title="列出pod"></a>列出<code>pod</code></h4><p>不能列出单个容器, 因为它们不是独立的<code>Kubernetes</code>对象, 但是可以列出<code>pod</code>. 要查看有关<code>pod</code>的更多信息, 还可以使用<code>kubectl describe pod</code>命令. </p><h3 id="访问WEB应用"><a href="#访问WEB应用" class="headerlink" title="访问WEB应用"></a>访问<code>WEB</code>应用</h3><p>每个<code>pod</code>都有自己的IP地址, 但是这个地址是集群内部的, 不能从集群外部访问. 要让<code>pod</code>能够从外部访问, 需要通过服务对象公开它, 要创建一个特殊的<code>LoadBalancer</code>类型的服务. 因为如果你创景一个常规服务(一个<code>ClusterIP</code>服务), 比如<code>pod</code>, 它也只能从集群内部访问. 通过创建<code>LoaBalancer</code>类型的服务, 将创建一个外部的负载均衡, 通过负载均衡的公共IP访问<code>pod</code>. </p><h4 id="创建一个服务对象"><a href="#创建一个服务对象" class="headerlink" title="创建一个服务对象"></a>创建一个服务对象</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose &lt;需要暴露的pod类型&gt; &lt;需要暴露的pod名称&gt; --type=&lt;暴露的类型&gt; --name=&lt;暴露的名称&gt; </span><br></pre></td></tr></table></figure><h4 id="列出服务"><a href="#列出服务" class="headerlink" title="列出服务"></a>列出服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure><h3 id="系统的逻辑部分"><a href="#系统的逻辑部分" class="headerlink" title="系统的逻辑部分"></a>系统的逻辑部分</h3><p>一个服务被创建时, 它会得到一个静态的<code>IP</code>, 在服务的生命周期中这个IP不会发生改变. 客户端应该通过固定IP地址连接到服务, 而不是直接连接<code>pod</code>. </p><p>服务表示一组或多组提供相同服务的<code>pod</code>的静态地址. 到达服务<code>IP</code>和端口的请求将被转发到属于该服务的一个容器的<code>IP</code>和端口</p><h4 id="水平伸缩应用"><a href="#水平伸缩应用" class="headerlink" title="水平伸缩应用"></a>水平伸缩应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale &lt;需要暴露的pod类型&gt; &lt;需要暴露的pod名称&gt; --replicas=&lt;数量&gt;</span><br></pre></td></tr></table></figure><h4 id="列出pod时显示pod-IP和pod的节点"><a href="#列出pod时显示pod-IP和pod的节点" class="headerlink" title="列出pod时显示pod IP和pod的节点"></a>列出<code>pod</code>时显示<code>pod IP</code>和<code>pod</code>的节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubernetes in Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes介绍</title>
      <link href="/2023/09/18/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/Kubernetes%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/09/18/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/Kubernetes%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernete介绍"><a href="#Kubernete介绍" class="headerlink" title="Kubernete介绍"></a>Kubernete介绍</h1><p><code>Kubernetes</code>使开发者可以自主部署应用, 并且控制部署的频率, 完全脱离运维团队的版主. <code>Kubernetes</code>同时能够让运维团队监控整个系统, 并且在硬件故障时重新调度应用. 系统管理员的工作重心, 从监管应用转移到了监管<code>Kubernetes</code>, 以及剩余的系统资源, 因为<code>Kubernetes</code>会帮助监管所有的应用. </p><h2 id="Kubernetes系统的需求"><a href="#Kubernetes系统的需求" class="headerlink" title="Kubernetes系统的需求"></a><code>Kubernetes</code>系统的需求</h2><h3 id="从单体应用到微服务"><a href="#从单体应用到微服务" class="headerlink" title="从单体应用到微服务"></a>从单体应用到微服务</h3><p>单体应用由很多个组件构成, 这些组件紧密地耦合在一起, 由于它们在同一操作系统进程中运行, 所以在开发, 部署, 管理的时候必须以同一个实体运行. 对单体应用来说, 即使是某个组件中一个小的修改, 都需要重新部署整个应用. 组件间缺乏严格的边界定义, 相互依赖, 日积月累导致系统复杂度提升, 整体质量也急剧恶化. </p><h4 id="将应用拆解为多个微服务"><a href="#将应用拆解为多个微服务" class="headerlink" title="将应用拆解为多个微服务"></a>将应用拆解为多个微服务</h4><p>这个问题迫使我们将复杂的大体单体应用, 拆分为小的可独立部署的微服务组件. 每个微服务以独立的进程运行, 并通过简单且定义良好的接口<code>(API)</code>与其他的微服务通信. </p><p>因为每个微服务都是独立的进程, 提供相对静态的<code>API</code>, 所以独立开发和部署单个微服务成为了可能. 只要<code>API</code>不变或者向前兼容, 改动一个微服务, 并不会要求其他微服务进行改动或重新部署. </p><h4 id="微服务的扩容"><a href="#微服务的扩容" class="headerlink" title="微服务的扩容"></a>微服务的扩容</h4><p>面向单体系统, 扩容针对的是整个系统, 而面向微服务架构, 库容却只需要针对单个服务, 这意味着你可以选择扩容那些需要更多资源的服务而保持其他的服务仍然维持在原来的规模. </p><h4 id="部署微服务"><a href="#部署微服务" class="headerlink" title="部署微服务"></a>部署微服务</h4><p>像大多数情况一样, 微服务也有缺点. 部署微服务, 部署者需要正确地配置所有服务来使其作为一个单一系统能正确工作, 随着微服务的数量不断增加, 配置工作变得冗余且易错.</p><p>微服务还带来其他问题, 比如因为垮了多个进程和机器, 使得调试代码和定位异常调用变得困难. </p><h3 id="为应用程序提供一个一致的环境"><a href="#为应用程序提供一个一致的环境" class="headerlink" title="为应用程序提供一个一致的环境"></a>为应用程序提供一个一致的环境</h3><p>不管你同时开发和部署多少个独立组件, 开发和运维团队总是需要解决的一个最大的问题是程序运行环境的差异性. 为了减少会在生产环境才会暴露的问题, 最理想的做法是让应用在开发和生产可以运行在完全一样的环境下. </p><h3 id="迈向持续交付-DevOps和无运维"><a href="#迈向持续交付-DevOps和无运维" class="headerlink" title="迈向持续交付: DevOps和无运维"></a>迈向持续交付: <code>DevOps</code>和无运维</h3><p>让同一个团队参与应用的开发, 部署, 运维的整个生命周期更好. 这意味着开发, <code>QA</code>和运维团队彼此之间的合作需要贯穿整个流程. 这种实践称为<code>DevOps</code>. </p><p>理想情况是, 开发者自己部署程序本身, 不需要知道硬件基础设施的任何情况, 也不需要和运维团队交涉, 这被叫作<code>NoOps</code>. 很明显, 你仍然需要有一些人来关心硬件基础设施, 但这些人不需要再处理应用程序的独特性. </p><p>正如你所看到的, <code>Kubernetes</code>能让我们实现所有这些想法. 通过对实际硬件做抽象, 然后将自身暴露成一个平台, 用于部署和运行应用程序. 它允许开发者自己配置和部署应用程序, 而不需要系统管理员的任何帮助, 让系统管理员聚焦于保持底层基础设施运转正常的同时, 不需要关注实际运行在平台上的应用程序. </p><h2 id="介绍容器技术"><a href="#介绍容器技术" class="headerlink" title="介绍容器技术"></a>介绍容器技术</h2><p><code>Kubernetes</code>使用<code>Linux</code>容器技术来提供应用隔离. </p><h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><p>当一个应用程序仅由较少数量的大组件构成时, 完全可以接受给每个组件分配专用的虚拟机, 以及通过给每个组件提供自己的操作系统实例来隔离它们的环境. 当时当这些组件开始变小且数量开始增长时, 如果你不想浪费硬件资源, 又想持续压低硬件成本, 就不能给每个组件配置一个虚拟机了. </p><h4 id="用Linux容器技术隔离组件"><a href="#用Linux容器技术隔离组件" class="headerlink" title="用Linux容器技术隔离组件"></a>用Linux容器技术隔离组件</h4><p>开发者不是使用虚拟机来隔离每个微服务环境, 而是正在转向<code>Linux</code>容器技术. 容器允许你在同一台机器上运行多个服务, 不经是提供不同的环境给每个服务, 而且将它们互相隔离. 容器类似虚拟机, 但开销小很多. </p><p>一个容器里运行的进程实际上运行在宿主机的操作系统上, 就像所有其他进程一样(不像虚拟机, 进程是运行在不同的操作系统上的). 但在容器里的进程仍然是和其他进程隔离的. 对于容器内进程本身而言, 就好像是在机器和操作系统上运行的唯一一个进程. </p><h4 id="比较虚拟机和容器"><a href="#比较虚拟机和容器" class="headerlink" title="比较虚拟机和容器"></a>比较虚拟机和容器</h4><p>和虚拟机计较, 容器更加轻量级, 它允许在相同的硬件上运行更多数量的组件. 主要是因为每个虚拟机需要运行自己的一组系统进程, 这就产生了除组件进程消耗以外的额外计算资源损耗. 从另一方面说, 一个容器仅仅是运行在宿主机上被隔离的单个进程, 仅消耗应用容器消耗的资源, 不会有其他进程的开销. </p><p>虚拟机需要一个管理程序, 它将物理硬件资源分成较小部分的虚拟硬件资源, 从而被每个虚拟机里的操作系统使用. 运行在那些虚拟机里的应用程序会执行虚拟机操作系统的系统调用, 然后虚拟机内核会通过管理程序在宿主机上的物理CPU执行指令. </p><p>多个容器则会完全执行运行在宿主机上的同一个内核的系统调用, 此内核是唯一一个在宿主机操作系统上执行指令的内核. CPU也不需要做任何对虚拟机那样的虚拟化. </p><p>虚拟机的主要好处是它们提供完全隔离的环境, 因为每个虚拟机运行在它自己的<code>Linux</code>内核上, 而容器都是调用同一个内核, 这自然会有安全隐患. 如果你的硬件资源有限, 那当你有少量进程需要隔离的时候, 虚拟机就可以成为一个选项. 为了在同一台机器上运行大量被隔离的进程, 容器因它的低消耗而成为一个更好的选择. </p><h4 id="容器实现隔离机制介绍"><a href="#容器实现隔离机制介绍" class="headerlink" title="容器实现隔离机制介绍"></a>容器实现隔离机制介绍</h4><p>容器如何隔离进程的, 有两个机制可用: 第一个是<code>Linux</code>命名空间, 它使每个进程只能看到它自己的系统视图(文件, 进程, 网络接口, 主机名等); 第二个是<code>Linux</code>控制组(<code>cgroups</code>), 它限制了进程能使用的资源量(CPU, 内存, 网络带宽等). </p><h4 id="用Linux命名空间隔离进程"><a href="#用Linux命名空间隔离进程" class="headerlink" title="用Linux命名空间隔离进程"></a>用<code>Linux</code>命名空间隔离进程</h4><p>默认情况下, 每个<code>Linux</code>系统最初仅有一个命名空间. 所有系统资源(诸如文件系统, 用户ID, 网络接口等)属于这一个命名空间. 但是你能创建额外的命名空间, 以及在它们之间组织资源. 对于进程, 可以在其中一个命名空间中运行它. 进程将只能看到同一个命名空间下的资源. 当然, 会存在多种类型的多个命名空间, 所以一个进程不单单只属于某一个命名空间, 而属于每个类型的一个命名空间. </p><p>存在以下类型的命名空间:</p><ol><li><code>Mount(mnt)</code></li><li><code>Process(pid)</code></li><li><code>Network(net)</code></li><li><code>Inter-process communication(ipd)</code></li><li><code>UTS</code></li><li><code>User Id(user)</code></li></ol><p>每种命名空间被用来隔离一组特定的资源. </p><h4 id="限制进程的可用资源"><a href="#限制进程的可用资源" class="headerlink" title="限制进程的可用资源"></a>限制进程的可用资源</h4><p>另外的隔离性就是限制容器能使用的系统资源. 这通过<code>cgroups</code>来实现. <code>cgroups</code>是一个<code>Linux</code>内核功能, 它被用来限制一个进程或者一组进程的资源使用. 一个进程的资源(CPU, 内存, 网络带宽等)使用量不能超出被分配使用的量. 这种方式下, 进程不能过分使用为其他进程保留的资源, 这和进程运行在不同的机器上是类似的. </p><h3 id="Docker容器平台介绍"><a href="#Docker容器平台介绍" class="headerlink" title="Docker容器平台介绍"></a><code>Docker</code>容器平台介绍</h3><p><code>Docker</code>不仅简化了打包应用的流程, 也简化了打包应用的库和依赖, 甚至整个操作系统地文件都能被打包成一个简单的可移植的包, 这个包可以被用来在任何其他运行<code>Docker</code>的机器上使用. </p><h4 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a><code>Docker</code>的概念</h4><p><code>Docker</code>是一个打包, 分发和运行应用程序的平台. <code>Docker</code>中三个主要的概念.</p><ol><li>镜像: <code>Docker</code>镜像里包含了你打包的应用程序及其所依赖的环境. 它包含应用程序可用的文件系统和其他元数据, 如镜像运行时的可执行文件路径. </li><li>镜像仓库: <code>Docker</code>镜像仓库用于存放<code>Docker</code>镜像, 以及促进不同人和不同电脑之间共享这些镜像. </li><li>容器: <code>Docker</code>容器通常是一个<code>Linux</code>容器, 它基于<code>Dokcer</code>镜像被创建. 一个运行中的容器是一个运行在<code>Docker</code>主机的进程, 但它和主机, 以及所有运行在主机的其他进程都是隔离的. 这个进程也是资源受限的, 意味着它只能访问和使用分配给它的资源(CPU, 内存等).</li></ol><h4 id="镜像层"><a href="#镜像层" class="headerlink" title="镜像层"></a>镜像层</h4><p>层不仅使分发更高效, 也助于减少镜像的存储空间. 每一层被存一次, 当基于相同基础层的镜像被创建成两个容器时, 它们就能够读取相同的文件. 但是如果其中一个容器写入某些文件, 另外一个是无法看见文件变更的. 因此, 即使它们共享文件, 仍然彼此隔离. 这是因为容器镜像层是只读的. 容器运行时, 一个新的可写在镜像层之上被创建. 容器中进程写入位于底层的一个文件时, 此文件的一个拷贝在顶层被创建, 进程写的是此拷贝. </p><h4 id="容器镜像可移植性的限制"><a href="#容器镜像可移植性的限制" class="headerlink" title="容器镜像可移植性的限制"></a>容器镜像可移植性的限制</h4><p>理论上, 一个容器镜像能运行在任何一个运行<code>Docker</code>的机器上. 但是如果一个容器化的应用需要一个特定的内核版本, 那它可能不能在每台机器上都工作. 如果一台机器运行了一个不匹配的<code>Linux</code>内核版本, 或者没有相同内核模块可用,  那么此应用就不能在其上运行. </p><h2 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a><code>Kubernetes</code>介绍</h2><h3 id="深入浅出地了解Kubernetes"><a href="#深入浅出地了解Kubernetes" class="headerlink" title="深入浅出地了解Kubernetes"></a>深入浅出地了解<code>Kubernetes</code></h3><p><code>Kubernets</code>是一个软件系统, 它允许你在其上很容易地部署和管理容器化的应用. <code>Kubernetes</code>使你在数以千计的电脑节点上运行软件时就像所有节点是单个大节点一样. </p><h4 id="Kubenetes的核心功能"><a href="#Kubenetes的核心功能" class="headerlink" title="Kubenetes的核心功能"></a><code>Kubenetes</code>的核心功能</h4><p>整个系统由一个主节点和若干个工作节点组成. 开发者把一个应用列表提交到主节点, <code>Kubernetes</code>会将它们部署到集群的工作节点. </p><p>开发者能指定一些应用必须一起运行, <code>Kubernets</code>将会在一个工作节点上部署它们. 其他的将被分散部署到集群中, 但是不管部署在哪儿, 它们都能以相同的方式相互通信. </p><h3 id="Kubernetes集群架构"><a href="#Kubernetes集群架构" class="headerlink" title="Kubernetes集群架构"></a><code>Kubernetes</code>集群架构</h3><p>在硬件级别, 一个<code>Kubernetes</code>集群由很多节点组成, 这些节点被分成以下两种类型:</p><ol><li>主节点: 它承载着<code>Kubernetes</code>控制和管理整个集群系统地控制面板</li><li>工作节点: 它们运行用户实际部署的应用</li></ol><h4 id="控制面板"><a href="#控制面板" class="headerlink" title="控制面板"></a>控制面板</h4><p>控制面板用于控制集群并使它工作. 它包含多个组件, 组件可以运行在单个主节点或者通过副本分别部署在多个主节点以确保高可用性. 这些组件是:</p><ol><li><code>Kubernetes API</code>服务器, 你和其他控制面板组件都要和它通信.</li><li><code>Scheduler</code>, 它调度你的应用(为应用的每个部署组件分配一个工作节点).</li><li><code>Controller Mananger</code>, 它执行集群基本的工作, 如复制组件, 持续跟踪工作节点, 处理节点失败等. </li><li><code>etcd</code>, 一个可靠的分布式数据存储, 它能持久化存储集群配置.</li></ol><p>控制面板的组件持有并控制集群状态, 但是它们不运行你的应用程序. 这是由工作节点完成的. </p><h4 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h4><p>工作节点是运行容器化应用的机器. 运行, 监控和管理应用服务的任务是由以下组件完成的: </p><ol><li><code>Docker</code>, <code>rtk</code>或其他的容器类型</li><li><code>Kubelet</code>, 它与API服务器通信, 并管理它所在节点的容器</li><li><code>Kubernetes Service Proxy(kube-proxy)</code>, 它负责组件之间的负载均衡网络流量</li></ol><h3 id="在Kubernetes中运行应用"><a href="#在Kubernetes中运行应用" class="headerlink" title="在Kubernetes中运行应用"></a>在<code>Kubernetes</code>中运行应用</h3><h4 id="描述信息怎样成为一个运行的容器"><a href="#描述信息怎样成为一个运行的容器" class="headerlink" title="描述信息怎样成为一个运行的容器"></a>描述信息怎样成为一个运行的容器</h4><p>当<code>API</code>服务器处理应用描述时, 调度器选择可用的工作节点. 选择时基于所需要的计算资源, 以及调度时每个节点未分配的资源. 然后, 那些节点上的<code>Kubelet</code>指示容器运行时拉取所需要的镜像并运行容器. </p><h4 id="保持容器运行"><a href="#保持容器运行" class="headerlink" title="保持容器运行"></a>保持容器运行</h4><p>一旦应用程序运行起来, <code>Kubernetes</code>就会不断地确认应用程序的部署状态始终与你提供的描述相匹配. 如果实例之一停止了正常工作, 比如进程崩溃或停止响应时, <code>Kubernetes</code>将自动重启它. </p><p>同理, 如果整个工作节点死亡或无法访问, <code>Kubernetes</code>将为在故障节点上运行的所有容器选择新节点, 并在新选择地节点上运行它们. </p><h4 id="扩展副本数量"><a href="#扩展副本数量" class="headerlink" title="扩展副本数量"></a>扩展副本数量</h4><p>当应用程序运行时, 可以决定要增加或减少副本量, 而<code>Kubernetes</code>将分别增加附加的或停止多余的副本. 甚至可以把决定最佳副本数目的工作交给<code>Kubernetes</code>. 它可以根据实时指标(CPU负载, 内存消耗, 每秒查询或应用程序公开的任何其他指标)自动调整副本数. </p><h4 id="命中移动目标"><a href="#命中移动目标" class="headerlink" title="命中移动目标"></a>命中移动目标</h4><p><code>Kubernetes</code>可能需要在集群中迁移你的容器. 当它们运行的节点失败时, 或者为了给其他容器腾出地方而从节点移除时, 就会发生这种情况.</p><p>为了让客户能够轻松找到提供特定服务的容器, 可以告诉<code>Kubernetes</code>哪些容器提供相同的服务, 而<code>Kubernetes</code>将通过一个静态IP地址暴露所有容器, 并将该地址暴露给集群中运行的所有应用程序. 这是通过环境变量完成的, 但是客户端也可以通过良好的DNS查找服务器IP. 服务的IP地址保持不变, 因此客户端始终可以连接到它的容器, 即使它们在集群中移动. </p><h3 id="使用Kubernetes的好处"><a href="#使用Kubernetes的好处" class="headerlink" title="使用Kubernetes的好处"></a>使用<code>Kubernetes</code>的好处</h3><p>如果在所有服务器上都部署了<code>Kubernetes</code>, 那么运维团队就不需要在部署应用程序. </p><h4 id="简化应用程序部署"><a href="#简化应用程序部署" class="headerlink" title="简化应用程序部署"></a>简化应用程序部署</h4><p>由于<code>Kubernetes</code>将其所有工作节点作为一个部署平台, 因此应用程序开发人员可以开始自己开始部署应用程序, 不需要了解组成集群的服务器. </p><h4 id="健康检查和自修复"><a href="#健康检查和自修复" class="headerlink" title="健康检查和自修复"></a>健康检查和自修复</h4><p>当服务器发生故障时, 拥有一个允许在任何时候跨集群迁移应用程序的系统也很有价值. </p><p><code>Kubernetes</code>监控你的应用程序组件和它们运行的节点, 并在节点出现故障时自动将它们重新调度到其他节点. 这使运维团队不必手动迁移应用程序组件, 并允许团队立即专注与修复节点本身, 并将其修好送回到可用的硬件资源池中. </p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> kubernetes in Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes集群搭建与配置</title>
      <link href="/2023/09/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/09/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Kubernetes集群搭建和配置"><a href="#Kubernetes集群搭建和配置" class="headerlink" title="Kubernetes集群搭建和配置"></a><code>Kubernetes</code>集群搭建和配置</h1><h2 id="Kubernetes部署利器-kubeadm"><a href="#Kubernetes部署利器-kubeadm" class="headerlink" title="Kubernetes部署利器: kubeadm"></a><code>Kubernetes</code>部署利器: <code>kubeadm</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个Master节点</span></span><br><span class="line">kubeadm init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个Node节点加入当前集群</span></span><br><span class="line">kubeadm join &lt;Master节点的IP和端口&gt;</span><br></pre></td></tr></table></figure><h3 id="kubeadm的工作原理"><a href="#kubeadm的工作原理" class="headerlink" title="kubeadm的工作原理"></a><code>kubeadm</code>的工作原理</h3><p>在部署时, 它的每个组件都是一个需要被执行的, 单独的二进制文件. </p><h4 id="Kubernetes集群初始化"><a href="#Kubernetes集群初始化" class="headerlink" title="Kubernetes集群初始化"></a><code>Kubernetes</code>集群初始化</h4><p><code>Kubernetes</code>中有一种特殊的容器启动方法, 叫做<code>static pod</code>. 它允许你把要部署的<code>pod</code>的<code>YAML</code>文件放在一个指定的目录中. 这样, 当这台机器上的<code>kubelet</code>启动时, 它会自动检查该目录, 加载所有的<code>Pod YAML</code>文件并在这台机器上启动它们. </p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubernetes </tag>
            
            <tag> 深入剖析Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goroutines和Channels</title>
      <link href="/2023/09/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/Goroutines%E5%92%8CChannels/"/>
      <url>/2023/09/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/Goroutines%E5%92%8CChannels/</url>
      
        <content type="html"><![CDATA[<h1 id="Goroutines和Channels"><a href="#Goroutines和Channels" class="headerlink" title="Goroutines和Channels"></a><code>Goroutines</code>和<code>Channels</code></h1><p><code>Go</code>语言中的并发程序可以用两种手段来实现. <code>goroutine</code>和<code>channel</code>, 其支持”顺序通信进程”<code>(CSP)</code>. <code>CSP</code>是一种现代的并发编程模型, 在这种编程模型中值会在不同的运行实例<code>goroutine</code>中传递, 尽管大多数情况下仍然是被限制在单一实例中. </p><h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a><code>Goroutines</code></h2><p>在<code>Go</code>语言中, 每一个并发的执行单元叫作一个<code>goroutine</code>. 当一个程序启动时, 其主函数即在一个单独的<code>goroutine</code>中运行, 我们叫它<code>main goroutine</code>. 新的<code>gorountine</code>会用<code>go</code>语句来创建. 在语法上, <code>go</code>语句是一个普通的函数或方法调用前加上关键字<code>go</code>. <code>go</code>语句会使其语句中的函数在一个新创建的<code>goroutine</code>中运行. 而<code>go</code>语句本身会迅速地完成. </p><p>主函数返回时, 所有的<code>goroutine</code>都会被直接打断, 程序退出. 除了从主函数退出或者直接终止程序之外, 没有其它的编程方法能够让一个<code>goroutine</code>来打断另一个执行, 但是之后可以看到一种方式来实现这个目的, 通过<code>goroutine</code>之间的通信来让一个<code>goroutine</code>请求其它的<code>goroutine</code>, 让被请求的<code>goroutine</code>自行结束执行. </p><h2 id="示例-并发的Clock服务"><a href="#示例-并发的Clock服务" class="headerlink" title="示例: 并发的Clock服务"></a>示例: 并发的<code>Clock</code>服务</h2><p><code>time.Time.Format</code>将时间格式化. <code>time.Parse</code>将字符串转化为时间. </p><h2 id="示例-并发的Echo服务"><a href="#示例-并发的Echo服务" class="headerlink" title="示例: 并发的Echo服务"></a>示例: 并发的<code>Echo</code>服务</h2><p>函数值在循环体中才会出现捕获迭代变量的情况. </p><h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a><code>Channels</code></h2><p>如果说<code>goroutine</code>是<code>Go</code>语言程序的并发体的话, 那么<code>channels</code>是它们之间的通信机制. 一个<code>channels</code>是一个通信机制, 它可以让一个<code>goroutine</code>通过它给另一个<code>goroutine</code>发送值信息. 每个<code>channel</code>都有一个特殊的类型, 也就是<code>channels</code>可以发送的数据类型. 一个可以发送<code>int</code>类型数据的<code>channel</code>一般写作<code>chan int</code>.</p><p>使用内置的<code>make</code>函数, 我们可以创建一个<code>channel</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>和<code>map</code>类似, <code>channel</code>也是一个对应<code>make</code>创建的底层数据结构的引用. 当我们复制一个<code>channel</code>或用于函数传递参数时, 我们只是拷贝了一个<code>channel</code>引用, 因此调用者和被调用者讲引用同一个<code>channel</code>对象. 和其他的引用类型一样, <code>channel</code>的零值也是<code>nil</code>. </p><p>两个相同类型的<code>channel</code>可以使用<code>==</code>运算符比较. 如果两个<code>channel</code>引用的是相通的对象, 那么比较的结果为真. 一个<code>channel</code>也可以和<code>nil</code>进行比较. </p><p><code>channel</code>支持<code>close</code>操作, 用于关闭<code>channel</code>, 随后对与基于该<code>channel</code>的任何发送操作都将都导致<code>panic</code>异常. </p><h3 id="不带缓存的Channels"><a href="#不带缓存的Channels" class="headerlink" title="不带缓存的Channels"></a>不带缓存的<code>Channels</code></h3><p>一个基于无缓存<code>channel</code>的发送操作将导致发送者<code>goroutine</code>阻塞, 直到另一个<code>goroutine</code>在相同的<code>channel</code>上执行接收操作, 当发送的值通过<code>channel</code>成功传输之后, 两个<code>goroutine</code>可以继续执行后面的语句. 反之, 如果接收操作先发生, 那么接收者<code>goroutine</code>也将阻塞, 直到有另一个<code>goroutine</code>在相同的<code>channel</code>上执行发送操作. </p><h3 id="串联的channels-pipeline"><a href="#串联的channels-pipeline" class="headerlink" title="串联的channels(pipeline)"></a>串联的<code>channels(pipeline)</code></h3><p><code>channel</code>也可以用于将多个<code>goroutine</code>链接在一起, 一个<code>channel</code>的输出作为下一个<code>channel</code>输入. 这种串联的<code>channel</code>就是所谓的管道<code>pipeline</code>. </p><p>当一个<code>channel</code>被关闭后, 再向该<code>channel</code>发送数据将导致<code>panic</code>异常. 当一个被关闭的<code>channel</code>中已经发送的数据都被成功接收后, 后续的接收操作将不再阻塞, 它们会立即返回一个零值. </p><p>没有办法直接测试一个<code>channel</code>是否被关闭, 但是接收操作有一个变体形式: 它多接收一个结果, 多接收的第二个结果是一个布尔值, <code>true</code>表示成功从<code>channel</code>接收到值, <code>false</code>表示<code>channel</code>已经被关闭并且里面没有值可被接收. </p><p><code>Go</code>语言的<code>range</code>循环可直接在<code>channel</code>上迭代, 它依次从<code>channel</code>接收数据, 当<code>channel</code>被关闭并且没有值可被接收时跳出循环. </p><p>并不需要关闭每一个<code>channel</code>. 不管一个<code>channel</code>是否被关闭, 当它没有被引用时会被<code>Go</code>语言的垃圾自动回收器回收. </p><p>试图重复关闭一个<code>channel</code>将导致<code>panic</code>异常, 试图关闭一个<code>nil</code>的<code>channel</code>也将导致<code>panic</code>异常. 关闭<code>channel</code>还会触发一个广播机制. </p><h3 id="单方向的channel"><a href="#单方向的channel" class="headerlink" title="单方向的channel"></a>单方向的<code>channel</code></h3><p>当一个<code>channel</code>作为函数参数时, 它一般总是被专门用于只发送或者只接收. </p><p>为了表示这种意图并防止被滥用, <code>Go</code>语言的类型系统提供了单方向的<code>channel</code>类型, 分别用于只发送或只接收的<code>channel</code>. 类型<code>chan&lt;- int</code>表示一个只发送<code>int</code>的<code>channel</code>, 只能发送不能接收. 相反, 类型<code>&lt;-chan int</code>表示一个只接收<code>int</code>的<code>channel</code>, 只能接收不能发送. 这种限制将在编译期检测. </p><p>因为<code>close</code>操作说明了通道上没有数据再发送, 仅仅在发送方<code>goroutine</code>上才能调用它, 所以试图关闭一个仅能接收的<code>channel</code>在编译时会报错. </p><p>任何双向<code>channel</code>向单向<code>channel</code>变量的赋值操作都将导致隐式转换. 这里没有反向转换的语法, 也就是不能将单向<code>channel</code>转换为双向<code>channel</code>. </p><h3 id="带缓存的channel"><a href="#带缓存的channel" class="headerlink" title="带缓存的channel"></a>带缓存的<code>channel</code></h3><p>带缓存的<code>channel</code>内部持有一个元素队列. 队列的最大容量是在调用<code>make</code>函数创建<code>channel</code>时通过第二个参数指定的. </p><p>向缓存<code>channel</code>的发送操作就是向内部缓存队列的尾部插入元素, 接收操作则是从队列的头部删除元素. 如果内部缓存队列是满的, 那么发送操作将阻塞直到因另一个<code>goroutine</code>执行接收从而释放了新的队列空间. 相反, 如果<code>channel</code>是空的, 接收操作将阻塞直到有另一个<code>goroutine</code>执行发送操作而向队列插入元素. </p><p>在某些特殊情况下, 程序可能需要知道<code>channel</code>内部缓存的容量, 可以用内置的<code>cap</code>函数获取. </p><p>同样, 对于内置的<code>len</code>函数, 如果传入的是<code>channel</code>, 那么将返回<code>channel</code>内部缓存队列中有效元素的个数. </p><p><code>goroutine</code>可能因为<code>channel</code>无法接收可卡住, 导致<code>goroutine</code>泄露. 泄漏的<code>goroutine</code>并不会被自动回收, 因此确保每个不再需要的<code>goroutine</code>能正常退出是重要的. </p><h2 id="并发的循环"><a href="#并发的循环" class="headerlink" title="并发的循环"></a>并发的循环</h2><p>每个子问题都是完全彼此独立的问题叫做易并行问题. 易并行问题是最容易被实现成并行的一类问题, 并且是最能够享受并发带来的好处, 能够随着并行的规模线性地扩展. </p><p>为了知道最后一个<code>goroutine</code>什么时候结束, 我们需要一个递增的计数器, 在每一个<code>goroutine</code>启动时加一, 在<code>goroutine</code>退出时减一. 这需要一种特殊的计数器, 这个计数器需要多个<code>goroutine</code>操作时做到安全并且提供在其减为零之前一直等待的一种方法. 这种计数类型被称为<code>sync.WaitGroup</code>. </p><h2 id="实例-并发的Web爬虫"><a href="#实例-并发的Web爬虫" class="headerlink" title="实例: 并发的Web爬虫"></a>实例: 并发的<code>Web</code>爬虫</h2><p>注意<code>channel</code>可能造成死锁. </p><p>限制<code>goroutine</code>数量的方法. 使用缓存队列. </p><p>终止程序的方法. </p><p>限制<code>goroutine</code>数量的方法. 保持长活<code>goroutine</code>. </p><h2 id="基于select的多路复用"><a href="#基于select的多路复用" class="headerlink" title="基于select的多路复用"></a>基于<code>select</code>的多路复用</h2><p><code>time.Tick</code>函数返回一个<code>channel</code>, 程序会周期性的像一个节拍器一样向这个<code>channel</code>发送事件. 每一个事件的值是一个时间搓. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ch1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;- ch2:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code>会等待<code>case</code>中有能够执行的<code>case</code>时去执行. 当条件满足时, <code>select</code>才会去通信并执行<code>case</code>之后的语句; 这时候其它通信是不会执行的. 一个没有任何<code>case</code>的<code>select</code>语句写作<code>select&#123;&#125;</code>, 会永远地等待下去. </p><p><code>time.After</code>函数会立即返回一个<code>channel</code>, 并起一个新的<code>goroutine</code>在经过特定的时间后向该<code>channel</code>发送一个独立的值. </p><p>如果多个<code>case</code>同时就绪, <code>select</code>会随机地选择一个执行, 这样保证每一个<code>channel</code>都有平等的被<code>select</code>的机会. </p><p><code>Tick</code>函数挺方便, 但是只有当程序整个生命周期都需要这个时间时我们使用它才比较合适. 否则应该使用, 下面这种模式. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">&lt;-ticker.C</span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure><p>有时候我们希望能够从<code>channel</code>中发送或者接收值, 并避免因为发送或者接收导致的阻塞, 尤其是当<code>channel</code>没有准备好写或者读时. <code>select</code>语句就可以实现这样的功能. <code>select</code>会有一个<code>default</code>来设置当其它的操作都不能够被马上处理时程序需要执行哪些逻辑. </p><p>因为对一个<code>nil</code>的<code>channel</code>发送和接收操作会被永远阻塞, 在<code>select</code>语句中操作<code>nil</code>的<code>channel</code>永远都不会被<code>select</code>到. </p><p>这使得我们可以使用<code>nil</code>来激活或者禁用<code>case</code>, 来达成处理其它输入或输出事件时超时和取消的逻辑. </p><h2 id="示例-并发的字典遍历"><a href="#示例-并发的字典遍历" class="headerlink" title="示例: 并发的字典遍历"></a>示例: 并发的字典遍历</h2><p><code>nil</code>的<code>channel</code>可以和<code>select</code>配合来达到关闭<code>case</code>的效果. </p><h2 id="并发的退出"><a href="#并发的退出" class="headerlink" title="并发的退出"></a>并发的退出</h2><p><code>Go</code>语言并没有提供一个<code>goroutine</code>中终止另一个<code>goroutine</code>的方法, 由于这样会导致<code>goroutine</code>之间的共享变量落在未定义的状态上. </p><p>可以创建一个退出<code>channel</code>, 只用退出来, 作为一个广播. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelled</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例-聊天服务"><a href="#实例-聊天服务" class="headerlink" title="实例: 聊天服务"></a>实例: 聊天服务</h2><p>学习<code>broadcaster</code>中的<code>select</code>用法.</p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获得文件的属性</span></span><br><span class="line">os.Stat()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获得目录下的所有文件</span></span><br><span class="line">ioutil.ReadDir()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取命令行参数</span></span><br><span class="line">flag.Args()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go程序设计语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2023/09/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/09/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>在<code>Go</code>语言中接口类型的独特之处在于它是满足隐式实现的. 也就是说, 我们没有必要对于给定的具体类型定义所有满足的接口类型; 简单地拥有一些必需的方法就足够了. 这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义; 当我们使用的类型来自于不受我们控制的包时这种设计尤其有用. </p><h2 id="接口约定"><a href="#接口约定" class="headerlink" title="接口约定"></a>接口约定</h2><p>接口类型是一种抽象的类型. 它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合; 它们只会展示出它们自己的方法. 也就是说当你看到一个接口类型的值时, 你不知道它时什么, 唯一知道的就是可以通过它的方法来做些什么. </p><p>一个类型可以自由的使用另一个满足相同接口的类型来进行替换被称作可替换性(LSP里氏替换). </p><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>接口类型具体描述了一系列方法的集合, 一个实现了这些方法的具体类型是这个接口类型的实例. </p><p>新的接口类型可以通过组合已有的接口来定义. </p><h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><p>一个类型如果拥有一个接口需要的所有方法, 那么这个类型就实现了这个接口. </p><p><code>interface&#123;&#125;</code>被称为空接口类型. 因为空接口类型对实现它的类型没有要求, 所以我们可以将任意一个值赋给空接口类型. </p><p>判断是否实现了接口只需要比较具体类型和接口类型的方法, 所以没有必要在具体类型的定义中声明这种关系. </p><p>非空的接口类型比如<code>io.Writer</code>经常被指针类型实现, 尤其当一个或多个接口方法像<code>Write</code>方法那样隐式地给接受者带来变化的时候. 一个结构体的指针是非常常见的承载方法的类型. </p><h2 id="flag-Value接口"><a href="#flag-Value接口" class="headerlink" title="flag.Value接口"></a><code>flag.Value</code>接口</h2><p>调用<code>flag.CommandLine.Var</code>方法把标记加入到应用的命令行标记集合中. </p><h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p>概念上讲一个接口的值, 接口值, 由两个部分组成, 一个具体的类型和那个类型的值. 通常被称为接口的动态类型和动态值. 对于像<code>Go</code>语言这种静态类型的语言, 类型是编译期的概念: 因此一个类型不是一个值. 在我们的概念中, 用类型描述符提供每个类型的具体信息, 比如它的名字和方法. 对于一个接口值, 类型部分就用对应的类型描述符来表述. </p><p>在<code>Go</code>语言中, 变量总是被一个定义明确的值初始化, 即使接口类型也不例外. 对于一个接口的零值就是它的类型和值的部分都是<code>nil</code>. </p><p>一个接口值基于它的动态类型被描述为空或非空. 可以通过<code>==nil</code>或<code>!=nil</code>来判断接口值是是否为空. 调用一个空接口值上的任意方法都会产生<code>panic</code>. </p><p>一般来讲, 在编译时我们无法知道一个接口值的动态类型会是什么, 所以通过接口来做调用必须需要使用动态分发. 编译器必须生成一段代码来从类型描述符拿到名为<code>write</code>的方法地址, 在间接调用该方法地址. 调用的接收者就是接口的动态值. </p><p>接口值可以用<code>==</code>和<code>!=</code>操作符来做比较. 如果两个接口值都是<code>nil</code>或者二者的动态类型完全一致且二者动态值相等(使用动态类型的<code>==</code>操作符来比较), 那么两个接口值相等. 应为接口值是可以比较的, 所以它们可以作为<code>map</code>的键, 也可以作为<code>switch</code>语句的操作数. </p><p>然而, 如果两个接口值的动态类型相同, 但是这个动态类型时不可比较的(比如切片), 将它们进行比较就是失败且<code>panic</code>. </p><p>考虑到这点, 接口类型时非常与众不同的. 其它类型那么是安全地可比较类型(如基本类型和指针)要么是完全不可比较的类型(如切片, 映射类型, 和函数), 但是在比较接口值或者包含了接口值的聚合类型时, 我们必须要意识到潜在的<code>panic</code>. 同样的风险也存在与使用接口作为<code>map</code>的键或者<code>switch</code>的操作数. 只能比较你非常确定的动态值是可比较类型的接口值. </p><h3 id="警告-一个包含nil指针的接口不是nil接口"><a href="#警告-一个包含nil指针的接口不是nil接口" class="headerlink" title="警告: 一个包含nil指针的接口不是nil接口"></a>警告: 一个包含<code>nil</code>指针的接口不是<code>nil</code>接口</h3><p>空的接口值(其中不包含任何信息)与仅仅动态值为<code>nil</code>的接口值是不一样的. </p><h2 id="sort-Interface接口"><a href="#sort-Interface接口" class="headerlink" title="sort.Interface接口"></a><code>sort.Interface</code>接口</h2><p>需要实现<code>sort.Interface</code>接口, 然后使用<code>sort.Sort</code>进行排序, 检查是否有序<code>sort.IsSorted</code>. </p><h2 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a><code>http.Handler</code>接口</h2><p>了解<code>ServerMux</code>. </p><h2 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a><code>error</code>接口</h2><p><code>error</code>类型就是一个<code>interface</code>类型, 这个类型有一个返回错误信息的单一方法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言是一个使用在接口值上的操作. 语法它看起来像<code>x.(T)</code>, 其中<code>x</code>是一个接口类型的表达式, 而<code>T</code>是一个类型(称为断言类型). 一个类型断言检查它操作对象的动态类型是否和断言的类型匹配. </p><p>这里有两种情况. 第一种, 如果断言的类型<code>T</code>是一个具体的类型, 然后断言类型检查<code>x</code>的动态类型是否和<code>T</code>相同. 如果检查成功了, 这个断言的结果是<code>x</code>的动态值, 当然的类型是<code>T</code>. 如果检查失败, 这个检查失败, 将会抛出<code>panic</code>. </p><p>第二种情况, 如果断言的类型<code>T</code>是一个接口类型, 然后断言检查是否<code>x</code>的动态类型满足<code>T</code>. 如果检查成功, 这个结果是一个有相同类型和值部分的接口值, 但是结果类型为<code>T</code>. </p><p>如果断言操作的对象是一个<code>nil</code>接口值, 那么不论被断言的类型是什么类型断言都会失败. 我们几乎不需要对一个更少限制的接口类型做断言, 因为它表现得就像赋值操作一样, 除了对于<code>nil</code>接口值的情况. </p><p>如果类型断言出现在一个预期有两个结果的赋值操作中, 这个操作不会在失败的时候发生<code>panic</code>, 但是用第二个布尔值来表示转换成功或失败. 失败时, 第一个值是被断言类型的零值. </p><h2 id="基于类型断言区别错误类型"><a href="#基于类型断言区别错误类型" class="headerlink" title="基于类型断言区别错误类型"></a>基于类型断言区别错误类型</h2><p>通过检查错误消息是否含有特定的子字符串从而来区分错误的类型是非常不成熟的. 一个更可靠的方式是使用一个专门的类型来描述结构化的错误. </p><h2 id="类型开关"><a href="#类型开关" class="headerlink" title="类型开关"></a>类型开关</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从输入s中解析出一个变量.</span> </span><br><span class="line">fmt.Sscanf()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符串排序</span></span><br><span class="line">sort.Strings()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go程序设计语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法</title>
      <link href="/2023/09/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E6%96%B9%E6%B3%95/"/>
      <url>/2023/09/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>尽管没有被大众所接受的明确的<code>OOP</code>的定义, 从我们的理解来讲, 一个对象其实也就是一个简单的值或者一个变量, 这个对象中会包含一些方法, 而一个方法则是一个一个和特殊类型关联的函数. 一个面向对象的程序会使用方法来表达其属性和对应的操作, 这样使用这个对象的用户就不需要直接去操作对象, 而是借助方法来做这些事情. </p><h2 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h2><p>在函数声明时, 在其名字之前放上一个变量, 即是一个方法. 这个附加的参数会将该函数附加到这种类型上, 即相当于为这种类型定义了一个独占的方法. </p><p>函数名字前的变量称为方法的接受器, 早期的面向对象语言留下的遗产将调用一个方法称为”向一个对像发送消息”. </p><p>在<code>Go</code>语言中, 我们并不会像其它语言那样用<code>this</code>或者<code>self</code>作为接收器; 我们可以任意选择接收器的名字. 由于接受器的名字会经常被使用到, 所以保持其在方法间传递时的一致性或简短性是不错的注意. 这里的建议是可以使用其类型的第一个字母的小写. </p><p>方法可以被声明到任意类型, 只要不是一个指针类型或者<code>interface</code>. </p><h2 id="基于指针对象的方法"><a href="#基于指针对象的方法" class="headerlink" title="基于指针对象的方法"></a>基于指针对象的方法</h2><p>当接收器变量本身比较大或我们希望更新接受器对象, 我们可以用其指针而不是对象来声明方法. </p><p>在声明方法时, 如果一个类型名本身是一个指针的话, 是不允许其出现在接收器中的. </p><p>不管你的<code>method</code>的<code>receiver</code>是指针类型还是非指针类型, 都是可以通过指针&#x2F;非指针类型进行调用的, 编译器会帮你做类型转换. </p><p>在声明一个<code>method</code>的<code>receiver</code>该是指针还是非指针类型时, 你需要考虑两方面的内部, 第一方面是这个对象本身是不是特别大, 如果声明为非指针变量时, 调用会产生一次拷贝; 第二方面是如果你用指针类型作为<code>receiver</code>, 那么你一定要注意, 这种指针类型指向的始终是一个块内存地址. </p><h3 id="Nil也是一个合法接收器类型"><a href="#Nil也是一个合法接收器类型" class="headerlink" title="Nil也是一个合法接收器类型"></a><code>Nil</code>也是一个合法接收器类型</h3><p>就像一些函数允许<code>nil</code>指针作为参数一样, 方法理论上也可以用<code>nil</code>作为其接收器, 尤其当<code>nil</code>对于对象来说是合法的零值, 比如<code>map</code>或者<code>slice</code>. </p><p>当你定义一个允许<code>nil</code>作为接收器值的方法的类型时, 在类型前面的注释中指出<code>nil</code>变量代表的意义是很有必要的. </p><h2 id="通过嵌入结构体来扩展类型"><a href="#通过嵌入结构体来扩展类型" class="headerlink" title="通过嵌入结构体来扩展类型"></a>通过嵌入结构体来扩展类型</h2><p>嵌套类型, 不是<code>is a</code>关系, 而是<code>has a</code>关系, 内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法. </p><p>在类型中内嵌的匿名字段也可能是一个命名类型的指针, 这种情况下字段和方法会被间接地引入到当前的类型(访问需要通过该指针指向的对象去取). 添加这一层间接关系让我们可以共享通用的结构并动态地改变对象间的关系. </p><p>方法只能在命名类型或指向类型的指针上定义, 但是多亏了内嵌, 有些时候我们给匿名<code>struct</code>类型来定义方法也有了手段. </p><h2 id="方法值和方法表达式"><a href="#方法值和方法表达式" class="headerlink" title="方法值和方法表达式"></a>方法值和方法表达式</h2><p>我们经常选择一个方法, 并且在同一个表达式里执行, 比如常见的<code>p.Distance()</code>形式, 实际上将其分成两步来执行也是可能的. <code>p.Distance</code>叫作”选择器”, 选择器会返回一个方法”值”, 一个将方法<code>Point.Distance</code>绑定到特定接收器变量的函数. 这个函数可以不通过指定其接收器即可被调用; 即调用时不需要指定接收器, 只要传入函数的参数即可. </p><p>在一个包的<code>API</code>需要一个函数值, 且调用方希望操作的是某一个绑定了对象的方法的化, 方法”值”会非常实用. </p><p>当<code>T</code>是一个类型时, 方法表达式可能会写作<code>T.f</code>或者<code>(*T).f</code>, 会返回一个函数”值”, 这种函数会将其第一个参数用作接收器, 所以可以用不写选择器的方式来进行调用. </p><h2 id="实例-BIT数组"><a href="#实例-BIT数组" class="headerlink" title="实例: BIT数组"></a>实例: <code>BIT</code>数组</h2><p><code>Go</code>语言里的集合一般会用<code>map[T]bool</code>这种形式来表示, <code>T</code>代表元素类型. </p><p>一个<code>bit</code>数组通常会用一个无符号数或者称之为”字”的<code>slice</code>来表示, 每个元素的每一位都表示集合里的一个值. 当集合的第<code>i</code>位被设置时, 我们才说这个集合包含元素<code>i</code>. </p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>一个对象的变量或者方法如果对调用方是不可见的话, 一般就定义为”封装”. 封装有时候也叫作信息隐藏, 同时也是面向对象编程最关键的一个方面. </p><p><code>Go</code>语言只有一种控制可见性的手段: 大写手写字母的标识符会从定义它们的包中被导出, 小写字母的则不会. 这种限制包内成员的方式同样适用于<code>struct</code>或者一个类型的方法. 因而如果我们想要封装一个对象, 我们必须将其定义为一个<code>struct</code>. </p><p>这种基于名字的手段使得语言中最小的封装单元是<code>package</code>, 而不是像其它语言一样的类型. 一个<code>struct</code>类型的字段对同一个包的所有代码都有可见性, 无论你的代码是写在一个函数还是一个方法里. </p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go程序设计语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数</title>
      <link href="/2023/08/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/"/>
      <url>/2023/08/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>每个函数声明都包含一个名字, 一个形参列表, 要给可选的返回列表以及函数体:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func name(parameter-list) (result-list) &#123;</span><br><span class="line">body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值也可以像形参一样命名. 这个时候, 每个命名的返回值会声明为一个局部变量, 并根据变量类型初始化为相应的0值. </p><p>函数的类型称作函数签名. 当两个函数拥有相同的形参列表和返回列表时, 认为这两个函数的类型或签名是相同的. </p><p>每一次调用函数都需要提供实参来对应函数的每一个形参. <code>Go</code>语言没有默认参数值的概念, 也没有任何方法可以通过参数名指定形参. </p><p>实参是按值传递的, 所以函数接收到的是每个实参的副本; 修改函数的形参变量并不会影响到抵用者提供的实参. 然后就, 如果提供的实参包含引用类型, 比如指针, <code>slice</code>, <code>map</code>, 函数或者通道, 那么当函数使用形参变量时就有可能会间接修改实参变量. </p><p>如果函数声明没有函数体, 那说明这个函数使用了除<code>Go</code>以外的语言实现. </p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>许多编程语言使用固定长度的函数调用栈; 大小在<code>64KB</code>到<code>2MB</code>之间. 递归的深度会受限于固定长度的栈大小, 所以但进行深度递归调用时必须谨慎防栈溢出. 固定长度的栈甚至会造成一定的安全隐患. 相比固定长的栈, <code>Go</code>语言的实现是使用了可变长度的栈, 栈的大小会随着使用而增长, 可达到<code>1GB</code>左右的上限. </p><h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><p><code>Go</code>语言的垃圾回收机制将回收未使用的内存, 但不能指望它会释放未使用的操作系统资源, 比如打开的文件以及网络连接. 必须显式地关闭它们. </p><p>返回一个多值结果可以是调用另一个多字返回的函数. </p><p>一个多值调用可以作为单独的实参传递给拥有多个形参的函数中. </p><p>良好的名称可以使得返回值更加有意义. 尤其在一个函数返回多个结果且类型相同时. </p><p>一个函数如果有命名的返回值, 可以省略<code>return</code>语句的操作数, 这称为裸返回. 因为能直观看出返回值, 应该保守使用裸返回. </p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>如果当函数函数调用发生错误时返回一个附加的结果作为错误值, 习惯上将错误值作为最后一个结果返回. 如果错误只有一种情况, 结果通常设置为布尔类型. 更多时候, 尤其对于<code>I/O</code>操作, 错误的原因可能多种多样, 而调用者则需要一些详细的信息. 在这种情况下, 错误的结果类型往往是<code>error</code>. </p><p><code>error</code>是内置的接口类型. 非空的错误类型有一个错误消息字符串, 可以通过调用它的<code>Error</code>方法或者通过调用<code>fmt.Println(err)</code>或<code>fmt.Print(&quot;%v&quot;, err)</code>直接输出错误消息. </p><p>在<code>Go</code>中, 函数运行失败时会返回错误信息, 这些错误信息被认为时一种预期的值而非异常, 这使得<code>Go</code>有区别于那些将函数运行失败看作异常的语言. 虽然<code>Go</code>有各种异常机制, 但这些机制仅被使用在处理那些未被预料到的错误, 即bug, 而不是那些键壮程序中应该被避免的程序错误. </p><h3 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h3><p>当一个函数调用返回一个错误时, 调用者应负责检查错误并采取合适的处理应对. </p><p>首先也还是最常见的情形是将错误传递下去, 使得子例程中发生的错误变为主调例程的错误. 我们为原始错误消息不断添加额外的上下文信息来建立一个可读的错误描述. 当错误最终被程序的<code>main</code>函数处理时, 它应该能够提供一个根本问题到总体故障的清晰因果链. </p><p>因为错误消息频繁地串联起来, 所以消息字符串首字母不应该大写, 而且应该避免换行.</p><p>一般而言, 被调用函数<code>f(x)</code>会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者, 调用者需要添加一些错误信息中不包含的信息. </p><p>第二种错误处理策略. 对于不固定或者不可预测的错误, 在短暂的间隔后对操作进行重试是合乎情理的, 超出一定的重试次数和限定的时间后在报错退出. </p><p>第三, 如果依旧不能顺利进行下去, 调用者能够输出错误然后优雅地停止程序, 但一般这样的处理应该留给主程序部分. 通常库函数应当将错误传递给调用者, 除非这个错误表示一个内部一致性错误, 这意味着库内部存在<code>bug</code>. </p><p>一个更方便的方法是通过调用<code>log.Fatalf</code>实现相同的效果. 就和所有日志函数一样, 它默认会将时间和日期作为前缀添加到错误消息前. </p><p>第四, 在一些错误情况下, 只记录下错误信息然后程序继续运行. 可以使用<code>log.Printf</code>或者直接输出到标准错误流.  <code>log</code>包中所有函数会为没有换行符的字符串增加换行符. </p><p>第五, 在某些罕见的情况下我们可以直接安全地忽略掉整个错误. 要习惯考虑到每个函数调用可能发生的出错情况, 当你有意地忽略一个错误的时候, 清晰地注释一下你的意图. </p><p>如果某个错误会导致函数返回, 那么成功的逻辑代码不应该放在<code>else</code>语句中, 而应直接放在函数体中. </p><h3 id="文件结尾错误-EOF"><a href="#文件结尾错误-EOF" class="headerlink" title="文件结尾错误(EOF)"></a>文件结尾错误<code>(EOF)</code></h3><p><code>Io</code>包保证任何由文件结束引起的读取失败都返回同一个错误<code>(io.EOF)</code>. </p><h2 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h2><p>在<code>Go</code>中, 函数被看作第一类值: 函数像其他值一样, 拥有类型, 可以被赋值给其他变量, 传递给其他变量, 传递给函数, 从函数返回. 对函数值的调用类似函数调用. </p><p>函数类型的零值是<code>nil</code>, 调用一个空的函数变量将导致<code>panic</code>错误. 函数变量可以和<code>nil</code>比较, 但它们本省不可比较, 所以不可以相互进行比较或者作为键值出现在<code>map</code>中. </p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>命名函数只能在包级别的作用域进行声明, 但我们能够使用函数字面量在任何表达式内指定函数变量. 函数字面量就像函数声明, 但在<code>func</code>关键字后面没有函数名称. 它是一个表达式, 它的值称作匿名函数. </p><p>函数字面量在我们需要的时候才定义. </p><p>更重要的是, 以这种方式定义的函数能够获取到整个词法环境, 因此里层的函数可以使用外层函数中的变量. </p><p>函数值不仅仅是一串代码, 还记录了状态. 存在变量引用. 这就是函数值属于引用类型和函数值不可比较的原因. <code>Go</code>使用闭包技术实现函数值, <code>Go</code>程序员也把函数值叫做闭包. </p><p>当一个匿名函数需要进行递归, 必须先声明变量然后将匿名函数赋值给这个变量. </p><h3 id="警告-捕获迭代变量"><a href="#警告-捕获迭代变量" class="headerlink" title="警告: 捕获迭代变量"></a>警告: 捕获迭代变量</h3><p>为什么在循环体内将循环变量赋给一个新的局部变量, 而不是直接使用循环变量. </p><p>问题的原因在于循环变量的作用域. <code>for</code>循环引入了新的语法块, 循环变量在这个词法块中被声明. 在该循环中生成的所有函数值都共享相同的函数变量. 需要注意, 函数值中记录的是循环变量的内存地址, 而不是循环变量某一时刻的值. </p><p>这样的隐患不仅仅存在于使用<code>range</code>的<code>for</code>循环中. 在普通<code>for</code>循环中也存在. </p><p>在<code>go</code>语句和<code>defer</code>语句中会经常遇到此类问题. 者不是<code>go</code>或<code>defer</code>本身导致的, 而是因为它们都会等待循环结束后, 在执行函数值. </p><h2 id="变长函数"><a href="#变长函数" class="headerlink" title="变长函数"></a>变长函数</h2><p>变长函数被调用的时候可以有可变的参数个数. 最令人熟知的例子就是<code>fmt.Printf</code>与其变种. <code>Prinf</code>需要在开头提供一个固定的参数, 后续便可以就收任意数目的参数. </p><p>在参数列表最后的类型名称之前使用省略号<code>...</code>表示声明一个变长函数, 调用这个函数的时候可以传递该类型任意数目的参数. </p><p>调用者隐式地创建一个数组, 并将原始参数复制到数组中, 再把数组的一个切片作为参数传递给被调用函数. 如果原始参数已经是切片类型, 我们如何传值? 只需要在<code>slice</code>后加<code>...</code>. </p><p>虽然在可变参数函数内部, 尽管可变参数的行为很像切片类型, 但实际上, 可变参数函数和以切片作为参数的函数是不同的. </p><p>可变参数函数经常被用于格式化字符串. <code>interface&#123;&#125;</code>表示函数的最后一个参数可以接收任意类型. </p><h2 id="延迟函数调用"><a href="#延迟函数调用" class="headerlink" title="延迟函数调用"></a>延迟函数调用</h2><p>语法上, 一个<code>defer</code>语句就是一个普通的函数或方法调用, 在调用之前加上关键字<code>defer</code>. 函数和参数表达式会在语句执行时求值, 但是无论是正常情况下, 执行<code>reutrn</code>或函数执行完毕, 还是不正常的情况下, 比如发生宕机, 实际的调用推迟到包含<code>defer</code>语句的函数结束后才执行. <code>defer</code>语句没有限制使用次数; 执行的时候以调用<code>defer</code>语句的顺序倒序进行. </p><p><code>defer</code>语句经常被用于处理成对的操作, 如打开, 关闭, 连接, 断开连接, 加锁, 释放锁. 通过<code>defer</code>机制, 无论函数逻辑多复杂, 都能保证在任何执行路径下, 资源被释放. 释放资源的<code>defer</code>应该直接跟在请求资源的语句后. </p><p>调试复杂程序时, <code>defer</code>机制也常被用于记录何时进入和退出函数. <code>defer</code>后面的函数返回一个函数. 返回函数的函数会在入口执行, 返回的函数会在出口执行. </p><p>我们知道, <code>defer</code>语句中的函数会在<code>return</code>语句更新返回值变量后在执行, 又因为在函数定义的匿名函数可以访问函数包括返回变量在内的所有变量, 所以, 对匿名函数采用<code>defer</code>机制, 可以使其观察函数的返回值. 被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值. </p><p>在循环体中的<code>defer</code>语句需要特别注意, 因为只有在函数执行完毕之后, 这些函数被延迟的函数才会被执行, 有些需要在一次循环结束后关闭, 这时可以把循环体变成一个函数, 在这个函数中使用<code>defer</code>. </p><p>如果试图使用延迟调用去关闭一个本地文件就会有些问题. 在许多文件系统中, 尤其是<code>NFS</code>, 写错误往往不是立即返回而是推迟到文件关闭的时候. 如果没有检查文件关闭时的反馈信息, 可能会导致数据丢失, 而我们还认为写入操作成功. </p><h2 id="Panic异常"><a href="#Panic异常" class="headerlink" title="Panic异常"></a><code>Panic</code>异常</h2><p><code>Go</code>的类型系统会在编译时捕获很多错误, 但有些错误只能在运行时检查, 如数组访问越界, 空指针引用等. 这些运行时错误会引起<code>panic</code>异常. </p><p>一般而言, 当<code>panic</code>异常发生时, 程序会中断运行, 并立即执行在该<code>goroutine</code>中被延迟的函数(<code>defer</code>机制). 随后, 程序崩溃并输出日志信息. 日志信息包括<code>panic value</code>和函数调用的堆栈很跟踪信息. <code>panic value</code>通常是某种错误信息. 对于每个<code>goroutine</code>, 日志信息中都会有与之相对的, 发生<code>panic</code>时的函数调用堆栈跟踪信息. </p><p>不是所有的<code>panic</code>异常都来自运行时, 直接调用内置的<code>panic</code>函数也会引发<code>panic</code>异常; <code>panic</code>函数接受任何值作为参数. 当某些不应该发生的场景发生时, 我们就应该调用<code>panic</code>.</p><p>断言函数必须满足的前置条件时明智的做法, 但者很容易被滥用. 除非你能提供更多的错误信息, 或者能更快的发现错误, 否则不需要使用断言, 编译器在运行时会帮你检查代码. </p><p>虽然<code>Go</code>的<code>panic</code>机制类似于其他语言的异常, 但<code>panic</code>的适用场景有些不同. 由于<code>panic</code>会引起程序的崩溃, 因此<code>panic</code>一般用于严重的错误, 如程序内部的逻辑不一致. 勤奋的程序员认为任何崩溃都表明程序中存在漏洞, 所以对于大部分漏洞, 我们应该使用<code>Go</code>提供的错误机制, 而不是<code>panic</code>, 尽量避免程序崩溃. 在健壮的程序中, 任何可以预料到的错误, 如不正确的输入, 错误的配置或是失败的<code>I/O</code>操作都应该被优雅地处理, 最好的处理方式, 就是使用<code>Go</code>的错误机制. </p><p>当调用者明确的知道正确的输入不会引起函数错误是, 要求调用者检查这个错误时不必要和累赘的. 我们应该假设函数的输入一直合法, 就如前面的断言一样: 当调用者输入了不该出现的输入时, 触发<code>panic</code>异常. 函数名中的<code>Must</code>前缀是一种针对此类函数的命名约定. </p><h2 id="Recover捕获异常"><a href="#Recover捕获异常" class="headerlink" title="Recover捕获异常"></a><code>Recover</code>捕获异常</h2><p>通常来说, 不应该对<code>panic</code>异常做任何处理, 但有时, 也许我们可以从异常中恢复, 至少可以在程序崩溃前, 做一些操作. </p><p>如果在<code>deferred</code>函数中调用了内置函数<code>recover</code>, 并且定义该<code>defer</code>语句的函数发生了<code>panic</code>会使程序从<code>panic</code>中恢复, 并返回<code>panic value</code>. 导致<code>panic</code>异常的函数不会继续运行, 但能正常返回. 在未发生<code>panic</code>时调用<code>recover</code>, <code>recover</code>会返回<code>nil</code>. </p><p>不加区分的恢复所有的<code>panic</code>异常, 不是可取的做法; 因为在<code>panic</code>之后, 无法保证包级变量的状态仍然和我们预期一致. </p><p>作为被广泛遵守的规范, 你不应该试图去恢复其他包引起的<code>panic</code>. 公有的<code>API</code>应该将函数的运行失败作为<code>error</code>返回, 而不是<code>panic</code>. 同样的, 你不应该恢复一个由他人开发的函数引起的<code>panic</code>, 比如说调用者传入的回调函数, 因为你无法确保这样做是安全的. </p><p>只恢复应该恢复的<code>panic</code>异常, 此外, 这些异常所占的比例应该尽可能的低. 为了标识某个<code>panic</code>是否应该被恢复, 我们可以将<code>panic value</code>设置成特殊类型. 在<code>recover</code>时对<code>panic value</code>进行检查, 如果发现<code>panic value</code>是特殊类型, 就将这个<code>panic</code>作为<code>error</code>, 如果不是, 则按照正常的<code>panic</code>进行处理. </p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(&quot;%*s&quot;, 数量, &quot;字符&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符串排序</span></span><br><span class="line">sort.String()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">runtime包允许程序员输出堆栈信息</span></span><br><span class="line">runtime.Stack()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go程序设计语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复合数据类型</title>
      <link href="/2023/08/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/08/29/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><p>复合数据类型是由基本数据类型以各种方式组合而构成的. 数组和结构体都是聚合类型, 它们的值由内存中的一组变量构成. 数组的元素具有相同的类型, 而结构体中元素类型则可以不同. 数组和结构体的长度都是固定的, 反之, <code>slice</code>和<code>map</code>都是动态数据结构, 它们的长度都是元素添加到结构体中时可以动态增长. </p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是具有固定长度且拥有零个或多个相同数据类型元素的序列. 由于数组的长度固定, 所以在<code>Go</code>里面直接很少使用. <code>slice</code>的长度可以增长和缩短, 在很多场合下使用得更多. </p><p><code>Go</code>内置的函数<code>len</code>可以返回数组中元素元素的个数. </p><p>默认情况下, 一个新数组中的元素初始值为元素类型的零值, 对于数字来说, 就是0. 也可以使用数组字面量根据一组值来初始化一个数组. 在数组字面中, 如果使用<code>...</code>代替数组长度, 那么数组的长度由初始化数组的个数决定. </p><p>数组长度是数组类型的一部分, 所以<code>[3]int</code>和<code>[4]int</code>是两种不同的数组类型. 数组的长度必须是常量表达式, 也就是说, 这个表达式的值在程序编译时就可以确定. </p><p>数组可以通过索引赋值, 没有指定值的索引位置的元素默认被赋予数组元素类型的零值. </p><p>如果一个数组的元素类型是可比较的, 那么这个数组也是可比较的, 这样我们就可以直接使用<code>==</code>操作符来比较两个数组, 比较的结果是两边元素的值是否完全相同. 只有长度相同的数组可以比较, 如果长度不同, 会认为是两个不同类型的数组. </p><p>在<code>Go</code>语言中, 把数组和其他的类型都看成值传递, 对参数的任何修改都发生在复制的数组上. 而在其语言中, 数组时隐式地使用了引用或指针传递. </p><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a><code>slice</code></h2><p><code>slice</code>表示一个拥有相同类型元素的可变长度的序列. <code>slice</code>通常写成<code>[]T</code>, 其中元素的类型都是<code>T</code>; 它看上去像没有长度的数组类型. </p><p>一个<code>slice</code>是一个轻量级的数据结构, 提供了访问数组子序列元素的功能, 而且<code>slice</code>的底层确实引用了一个数组对象. 一个<code>slice</code>有三个属性: 指针, 长度和容量. 指针指向数组的第一个可以从<code>slice</code>中访问的元素, 这个元素并不一定是数组的第一个元素. 长度是指<code>slice</code>中元素的个数, 它不能超过<code>slice</code>的容量. 容量的大小通常是从<code>slice</code>的起始元素到底层数组的最后一个元素间元素的个数. <code>Go</code>的内置函数<code>len</code>和<code>cap</code>用来返回<code>slice</code>的长度和容量. </p><p>一个底层数组可以对应多个<code>slice</code>, 这些<code>slice</code>可以引用数组的任何位置, 彼此之间的元素还可以重叠. </p><p><code>slice</code>操作符<code>s[i:j]</code>(其中$0 \le i \le j \le cap(s)$) 创建了一个新的<code>slice</code>, 这个新的<code>slice</code>引用了序列s中<code>i</code>到<code>j-1</code>索引位置的所有元素, 这里的s既可以是数组或是指向数组的指针, 也可以是<code>slice</code>. </p><p>如果切片操作超出了<code>cap(s)</code>的上限将导致一个<code>panic</code>异常, 但是超出了<code>len(s)</code>则是意味着扩展了<code>slice</code>, 因为新的<code>slice</code>的长度会变大. </p><p>因为<code>slice</code>包含了指向数组元素的指针, 所以将一个<code>slice</code>传递给函数的时候, 可以在函数内部修改底层数组的元素. </p><p><code>slice</code>字面量看上去和数组字面量很像, 都是用逗号分隔并用花括号扩起来的一个元素序列, 但是<code>slice</code>没有指定长度. 这种隐式区别的结果分别是创建有固定长度的数组和创建指向数组的<code>slice</code>. 和数组一样, <code>slice</code>也按照顺序指定元素, 也可以通过索引了指定元素, 或者两种结合. </p><p>和数组不同的是, <code>slice</code>无法做比较, 因此不能用<code>==</code>来测试两个<code>slice</code>是否拥有相同的元素. 标准库里面提供了高度优化的函数<code>bytes.Equal</code>来比较两个字节<code>slice</code>. 但是对于其他类型的<code>slice</code>, 我们必须自己写函数来比较. </p><p><code>slice</code>唯一允许的比较操作是和<code>nil</code>做比较. <code>slice</code>类型的零值是<code>nil</code>. 值是<code>nil</code>的<code>slice</code>没有对应的底层数组. 值为<code>nik</code>的<code>slice</code>长度和容量都是零, 但是也有非<code>nil</code>的<code>slice</code>长度和容量都是零, 例如<code>[]int&#123;&#125;</code>或<code>make([]int,3)[3:]</code>. 对于任何类型, 如果它们的值可以nil, 那么这个类型的值可以使用一种转换表达式, 例如<code>[]int(nil)</code>. </p><p>所以, 如果想检查一个<code>slice</code>是否为空, 那么使用<code>len(s) == 0</code>, 而不是<code>s == nil</code>, 因为<code>s != nil</code>情况下, <code>slice</code>也可能是空. </p><p>内置函数<code>make</code>可以创建一个具有指定元素类型, 长度和容量的<code>slice</code>. 其中容量参数可以省略, 在这种情况下, <code>slice</code>的长度和容量相等. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>)</span><br><span class="line"><span class="built_in">make</span>([]T, <span class="built_in">len</span>, <span class="built_in">cap</span>) <span class="comment">// 和 make([]T, cap)[:len]功能相同</span></span><br></pre></td></tr></table></figure><p>深度研究一下, 其实<code>make</code>创建了一个无名数组并返回了它的一个<code>slice</code>; 这个数组仅可以通过<code>slice</code>来访问. 在上面的第一行代码中, 所返回的<code>slice</code>引用了整个数组. 在第二行代码中, <code>slice</code>只引用了数组的前<code>len</code>个元素, 但是它的容量和数组的长度, 这为未来的<code>slice</code>元素留出空间. </p><h3 id="append函数"><a href="#append函数" class="headerlink" title="append函数"></a><code>append</code>函数</h3><p>内置函数<code>append</code>用来将元素追加到<code>slice</code>的后面. </p><p>更新<code>slice</code>变量不仅对调用<code>append</code>函数是必要的, 实际上对应任何可能导致长度, 容量或底层数组变化的操作都是必要的. </p><p>函数参数声明中的省略号<code>...</code>表示该函数可以接受可变参数列表, 实参后面的省略号表示将一个<code>slice</code>转换为参数列表. </p><h3 id="slice内存技巧"><a href="#slice内存技巧" class="headerlink" title="slice内存技巧"></a><code>slice</code>内存技巧</h3><p>输入的<code>slice</code>和输出的<code>slice</code>共享一个底层数组. 这可以避免分配另一个数组, 不过原来的数据可能会被覆盖. </p><h2 id="map"><a href="#map" class="headerlink" title="map"></a><code>map</code></h2><p>在<code>Go</code>语言中, <code>map</code>是散列表的引用, <code>map</code>的类型是<code>map[K]V</code>, 其中<code>K</code>和<code>V</code>是字典的键和值对应的数据类型. 键的类型<code>K</code>, 必须可以通过操作符<code>==</code>来进行比较的数据类型, 所以<code>map</code>可以检测某一个键是否已经存在. 虽然浮点型是可以比较的, 但是比较浮点型的相等性不是一个好主意. </p><p>内置函数<code>make</code>可以用来创建一个<code>map</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">args := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 创建一个从string到int的map</span></span><br></pre></td></tr></table></figure><p>也可以使用<code>map</code>的字面量来创建一个带初始键值对元素的字典:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">args := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">    <span class="string">&quot;alice&quot;</span>: <span class="number">31</span>,</span><br><span class="line">    <span class="string">&quot;charlie&quot;</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等价于</span><br><span class="line">args := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>) <span class="comment">// 等价于map[string]int&#123;&#125;</span></span><br><span class="line">args[<span class="string">&quot;alice&quot;</span>] = <span class="number">31</span></span><br><span class="line">args[<span class="string">&quot;charlie&quot;</span>] = <span class="number">34</span></span><br></pre></td></tr></table></figure><p>可以使用内置函数<code>delete</code>来从字典中根据键移除一个元素:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(args, <span class="string">&quot;alice&quot;</span>)</span><br></pre></td></tr></table></figure><p>即使键不在<code>map</code>中, 上面的操作也都是安全的. <code>map</code>使用给定的键来查找元素, 如果对应的元素不存在, 就返回值类型的零值. </p><p>快捷赋值方式(如x+&#x3D;y和x++)对<code>map</code>中元素同样适用.</p><p>我们无法获得<code>map</code>元素的地址的一个原因是<code>map</code>的增长可能会导致已有元素元素被重新散列到新的存储位置, 这样就可能使得获得的地址无效. </p><p>可以使用<code>for</code>循环(结合<code>range</code>关键字)来便历<code>map</code>中所有的键和对应的值. </p><p>如果需要按照某种顺序来遍历<code>map</code>中的元素, 我们必须显式地来给键排序, 然后再取值. 如果一开始就知道了元素的个数, 直接指定一个<code>slice</code>的长度会更加高效. </p><p><code>map</code>类型的零值是<code>nil</code>, 大多数的<code>map</code>操作都可以安全地在<code>map</code>的零值<code>nil</code>上执行, 包括查找元素, 删除元素, 获取<code>map</code>元素的个数(<code>len</code>), 执行<code>range</code>循环, 应为这和空<code>map</code>的行为一致. 但是向零值<code>map</code>中设置元素会导致错误. </p><p>判断一个元素知否在<code>map</code>中, 还是值是零值. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age, ok := args[<span class="string">&quot;bob&quot;</span>]; !ok &#123; <span class="comment">/* ... */</span>&#125;</span><br></pre></td></tr></table></figure><p>和<code>slice</code>一样, <code>map</code>不可比较, 唯一合法的比较就是和<code>nil</code>做比较. 为了判断两个<code>map</code>是否拥有相同的键和值, 必须写一个循环. </p><p><code>Go</code>没有提供集合类型, 但既然<code>map</code>的键都是唯一的, 就可以用<code>map</code>来实现这个功能. </p><p><code>map</code>的值类型本身可以是复合数据类型, 例如<code>map</code>和<code>slice</code>.</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>结构体是将零个或多个任意类型的命名变量组合在一起的聚合数据类型. 每个变量都叫做结构体的成员. </p><p>结构体可以通过点号的方式来访问成员. 点号同样可以用在结构体指针上. </p><p>成员变量的顺序对于结构体同一性很重要. 顺序不一样, 结构体就不一样. </p><p>命名结构体类型S不可以定义一个拥有相同结构体类型S的成员变量, 也就是一个聚合类型不可以包含它自己(同样的限制对数组也是适用). 但是S中可以定义一个S的指针类型, 即<code>*S</code>, 这样我们就可以创建一些递归数据结构, 比如链表和树. </p><p>结构体的零值由结构体成员的零值组成. 通常情况下, 我们希望零值是一个默认自然的, 合理的值. </p><p>任何没有成员变量的结构体称为空结构体, 写作<code>struct&#123;&#125;</code>. 它没有长度, 也不携带任何信息, 但是有时候会很有用. </p><h3 id="结构体字面量"><a href="#结构体字面量" class="headerlink" title="结构体字面量"></a>结构体字面量</h3><p>结构体类型的值可以通过结构体字面量来设置, 即通过设计结构体的成员变量来设置. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point struce&#123; X, Y <span class="type">int</span>&#125;</span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>有两种格式的结构体字面量. 第一中格式如上, 它要求按照正确的顺序, 为每个成员变量指定一个值, 这种格式一般只在定义结构体的包内部使用, 或者是在较小的结构体中使用, 这些结构体的成员排列比较规则. 第二种形式, 通过指定部分或全部成员变量的名称和值来初始化结构体变量. 如果在这种初始化方式中某个成员变量没有指定, 那么它的值就是该成员变量类型的零值. 因为了指定了成员变量的名字, 所以它们的顺序是无所谓的. </p><p>这两种初始化方式不可以混合使用, 另外也无法使用第一种初始化方式来绕过不可导出的变量无法在其他包中使用的规则. </p><p>如果考虑效率的haunted, 较大的结构体通常会使用指针的方式传入和返回. </p><p>如果要在函数内部修改结构体成员的话, 用指针传入是必须的; 因为在<code>Go</code>语言中, 所有的函数参数都是值拷贝传入的, 函数参数将不再是函数调用时的原始变量. </p><h3 id="结构体比较"><a href="#结构体比较" class="headerlink" title="结构体比较"></a>结构体比较</h3><p>如果结构体的所有成员变量都是可以比较的, 那么这个结构体就是可比较的. 两个结构体的比较可以使用<code>==</code>或者<code>!=</code>. 其中<code>==</code>操作按照顺序比较两个结构体变量的成员变量. </p><h3 id="结构体嵌套和匿名成员"><a href="#结构体嵌套和匿名成员" class="headerlink" title="结构体嵌套和匿名成员"></a>结构体嵌套和匿名成员</h3><p><code>Go</code>允许我们定义不带名称的结构体成员, 只需要指定类型即可; 这种结构体成员称做匿名成员. 这个结构体成员的类型必须是一个命名类型或指向命名类型的指针. 正因为有了这种结构体嵌套的功能, 我们才能直接访问到我们需要的变量而不是指定一大串中间变量. </p><p>匿名成员的名称其实是对应类型的名字, 只是这些名字在点号访问时时可选的. 结构体字面值并没有简短表示匿名成员的语法. </p><p>因为”匿名成员”拥有隐式的名字, 所以你不能在一个结构体里面定义两个相同类型的匿名成员, 否则会引起冲突. 由于匿名成员的名字是由它们的类型决定的, 因此它们的可导出性也是由它们的类型决定的. </p><p>以快捷方式访问匿名成员的内部变量同样适用于访问匿名成员的内部方法. 因此, 外围的结构体类型获取的不仅是匿名成员的内部变量, 还有相关的方法. </p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a><code>JSON</code></h2><p><code>javaScript</code>对象表示法(<code>JSON</code>)是一种发送和接收格式化信息的标准. <code>JSON</code>是<code>JavaScript</code>值的<code>Unicode</code>编码, 这些值包括字符串, 数字, 布尔值, 数组和对象. <code>JSON</code>里面的<code>\Uhhhh</code>转义数字来表示一个<code>UTF-16</code>编码(译注: <code>UTF-16</code>和<code>UTF-8</code>一样是一种变长的编码, 但是有大端和小端之分). </p><h2 id="文本和HTML模版"><a href="#文本和HTML模版" class="headerlink" title="文本和HTML模版"></a>文本和<code>HTML</code>模版</h2><p>通常情况下, <code>Printf</code>函数就够用了, 但是有的情况下格式化会很复杂, 并且要求格式和代码彻底分离. 这个可以通过<code>text/template</code>包和<code>/html/template</code>包里面的方法来实现, 这两个包提供了一种机制, 可以将程序变量的值植入到文本或者是<code>HTML</code>模版中. </p><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 解码UTF-8编码, 并返回三个值, 解码的字符, UTF-8编码中字节的长度和错误值. 这里唯一可能出现的错误是文件结束(EOF), 如果输入的不是合法的UTF-8字符, 那么返回的字符是unicode.ReplacementChar并且长度是1</span><br><span class="line">in.ReadRune()</span><br><span class="line"></span><br><span class="line">// 副词#使得%v用和`Go`语言类似的语法打印. 对于结构体类型来说, 将包含每个成员的名字</span><br><span class="line">fmt.Printf(&quot;%#v&quot;, w)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">marshal编组, 将go对象编组为JSON对象, 这个是紧凑形式, 格式化方法, json.MarshlIndent(movies, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>), 只有可以导出的成员可以转换为JSON字段</span></span><br><span class="line">json.marshal(movies)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">unmarshal解码, 将JSON转换为go对象. 通过合理地定义go的数据结构, 我们可以选择将哪部分JSON数据解码到结构体中, 哪些数据可以丢弃, 解码忽略大小写</span></span><br><span class="line">json.Unmarsh</span><br></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><p>将一个<code>slice</code>左移n个元素的简单方法是连续调用<code>reverse</code>函数三次. 第一次反转前n个元素, 第二次反转剩下的元素, 最后一次对整个<code>slice</code>再做一次反转(如果将元素右移n个元素, 那么先做第三次调用)</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go程序设计语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据</title>
      <link href="/2023/08/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE/"/>
      <url>/2023/08/26/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据"><a href="#基本数据" class="headerlink" title="基本数据"></a>基本数据</h1><p>毫无疑问, 计算机底层全是位, 而实际操作则是基于大小固定的单元中的数值, 称为字, 这些值可解释为整数, 浮点数, 位集或内存地址等, 进而构成更大的聚合体, 以表示数据包, 像素, 文件, 诗集, 以及其他种种. </p><p><code>Go</code>的数据类型分为四大类: 基础类型, 聚合类型, 引用类型和接口类型. 基础类型, 包括数字, 字符串和布尔型. 聚合类型包括, 数组和结构体. 引用类型, 包括指针, <code>slice</code>, <code>map</code>, 函数, 以及通道, 它们的共同点都是全部间接指向程序变量或状态, 这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝. </p><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p><code>Go</code>语言的数值类型包括几种不同大小的整数, 浮点数和复数. 各种数值类型分别有自己的大小, 对正负号支持也各异. </p><p><code>Go</code>同时具备有符号整数和无符号整数. 有符号整数分为四种大小: 8位, 16位, 32位, 64位, 用<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>表示, 对应的无符号整数是<code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>.</p><p>此外还有两种类型<code>int</code>和<code>uint</code>. 在特定平台上, 其大小和原生的有符号数<code>\</code>无符号整数相同, 或等于该平台上运算效率最高的值. <code>int</code>是目前使用最广泛的数值类型. 者两种类型大小相等, 都是32位或64位, 版不能认为它们就一定是32位, 或一个就是64位; 即使在同样的硬件平台上, 不同的编译器也可能选用不同的大小. </p><p><code>rune</code>类型是<code>int32</code>类型的同义词, 常常用于指明一个值是<code>Unicode</code>码点. 这两个名称可互换使用. 同样, <code>byte</code>类型是<code>uint8</code>类型的同义词, 强调一个值是原始数据, 而非量值. </p><p>最后, 还有一种无符号整数<code>uintptr</code>, 其大小并不明确, 但足以完整存放指针. <code>uintptr</code>类型仅仅用于底层编码, 例如在<code>Go</code>程序与<code>C</code>程序库或操作系统接口相互交互的地方. </p><p><code>int</code>, <code>uint</code>和<code>uintptr</code>都是不同类型的兄弟类型, 也必须进行显式地类型操作转换. </p><p>有符号数以补码表示. </p><p>算术运算符<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>可应用于整数, 浮点数和复数, 而取模运算符<code>%</code>仅能用于整数. 取模运算符<code>%</code>的行为因编程语言而异. 就<code>Go</code>而言, 取模余数的正负号总是与被除数一致, 于是<code>-5%3</code>和<code>-5%-3</code>都得<code>-2</code>. 除法运算<code>(/)</code>的行为取决于操作数是否都为整形, 整数相除, 商会舍弃掉小数部分.</p><p>不论是有符号数还是无符号数, 若表达算术运算结果所需的位超出该类型的范围, 就称为溢出. 溢出的高位部分会无提示地丢弃.</p><p>实际上, 全部基本类型的值(布尔值, 数值, 字符串)都可以比较, 这意味着两个相同类型的值可用<code>==</code>和<code>!=</code>运算符比较. 整数, 浮点数和字符串还能根据比较运算符排序. </p><p>如果作为二元运算符, 运算符<code>^</code>表示按位”异或”<code>(XOR)</code>; 若作为一元前缀运算符, 则它表示按位取反或按位取补, 运算结果就是操作数逐位取反. 运算符<code>&amp;^</code>是按位清除<code>(AND NOT)</code>: 表达式<code>z=x&amp;^y</code>中, 若y的某位是1, 则z的对应位等于0; 否则, 他就等于x的对应位. </p><p>在位移运算符<code>x&lt;&lt;n</code>和<code>x&gt;&gt;n</code>中, 操作数你决定位移量, 而且n必须为无符号型; 操作数x可以是有符号型也可以是无符号型. 算术上, 左移运算<code>x&lt;&lt;n</code>等价于x乘以$2^n$; 而右移运算<code>x&gt;&gt;n</code>等价于x除以<code>2^n</code>, 向下取整. </p><p>左移以0填补右边空位, 无符号数右移同样以0填补左边空位, 但是有符号数的右移操作是按符号位的值填补空位. 因此, 当进行位运算的时候, 尽量使用无符号数. </p><p>因此, 无符号整数往往只用于位运算符和特定算术运算符, 如实现位集时, 解析二进制格式的文件, 或散列和加密. 一般而言, 无符号整数极少用于表示非负值. </p><p>通常, 将某种类型的值转换成另一种, 需要显式转换. 对于算术和逻辑(不含移位)的二元运算符, 其操作数的类型必须相同. 虽然这有时会导致表示式相对冗长, 但是一整类错误得以避免, 程序也更容易理解. </p><p>浮点型转成整形, 会舍弃小数部分, 趋零截尾(正值先下取整, 负值先上取整). 如果有些转换的操作数的值超出了目标类型的取值范围, 就应当避免这种转换, 因为其行为依赖具体实现. </p><p>任何大小的整数字面值都能写成十进制数, 也能写成八进制数(以0开头), 或十六进制(以0x或0x)开头.当前, 八进制数似乎仅有一种用途, 表示<code>POSIX</code>文件系统的权限, 而十六进制数广泛用于强调其位模式, 而非数值大小. </p><p>字符面值通过一对单引号直接包含字符. 用<code>%c</code>输出文字符号, 如果希望输出带有单引号则用<code>%q</code>. </p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p><code>Go</code>具有两种大小的浮点数<code>float32</code>和<code>float64</code>. 这两个类型的值可从超细微到超宏大. <code>math</code>包给出了浮点值的极限. </p><p>十进制下, <code>float32</code>的有效数字大约是6位, <code>float64</code>的有效数字大约15位. 绝大多数情况下, 应优先选用<code>float64</code>, 因为除非格外小心, 否则<code>float32</code>的运算会迅速累积误差. 另外, <code>float32</code>能精确表示的正整数范围有限. </p><p>小数点前的数字可以省略<code>(.707)</code>, 后面的也可以省去<code>(1.)</code>. 非常小或非常大的数字最好使用科学计数法表示, 此方法在数量级指数前写字母<code>e</code>或<code>E</code>. </p><p>使用<code>Printf</code>函数的<code>%g</code>输出, 该谓词会自动保持足够的精度, 并选择最简介的表示方式, 但是对于数据表, <code>%e</code>(有指数)或<code>%f</code>(无指数)的形式可能更合适. </p><p>除了大量常见的数学函数之外, <code>math</code>包还有函数用于创建和判断<code>IEEE 754</code>标准定义的特殊值: 正无穷大和负无穷大, 它表示超出最大许可值的数和除零的结果; 以及<code>NAN</code>, 它表示数学意义上无意义的运算结果. </p><p><code>math.isNaN</code>函数判断其参数是否是非数值, <code>math.NaN</code>函数则返回非数值. 在数字运算中, 我们倾向于将<code>NaN</code>当作信号值, 不拿它来进行比较操作, 因为<code>NaN</code>和任何数的比较操作都为<code>false</code>(除了<code>!=</code>为<code>true</code>). 在浮点数中, <code>NaN</code>, 正无穷大和负无穷大都不是唯一的, 每个都有非常多种的<code>bit</code>模式表示. </p><p>如果一个函数返回的浮点数结果可能失败, 最好的做法是用单独的标志报告失败. </p><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p><code>Go</code>具有两种大小的复数<code>complex64</code>和<code>complex128</code>, 二者分别由<code>float32</code>和<code>float64</code>构成. 内置的<code>complex</code>函数根据给定的实部和虚部创建复数, 内置的<code>real</code>函数和<code>imag</code>函数则分别提取复数的实部和虚部. </p><p>如果一个浮点数面值或一个十进制整数面值后面跟着一个<code>i</code>, 例如<code>3.14i</code>或<code>2i</code>, 它将构成一个复数的虚部, 复数的实部是0. </p><p>可以用<code>==</code>或<code>!=</code>判断复数是否相等. 若两个复数的实部和虚部都相等, 则它们相等. </p><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p><code>bool</code>型的值或布尔值只有两种可能: 真<code>true</code>和假<code>false</code>. 布尔值可以和<code>&amp;&amp;</code>和<code>||</code>操作符结合, 并且会发生短路行为. </p><p>布尔值无法隐式转换成数值(如0或1), 反之也不行. </p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是不可变的字节序列, 它可以包含任意数据, 包括0值字节. 习惯上, 文本字符串被解读成按<code>UTF-8</code>编码的<code>Unicode</code>码点(文字符号)序列. </p><p>内置的<code>len</code>函数返回字符串的字节数(并非文字符号的数目), 下标访问操作<code>s[i]</code>则取的第<code>i</code>个字符, 其中$0 \le i \le len(s)$. 试图访问许可范围以外的字节会触发<code>panic</code>异常. </p><p>子串生成操作<code>s[i:j]</code>产生一个新字符串, 内容取自原字符串的字节, 下标从<code>i</code>(含边界值)开始, 直到<code>j</code>(不含边界值). 结果的大小是<code>j-i</code>个字节, 若下标越界, 或者<code>j</code>的值小于<code>i</code>, 将触发<code>panic</code>异常. </p><p>操作数<code>i</code>与<code>j</code>的默认值分别是<code>0</code>(字符串起始位置)和<code>len(s)</code>(字符串终止位置), 若省略<code>i</code>或<code>j</code>, 或两者, 则取默认值. </p><p>加号<code>(+)</code>运算符连接两个字符串而生成一个新字符串. </p><p>字符串可以通过比较运算符做比较, 如<code>==</code>和<code>&lt;</code>; 比较运算按字节进行, 结果服从本身字典排序. </p><p>字符串值无法改变, 不可变意味着两个字符串能安全地共用同一段底层内存, 使得复制任何长度字符串的开销都很低廉. </p><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>字符串的值可以直接写成字符串字面量, 形式上就是带双引号的字节序列. 源码中的字符串也可以包含十六进制或八进制的任意字节. </p><p>原生的字符串字面量的书写形式使用反引号而不是双引号. 原生的字符串字面量内, 转义序列不起作用; 实质内容与字面写法严格一致, 包括反斜杠和换行符, 因此, 在程序源码中, 原生的字符串字面量可以展开多行. 唯一的特殊处理是回车符会被删除(换行符会保留), 使得同一字符串在所有平台上的值都是相同的. </p><p>正则表达式往往含有大量反斜杠, 可以方便地写成原生的字符串字面量. 原生的字面量也适用于<code>HTML</code>模板, <code>JSON</code>字面量, 命令行提示信息, 以及需要多行文本表达的场景. </p><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode是一种字符集, 它攘括了世界上所有文书体系的全部字符, 对它们各自赋予一个叫Unicode码点的标准数字. 在<code>Go</code>的术语中, 这些字符记号称为文字符号. </p><p>我们可以将文字符号的序列表示成<code>int32</code>值序列, 这种表示方式称作<code>UTF-32</code>或<code>UCS-4</code>, 每个Unicode码点的编码长度相同, 都是32位. </p><h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a><code>UTF-8</code></h3><p><code>UTF-8</code>以字节为单位对Unicode码点做变长编码. 每个文字字符用<code>1~4</code>个字节表示, <code>ASCII</code>字符的编码仅占1个字节, 而其他常用的文字字符的编码只是2或3个字节. </p><p>变长编码的字符串无法按下标直接访问第n个字符. 同时<code>UTF-8</code>编码的顺序和Unicode码点的顺序一致, 因此可以直接排序<code>UTF-8</code>编码. </p><p><code>Go</code>语言字符串字面值中的的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符. 有两种形式, <code>\uhhhh</code>表示16位码点值, <code>\uhhhhhhhh</code>表示32位码点值, 其中每个<code>h</code>代表要一个十六进制数值. 这两种形式都以<code>UTF-8</code>编码表示给定的码点. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;世界&quot;</span><br><span class="line">&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;</span><br><span class="line">&quot;\u4e16\u754c&quot;</span><br><span class="line">&quot;\U00004e16\U0000754c&quot;</span><br><span class="line">&#x27;世&#x27; &#x27;\u4e16&#x27; &#x27;\U00004e16&#x27;</span><br></pre></td></tr></table></figure><p>码点值小于256的文字符号可以写成单个十六进制转义的形式, 如<code>A</code>写成<code>\x41</code>; 而更高的码点值则必须使用<code>\u</code>或<code>\U</code>转义. 这就导致<code>&#39;\xe4\xb8\x96\xe7\x95\x8c&#39;</code>不是合法的文字符号, 虽然这三个字节构成了某个有效的<code>UTF-8</code>编码的码点. </p><p>所幸, <code>Go</code>的<code>range</code>循环也适用于字符串, 按<code>UTF-8</code>隐式解码. 注意, 对于非<code>ASCII</code>文字符号, 下标增量大于1. </p><p>每次<code>UTF-8</code>解码器读入一个不合理的字节, 无论是显式调用<code>utf8.DecodeRuneInString</code>, 还是在<code>range</code>循环内隐式读取, 都会产生一个专门的Unicode字符<code>\uFFFD</code>替换它, 其输出通常是个黑色六角形或类似钻石的形状, 里面有个白色问号. 如果程序碰到这个文字符号值, 通常意味着, 生成字符串数据的系统上游部分在处理文本编码方面存在瑕疵. </p><p><code>UTF-8</code>是一种分外便捷的交互格式, 而在程序内部使用文字字符类型可能更加方便, 因为它们大小一致, 便于在数组和<code>slice</code>中用下标访问. </p><p>当<code>[]rune</code>转换作用于<code>UTF-8</code>编码字符串时, 返回该字符串的<code>Unicode</code>码点序列.</p><p>如果是将一个<code>[]rune</code>类型的Unicode字符<code>slice</code>或数组转为<code>string</code>, 则对它们进行<code>UTF8</code>编码.</p><p>将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的<code>UTF8</code>字符串.</p><p>如果对应码点的字符是无效的, 则用<code>\uFFFD</code>无效字符作为替换. </p><h3 id="字符串和字节slice"><a href="#字符串和字节slice" class="headerlink" title="字符串和字节slice"></a>字符串和字节<code>slice</code></h3><p>4个标准包对字符串操作特别重要: <code>bytes</code>, <code>strings</code>, <code>strconv</code>和<code>unicode</code>. </p><p><code>strings</code>包提供了许多函数, 用于搜索, 替换, 比较, 截断, 拆分和连接字符串. </p><p><code>bytes</code>包也有类似的函数, 用于操作字节<code>slice</code>. 由于字符串不可变, 因此按增量方式构建字符串会导致多次内存分配和复制. 在这种情况下, 使用<code>bytes.Buffer</code>类型会更高效. </p><p><code>strconv</code>包具备的函数, 主要用于转换布尔值, 整数, 浮点数为与之对应的字符串形式, 或者把字符串转换为布尔值, 整数, 浮点数, 另外还提供了双引号转义相关的转换. </p><p><code>unicode</code>包具备判别文字符号特征的函数, 如<code>IsDisgit</code>, <code>IsLetter</code>, <code>IsUpper</code>和<code>IsLower</code>. 每个函数一以单个文字符号值作为参数, 并返回布尔值. 若文字符号是英文字母, 转换函数(如<code>ToUpper</code>和<code>ToLower</code>)将其转换成指定的大小写. 上面所有函数都遵循Unicode标准对字母数字等的分类原则. <code>strings</code>包也有类似的函数, 函数名也是<code>ToUpper</code>和<code>ToLower</code>, 它们对原字符的每个字符做指定变换, 生成并返回一个新字符串. </p><p><code>path</code>包和<code>path/filepath</code>包提供提取<code>basename</code>的函数, 用来操作文件路径等具有层次结构的名字. <code>path</code>包处理以斜杠<code>/</code>分段的路径字符串, 不分平台. 它不适用于处理文件名, 却适合其他领域, 像<code>URL</code>地址的路径部分. 相反地, <code>path/filepath</code>包根据宿主平台的规则处理文件名. 例如<code>POSIX</code>系统使用<code>/</code>, 而<code>Microsoft Windows</code>系统使用<code>\</code>. </p><p>一个字符串是包含的只读字节数组, 一旦创建, 是不可变的. 相比之下, 一个字节<code>slice</code>的元素则可以自由地修改. </p><p>从概念上讲, 一个<code>[]byte(s)</code>转换是分配一个新的字节数组用于保存字符串数据的拷贝, 然后引用这个底层的字节数组. 编译器的优化可以避免在一些场景下分配和复制字符串数据, 但是总的来说需要确保<code>slice</code>变量被修改的情况下, 原始的字符串也不会改变. 将一个字节<code>slice</code>转到字符串<code>string(b)</code>从操作则是构造一个字符串拷贝, 以确保字符串是只读的. </p><p><code>bytes</code>包还提供了<code>Buffer</code>类型用于字节<code>slice</code>的缓存. 一个<code>Buufer</code>开始是空的, 但是随着<code>string</code>, <code>byte</code>或<code>[]byte</code>等数据类型的写入可以动态增长, 一个<code>bytes.Buffer</code>变量并不需要处理化, 因为零值也是有效的. </p><p>当向<code>bytes.Buffer</code>添加任意字符的<code>UTF0-8</code>编码时, 最好使用<code>bytes.Buffer</code>的<code>WriteRune</code>方法, 但是<code>WriteByte</code>方法对写入类似<code>[</code>和<code>]</code>等<code>ASCII</code>字符则会更加有效. </p><h3 id="字符串和数字的相互转换"><a href="#字符串和数字的相互转换" class="headerlink" title="字符串和数字的相互转换"></a>字符串和数字的相互转换</h3><p>要将整数转换成字符串, 一种选择是使用<code>fmt.Sprintf</code>, 另一种做法是用函数<code>strconv.Itoa()</code>. </p><p><code>FomatInt</code>和<code>FomatUint</code>可以按不同进制位格式化数字. </p><p>如要要将要给字符串解析位整数, 可以使用<code>strconv</code>包的<code>Atoi</code>或<code>ParseInt</code>函数, 还有用于解析无符号整数的<code>ParseUint</code>函数.</p><p>有时候也会使用<code>fmt.Scanf</code>来解析输入的字符串和数字, 特别是当字符串和数字混在一行的时候, 它可以灵活处理不完整或不规则的输入. </p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是一种表达式, 其可以保证在编译阶段就可以计算出表达式的值, 并不需要等到运行时, 从而使编译器以知晓其值. 所有常量本质上都是属于基本类型: 布尔型, 字符串或数字. </p><p>对于常量操作数, 所有数学运算, 逻辑运算和比较运算的结果依然是常量, 对常量的类型转换操作或以函数调用都是返回常量结果: <code>len</code>, <code>cap</code>, <code>real</code>, <code>imag</code>, <code>complex</code>和<code>unsafe.Sizeof</code>. </p><p>因为它们的值是在编译期就确定的, 因此常量可以是构成类型的一部分, 例如用于指定数组类型的长度. </p><p>常量声明可以同时指定类型和值, 如果没有显式指定类型, 则类型根据右边的表达式推断. 若同时声明一组变常量, 除了第一项之外, 其他项在等号右侧的表达式都可以省略, 这意味着会复用前面一项的表达式以及类型. </p><h3 id="常量生成器iota"><a href="#常量生成器iota" class="headerlink" title="常量生成器iota"></a>常量生成器<code>iota</code></h3><p>常量的声明可以使用常量生成器<code>iota</code>, 它创建一系列相关值, 而不是逐个值显式写出. 常量声明中, <code>iota</code>从<code>0</code>开始取值, 逐项加<code>1</code>. </p><h3 id="无类型常量"><a href="#无类型常量" class="headerlink" title="无类型常量"></a>无类型常量</h3><p>常量可以任何基本数据类型, 也包括具名的基本类型, 但是许多常量并没有一个明确的基本类型. 编译器为这些没有明确的基础恶劣性的数字常量提供了比基础类型更高精度的算术运算; 你可以认为至少有256<code>bit</code>的运算精度. 这里有六种未明确类型的常量类型, 分别是无类型的布尔型, 无类型的整数, 无类型的字符, 无类型的浮点数, 无类型的复数, 无类型的字符串. </p><p>通过延迟明确常量的具体类型, 无类型的常量不仅可以提供更高的运算精度, 而且可以直接用于更多的表达式而不需要显式地类型转换. </p><p>只有常量可以是无类型的. 当一个无类型的常量被赋值给一个变量的时候, 无类型的常量将会被隐式转换为对应的类型, 如果转换合法的话. </p><p>对于一个没有显式类型的变量声明语法(包括短变量声明语法), 无类型的常量会被隐式转为默认的变量类型. </p><h1 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印8位的表示</span></span><br><span class="line">fmt.Printf(&quot;%08b\n&quot;, x)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个参数打印多次, <span class="comment">#用来告知是打印前缀</span></span></span><br><span class="line">fmt.Printf(&quot;%d %[1]o %#[1]o %[1]x %#[1]x %#[1]X&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将浮点数指定输出宽度和数值精度, g, f, e都可以这样</span></span><br><span class="line">fmt.Printf(&quot;%8.3f&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给出文字字符的数量</span></span><br><span class="line">utf8.RuneCountInString(s)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解码出文字字符和文字字符占的字节数</span></span><br><span class="line">utf8.DecodeRuneInString()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">十六进制数, 字节以空格分隔</span></span><br><span class="line">fmt.Printf(% x, s)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go程序设计语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序结构</title>
      <link href="/2023/08/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/"/>
      <url>/2023/08/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p><code>Go</code>语言中的函数名, 变量名, 常量名, 类型名, 语句标号和包名等所有的命名, 都遵循一个简单的命名规则: 一个名字必须以一个字母(<code>Unicode</code>字母)或下划线开头, 后面可以跟任意数量的字母, 数字或下滑线. 大写字母和小写字母是不同的: <code>heapSort</code>和<code>HeapSort</code>是两个不同的名字. 名字的长度没有逻辑限制. 在习惯上, <code>Go</code> 语言程序员推荐使用驼峰式命名, 同时缩略词的中每个字母大小写保持一致. </p><p><code>Go</code>语言中关键字有25个:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break default func interface select</span><br><span class="line">case defer go map struct</span><br><span class="line">chan else goto package switch</span><br><span class="line">const fallthrough if range type</span><br><span class="line">continue for import return var</span><br></pre></td></tr></table></figure><p><code>Go</code>大约有30多个预定义的名字:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内建常量: true false iota nil</span><br><span class="line"></span><br><span class="line">内建类型: int int8 int16 int32 int64</span><br><span class="line">uint uint8 uint16 uint32 uint64 uintptr</span><br><span class="line">float32 float64 complex128 complex64</span><br><span class="line">bool type rune string error</span><br><span class="line"></span><br><span class="line">内建函数: make len cap new append copy close delete</span><br><span class="line">complex real imag panic recover</span><br></pre></td></tr></table></figure><p>如果一个名字是在函数内部定义, 那么它就只能在函数内部有效. 如果是在函数外部定义, 那么将在当前包的所有文件中都可以访问. 名字的开头字母的大小写决定了名字在包外的可见性. 如果一个名字是大写字母开头的, 那么它将是导出的, 也就是说可以被外部的包访问.</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><code>Go</code>语言主要有四种类型的声明语句: <code>var</code>, <code>const</code>, <code>type</code>和<code>func</code>, 分别对应变量, 常量, 类型和函数实体对象的声明. 程序中包一级的声明一般按照类型, 变量, 常量, 函数的声明语句.</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>var</code>声明语句可以创建要给特定类型的变量. 一般声明语法如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 变量名称 类型 = 表达式</span><br></pre></td></tr></table></figure><p>如果省略的是类型信息, 那么将根据初始化表达式来推导变量的类型信息. 如果初始化表达式被省略, 那么将用零值初始化该变量. 数值类型变量对应的零值是<code>0</code>, 布尔类型变量对应的零值是<code>false</code>, 字符串类型对应的零值是空字符串, 接口或引用类型(包括<code>slice</code>, <code>map</code>, <code>chan</code>和函数)变量对应的零值是<code>nil</code>. 数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值. </p><p>在包级别声明的变量会在<code>main</code>入口函数执行前完成初始化, 局部变量将在声明语句被执行到的时候完成初始化.</p><h3 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h3><p>在函数内部, 有一种称为短变量声明语句的形式可用于声明和初始化局部变量. 它以<code>名字:=表达式</code>形式声明变量, 变量的类型根据表达式来自动推导. </p><p>因为简单和灵活的特点, 短变量声明被广泛用于局部变量的声明和初始化. <code>var</code>形式的声明语句往往是用于需要显式指定变量类型的地方, 或者因为变量稍后会被重新赋值而初始值无关紧要的地方.</p><p>如果有一些已经在相同的词法域声明过了, 那么短变量声明语句对这些已经声明过的变量就只有赋值行为. 短变量声明语句中至少要声明一个新的变量. </p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>一个指针的值是是一个变量的地址. 并不是每一个值都会有一个内存地址, 但是对于每个变量必然有对应的内存地址. 通过指针, 我们可以直接读或更新对应变量的值, 而不需要知道变量的名字. </p><p>如果指针对应的数据类型是<code>*int</code>, 指针被称之为”指向<code>int</code>类型的指针”. 如果指针名字为<code>p</code>, 那么可以说”<code>p</code>指针指向变量<code>x</code>“ , 或者说”<code>p</code>指针保存了<code>x</code>变量的内存地址”. </p><p>任何类型的指针的零值都是<code>nil</code>. 如果<code>p != nil</code>测试为真, 那么<code>p</code>是指向某个有效变量. 指针之间也是可以进行相等测试的, 只有当它们指向同一个变量或全部都是<code>nil</code>时才相等. </p><p>在<code>Go</code>语言中, 返回函数中局部变量的地址也是安全的.   </p><h3 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a><code>new</code>函数</h3><p>另一个创建变量的方式是调用内建的<code>new</code>函数. 表达式<code>new(T)</code>将创建要给<code>T</code>类型的匿名变量, 初始为<code>T</code>类型的零值, 然后返回变量地址, 返回的指针类型为<code>*T</code>. </p><p>用<code>new</code>创建变量和普通变量声明语句方式创建变量没有什么区别, 除了不需要声明一个临时变量. </p><p>请谨慎使用大小为<code>0</code>的类型, 因为如果类型的大小为<code>0</code>的话, 可能导致<code>Go</code>语言的自动垃圾回收器有不同的行为. </p><h3 id="变量的生命周期"><a href="#变量的生命周期" class="headerlink" title="变量的生命周期"></a>变量的生命周期</h3><p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔. 对于在包一级声明的变量来说, 它们的生命周期和整个程序的运行周期是一致的. 而相比之下, 在局部变量的生命周期则是动态的: 从每次创建一个新变量的声明语句开始, 直到该变量不再被引用为止,  然后变量的存储空间可能被回收. 函数的参数变量和返回值都是局部变量. 它们在函数每次被调用的时候创建. </p><p>函数的有右小括弧也可以另起一行缩进, 同时为了防止编译器在行尾自动插入分号而导致的编译错误, 可以在末尾的参数变量后面显式插入逗号. </p><p><code>Go</code>语言的自动垃圾收集器是如何知道一个变量时何时可以被回收的呢? 基本的实现思路是, 从每个包级的变量和每个当前运行函数的每一个局部变量开始, 通过指针或引用的访问路径遍历, 是否可以找到该变量. 如果不存在这样的访问路径, 那么说明该变量时不可达的. </p><p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间, 这个选择并不是由用<code>var</code>还是<code>new</code>声明变量的方式决定的. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global *<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line">    global = &amp;x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> &#123;</span><br><span class="line">    y := <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *y = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>f</code>函数里的<code>x</code>变量必须在堆上分配, 因为它在函数退出后依然可以通过包一级的<code>global</code>变量找到, 虽然它是在函数内部定义的; 用<code>Go</code>语言的术语来说, 这个<code>x</code>局部变量从函数<code>f</code>中逃逸了. 相反, 当<code>g</code>函数返回时, 变量<code>*y</code>将是不可达的, 也就是说可以马上被回收. 因此, <code>*y</code>并没有从函数<code>g</code>中逃逸, 编译器可以选择在栈上分配<code>*y</code>的存储空间(译注: 也可以选择在堆上分配, 然后由<code>Go</code>语言的<code>GC</code>回收这个变量的内存空间), 虽然这里用的是<code>new</code>方式. 其实在任何时候, 你并不需要为了编写正确的代码而要考虑变量的逃逸行为, 要记住的是, 逃逸的变量需要额外分配内存, 同时对性能的优化可能产生细微的影响. </p><p><code>Go</code>语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助, 但也不是说你完全不用考虑内存了. 你虽然不需要显式地分配和释放内存, 但是要编写高效的程序你依然需要了解变量的生命周期. 例如, 如果将指向短生命周期对象保存到具有长生命周期的对象中, 特别是保存到全局变量时, 会阻止对短生命周期对象的垃圾回收(从而可能影响程序的性能). </p><h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>使用赋值语句可以更新一个变量的值.</p><h3 id="元组赋值"><a href="#元组赋值" class="headerlink" title="元组赋值"></a>元组赋值</h3><p>元组赋值是另一种形式的赋值语句, 它允许同时更新多个变量的值. 在赋值之前, 赋值语句右边的所有表达式将会先进行求值, 然后再统一更新左边对应变量的值. 这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助, 例如我们可以这样交换两个变量的值: </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br></pre></td></tr></table></figure><p>有些表达式会产生多个值, 比如调用一个有多个返回值的函数. 当这样一个函数调用出现在元组赋值右边的表达式中时(右边不能再有其它表达式), 左边变量的数目必须和右边一致. </p><p>通常, 这类函数会用额外的返回值来表达某种错误类型, 例如<code>os.Open</code>是用额外的返回值返回一个<code>error</code>类型的错误, 还有一些是用来返回布尔值, 通常被称为<code>ok</code>. </p><p>和变量声明一样, 我们可以用下划线空白标识符<code>_</code>来丢弃不需要的值. </p><h3 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h3><p>赋值语句是显式的赋值语句, 但是程序中还有很多地方会发生隐式的赋值行为: 函数调用会隐式地将调用参数的值赋值给函数的参数变量, 一个返回语句将隐式地将返回操作的值赋值给结果变量, 一个复合类型的字面字面量也会产生赋值行为.</p><p>不管是隐式还是显式地赋值, 在赋值语句左边的变量和右边最终求得的值必须有相同的数据类型. 更直白地说, 只有右边的值对于左边地变量时可赋值的, 赋值语句才是允许的. </p><p>对于两个值是否可以用<code>==</code>或<code>!=</code>进行相等比较的能力也和可赋值能力有关系: 对于任何类型的值的相等比较, 第二个值必须是对第一个变量值类型对应的变量是可赋值的, 反之亦然. </p><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>变量或表达式的类型定义了对应存储值的属性特征, 例如数值在内存中的存储大小(或者是元素的<code>bit</code>个数), 它们在内部是如何表达的, 是否支持一些操作符, 以及它们自己关联的方法集等.</p><p>一个类型声明语句创建了一个新的类型名称, 和现有类型就有相同的底层结构. 新命名提供了一种方式, 用来分隔不同概念的类型, 这样即使它们底层类型相同也是不兼容的. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type 类型名称 底层类型</span><br></pre></td></tr></table></figure><p>由于对于中文汉字, <code>Unicode</code>标志都是作为小写字母处理, 因此中文的命名默认不能导出.</p><p>对于每一个类型<code>T</code>, 都有一个对应的类型转换操作<code>T(x)</code>, 用于将<code>x</code>转为<code>T</code>类型(如果<code>T</code>是指针类型, 可能会需要用小括弧包括<code>T</code>, 比如<code>(*int)(0)</code>). 只有当两个类型的底层基础类型相同时, 才能允许这种转型操作, 或者是两者都是指向相同底层结构的指针类型, 这些转换只改变类型而不会影响值本身. </p><p>底层数据类型决定了内部结构和表达方式, 也决定是否可以像底层类型一样对内置运算符的支持.</p><p>通过<code>==</code>和<code>&lt;</code>之类的比较操作符, 命名类型的值可以与其相同类型的值或者底层类型相同的未命名类型的值相比较. </p><h2 id="包和文件"><a href="#包和文件" class="headerlink" title="包和文件"></a>包和文件</h2><p><code>Go</code>语言中的包和其他语言的库或模块的概念类似, 目的都是为了支持模块化, 封装, 单独编译和代码重用. 每个包都对应一个独立的命名空间. </p><p>在每个源文件的包声明前紧跟着的注释是包注释. 通常, 包注释的第一句应该是包的功能概要说明. 一个包通常只有一个源文件有包注释. </p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>在<code>Go</code>程序语言中, 每个包都是有一个全局唯一的导入路径. 导入语句中类似<code>gopl.io/ch2/tempconv</code>的字符串对应包的导入路径. <code>Go</code>语言的规范并没有定义这些字符串的具体含义或包来自哪里, 它们是由构建工具来解释的. 当使用<code>Go</code>语句自带的<code>go</code>工具箱时, 一个导入路径代表一个目录中的一个或多个<code>Go</code>源文件. </p><p>除了包的导入路径, 每个包还有一个包名, 包名一般是短小的名字(并不要求包名是唯一的), 包名在包的声明处指定. 按照惯例, 一个包的名字和包的导入路径的最后一个字段相同. </p><p>导入语句将导入的包绑定到一个短小的名字, 然后通过该短小的名字就可以引用包中导出的内容. 在默认情况下, 导入的包绑定到包声明语句指定的名字, 但是我们也可以绑定到另一个名字, 以避免名字冲突. </p><p>如果导入了一个包, 但是又没有使用该包将被当作一个编译错误处理. </p><h3 id="包的初始化"><a href="#包的初始化" class="headerlink" title="包的初始化"></a>包的初始化</h3><p>包的初始化首先是解决包级变量的依赖顺序, 然后按照包级变量声明出现的顺序依次初始化. </p><p>如果包中包含多个<code>.go</code>源文件, 它们将按照发给编译的顺序进行初始化, <code>Go</code>语言的构建工具首先会将<code>.go</code>文件根据文件名排序, 然后依次调用编译器编译. </p><p>对于在包级别声明的变量, 如果有初始化表达式则用表达式初始化, 还有一些没有初始化表达式的. 在这种情况下, 我们可以用一个特殊的<code>init</code>初始化函数来简化初始化工作. 每个文件都可以包含多个<code>init</code>初始化函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的<code>init</code>初始化函数除了不能被调用或引用之外, 其他行为和普通函数类似. 在每个文件中的<code>init</code>初始化函数, 在程序开始执行时按照它们声明的顺序被自动调用. </p><p>每个包在解决依赖的前提下, 以导入声明的顺序初始化, 每个包只会被初始化一次. 初始化工作是自下而上进行的, <code>main</code>包最后被初始化. 以这种形式, 可以确保在<code>main</code>函数执行之前, 所有依赖的包都已经完成初始化工作了. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  循环的一种写法</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> pc &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环的另外一种写法</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> pc &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>一个声明语句将程序中的实体和一个名字关联, 比如一个函数或一个变量. 声明语句的作用域是指源代码中可以有效使用这个名字的范围. </p><p>不要将作用域和生命周期混为一谈. 声明语句的作用域对应的是一个源代码的文本区域; 它是一个编译时的属性. 一个变量的生命周期是指程序运行时变量存在的有效时间段, 在此时区域内它可以被程序的其他部分引用; 是一个运行时的概念. </p><p>声明语句对应的词法域决定了作用域范围的大小. 对于内置的类型, 函数和常量, 比如<code>int</code>, <code>len</code>和<code>true</code>等是在全局作用域的, 因此可以在整个程序中直接使用. 任何在函数外部(也就是包级语法域)声明的名字可以在同一个包的任何源文件中访问. 对于导入的包, 则是对应源文件级的作用域, 因此只能在当前的文件中访问导入的包, 当前包的其他源文件无法访问在当前源文件导入的包. 还有许多声明语句, 例如函数中的变量, 则是局部作用域, 它只能在函数内部(甚至只能是局部的某些部分)访问. </p><p>当编译器遇到一个名字引用时, 将从最内层的词法域向全局的作用域查找其声明. 如果查找失败, 则报告<code>undeclared name</code>错误; 如果在内层和外层块都存在这个声明, 内层的将先被找到. 在这种情况下, 内层声明将覆盖外部声明, 使它不可访问. </p><p>在包级别, 声明的顺序和它们的作用域没有关系, 所以一个声明可以它自己或者跟在它后面的其他声明, 使我们可以声明递归或相互递归的类型和函数. 如果常量或变量声明引用它自己, 则编译器会报错.</p><h1 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读入命令行参数</span></span><br><span class="line">flag.Bool()</span><br><span class="line">flag.String()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用于更新每个标志参数对应变量的值(之前是默认值)</span></span><br><span class="line">flag.parse()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获得当前的工作目录</span></span><br><span class="line">os.Getwd()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go程序设计语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raspberry初始化</title>
      <link href="/2023/08/19/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Raspberry/Raspberry%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/08/19/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Raspberry/Raspberry%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h2 id="树莓派连接wifi和使用SSH连接树莓派"><a href="#树莓派连接wifi和使用SSH连接树莓派" class="headerlink" title="树莓派连接wifi和使用SSH连接树莓派"></a>树莓派连接<code>wifi</code>和使用<code>SSH</code>连接树莓派</h2><ol><li>在<code>SD</code>卡的根目录新建<code>wpa_supplicant.conf</code>文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">country=CN</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"> </span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;wifi-A&quot;</span><br><span class="line">psk=&quot;12345678&quot;</span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;wifi-B&quot;</span><br><span class="line">psk=&quot;12345678&quot;</span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;wifi-C&quot;</span><br><span class="line">psk=&quot;12345678&quot;</span><br><span class="line">key_mgmt=WPA-PSK</span><br><span class="line">priority=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树莓派使用<code>5G</code>的<code>wifi</code>可能出现问题, 建议使用<code>2.4G</code>的<code>wifi</code>. </p><p><code>ssid</code>和<code>psk</code>出现特殊字符和中文字符有可能连不上<code>wifi</code>.</p><p><code>priority</code>的值越大, 优先级越高.</p><p>树莓派启动时会自动把这个文件</p><ol start="2"><li>在<code>SD</code>卡的根目录新建<code>ssh</code>文件, 这个会让树莓派开启<code>ssh</code></li></ol><p><code>SD</code>不要在在用的时候进行插拔, 很容易损坏</p><h2 id="树莓派设置用户和密码"><a href="#树莓派设置用户和密码" class="headerlink" title="树莓派设置用户和密码"></a>树莓派设置用户和密码</h2><p>新的系统不再支持<code>pi&#39;</code>和<code>raspberry</code>, 需要自己往<code>SD</code>中写入东西. 新建<code>userconf</code>, 里面的内容<code>username:encrypted-password</code>.加密的密码用下面的内容生成. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;mypassword&#x27; | openssl passwd -6 -stdin</span><br></pre></td></tr></table></figure><h2 id="初始化root密码"><a href="#初始化root密码" class="headerlink" title="初始化root密码"></a>初始化<code>root</code>密码</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><h2 id="Linux命令别名和命令颜色显示"><a href="#Linux命令别名和命令颜色显示" class="headerlink" title="Linux命令别名和命令颜色显示"></a><code>Linux</code>命令别名和命令颜色显示</h2><p>修改<code>/etc/bash.bashrc</code>中文件可以对所有的用户生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alias ls=&#x27;ls --color=auto&#x27;</span><br><span class="line">alias ll=&#x27;ls -a --color=auto&#x27;</span><br><span class="line">alias grep=&#x27;grep --color=auto&#x27;</span><br><span class="line">alias fgrep=&#x27;fgrep --color=auto&#x27;</span><br><span class="line">alias egrep=&#x27;egrep --color=auto&#x27;</span><br></pre></td></tr></table></figure><h2 id="设置VIM"><a href="#设置VIM" class="headerlink" title="设置VIM"></a>设置<code>VIM</code></h2><p>修改<code>/etc/vim/vimrc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&quot; 设置行号</span><br><span class="line">set nu</span><br><span class="line">&quot; 始终显示状态栏</span><br><span class="line">set laststatus=2</span><br><span class="line">&quot; 高亮当前行</span><br><span class="line">set cul</span><br><span class="line">&quot; 设置tab的大小为4个空格</span><br><span class="line">set tabstop=4</span><br><span class="line">&quot; 回退删除4个空格</span><br><span class="line">set softtabstop=4</span><br><span class="line">&quot; 自动缩进</span><br><span class="line">set autoindent </span><br><span class="line">&quot; 搜索高亮</span><br><span class="line">set hlsearch</span><br><span class="line">&quot; 设置字体和大小</span><br><span class="line">set guifont=Courier\ New:h12</span><br><span class="line">&quot; 设置Vim主题</span><br><span class="line">colorscheme elflord </span><br><span class="line">&quot; 取消回撤文件</span><br><span class="line">set noundofile</span><br><span class="line">&quot; 取消备份文件 </span><br><span class="line">set nobackup</span><br><span class="line">&quot; 取消交换文件</span><br><span class="line">set noswapfile</span><br></pre></td></tr></table></figure><h2 id="设置DDNS"><a href="#设置DDNS" class="headerlink" title="设置DDNS"></a>设置<code>DDNS</code></h2><ol><li>在阿里云上添加一条<code>AAAA</code>的记录, 下面的<code>ipv6</code>地址随便填, 之后会由<code>DDNS</code>自动刷新</li><li>下载<code>github</code>上的<code>DDNS</code>, 填入阿里云的<code>accesskey</code></li><li>运行定时任务的脚本</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Raspberry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Raspberry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门</title>
      <link href="/2023/08/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p><code>Go</code>是编译型的语言. <code>Go</code>的工具链将程序的源文件转变成机器相关的原生二进制指令. 这些工具可以通过单一的<code>go</code>命令配合其子命令进行使用. </p><p><code>Go</code>代码是使用包来组织的, 包类似于其他语言中的库和模块. 一个包有一个或多个<code>.go</code>源文件组成, 放在一个文件夹中, 该文件夹的名字描述了包的作用. 每一个源文件的开始都用<code>package</code>声明, 指明这个文件属于哪个包. 后面跟着它导入的其他包的列表, 然后是存储在文件中的程序声明. </p><p>名为<code>main</code>的包比较特殊, 它用来定义一个独立的可执行程序, 而不是库. </p><p><code>Go</code>不需要在语句或声明后面使用分号结尾, 除非有多个语句或声明出现在同一行. </p><h2 id="Go的命令"><a href="#Go的命令" class="headerlink" title="Go的命令"></a><code>Go</code>的命令</h2><p><code>run</code>子命令, 它将一个或多个以<code>.go</code>为后缀的源文件进行编译, 链接, 然后运行生成的可执行文件. 执行完成之后可执行文件将会被删除. </p><p><code>build</code>子命令, 生成一个可执行文件.</p><p><code>doc</code>子命令, 查看函数的文档. </p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h2><p>注释以<code>//</code>开头. 习惯上, 在一个包声明前, 使用注释对其进行描述; 对于<code>main</code>包, 注释是一个或多个完整的句子, 用来对这个程序进行整体概括.</p><p><code>var</code>关键字用于声明变量. 变量可以在声明的时候初始化. 如果变量没有明确地初始化, 它将隐式地初始化为这个类型的空值. </p><p>符号<code>:=</code>是短变量声明的一部分, 这是定义一个或多个变量并根据它们的初始值为这些变量赋予适当类型的语句. </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s, sep <span class="type">string</span></span><br></pre></td></tr></table></figure><p>自增<code>++</code>和自减<code>--</code>是语句, 而不像<code>C</code>系的其他语言那样是表达式. 所以<code>j = i++</code>非法, 而且<code>++</code>和<code>--</code>都只能放在变量名后面, 因此<code>--i</code>也非法. </p><p><code>Go</code>语言只有<code>for</code>循环这一种循环语句. <code>for</code>循环有多种形式, 其中一种如下所示: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for initialization; condition; post &#123;</span><br><span class="line">// zero or more statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环三个部分不需要括号包围</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// a traditional &quot;while&quot; loop</span><br><span class="line">for condition &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// a traditional infinite loop</span><br><span class="line">for &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for</code>循环的另一种形式, 在某种数据类型的区间上遍历, 如字符串或切片.每次循环迭代, <code>range</code>产生一对值; 索引以及在该索引处的元素值. 如果不需要索引, 可以是使用空标识符<code>_</code>, 下划线, 空标识符可用于任何语法需要变量名但程序逻辑不需要的时候. 因为<code>Go</code>语言不允许使用无用的局部变量.</p><p>声明一种变量有好几种方式, 下面这些都是等价的:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>第一种形式, 是一条短变量声明, 最简洁, 但只能用在函数内部, 而不能用于包变量. 第二种形式依赖于字符串的默认初始化零值机制, 被初始化为””. 第四种形式显示地表明变量的类型, 当变量类型与初值类型相同时, 类型冗余, 但如果两者类型不同, 变量类型就必须了.</p><h2 id="查找重复的行"><a href="#查找重复的行" class="headerlink" title="查找重复的行"></a>查找重复的行</h2><p>正如<code>for</code>循环一样, <code>if</code>语句条件两边也不加括号, 但是主体部分需要加. </p><p><code>map</code>存储了键<code>/</code>值的集合, 对集合元素, 提供常数时间的存, 取或测试操作. 键可以是任意类型, 只要其值能用<code>==</code>运算符比较; 值则可以是任意类型. 内置函数<code>make</code>创建空<code>map</code>, 此外, 它还有别的作用.</p><p><code>map</code>中包含某个键时不用担心, 首次读到某个值时, 键将会被赋值为其类型的零值.</p><p><code>map</code>是一个由<code>make</code>函数创建的数据结构的引用. <code>map</code>作为参数传递给某函数时, 该函数接收这个引用的一份拷贝, 被调用函数对<code>map</code>低层数据结构的任何修改, 调用者函数都可以通过持有的<code>map</code>引用看到. </p><h2 id="GIF动画"><a href="#GIF动画" class="headerlink" title="GIF动画"></a><code>GIF</code>动画</h2><p>当我们<code>import</code>了一个包路径包含了多个单词的<code>package</code>时, 比如<code>image/color</code>, 通常我们只需要用最后那个单词表示这个包就可以. </p><p>常量是指在程序编译后运行时始终不会发生变化的值. 目前常量声明的值必须是一个数字值, 字符串或者一个固定的<code>boolean</code>值. </p><p><code>[]color.Color&#123;...&#125;</code>和<code>gif.GIF&#123;...&#125;</code>是复合声明的一种写法. 这里前者生成的是一个<code>slice</code>切片, 后者生成的是一个<code>struct</code>结构体. </p><p><code>struct</code>是一组值或者叫字段的集合, 不同的类型集合在一个<code>struct</code>可以让我们以一个统一的单元进行处理, <code>struct</code>内部的变量可以以一个点<code>.</code>来进行访问. </p><h2 id="并发获得多个URL"><a href="#并发获得多个URL" class="headerlink" title="并发获得多个URL"></a>并发获得多个<code>URL</code></h2><p><code>goroutine</code>是一种函数的并发执行方式, 而<code>channel</code>是用来在<code>goroutine</code>之前进行参数传递. </p><p><code>main</code>函数本身也运行在一个<code>goroutine</code>中, 而<code>go function</code>则表示创建一个新的<code>goroutine</code>, 并在新的<code>goroutine</code>中执行这个函数. </p><p>当一个<code>goroutine</code>尝试在一个<code>channel</code>上做<code>send</code>或者<code>receive</code>操作时, 这个<code>goroutine</code>会堵塞在调用处, 直到另一个<code>goroutine</code>往这个<code>channel</code>里写入, 或者接收值, 这样两个<code>goroutine</code>才会继续执行<code>channel</code>操作之后的逻辑. </p><h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a><code>Web</code>服务</h2><p><code>Go</code>允许一个简单的语句(如一个局部变量声明)写在<code>if</code>条件的前面, 这在错误处理的时候特别有用, 这样可以缩小<code>err</code>变量的作用域. </p><h2 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h2><p><code>switch</code>语句: <code>Go</code>语言并不需要显式地在每一个<code>case</code>后写<code>break</code>, 语言默认执行完<code>case</code>后的逻辑语句会自动退出. 如果需要贯穿, 需要自己显式地写上一个<code>fallthrough</code>语句来覆盖默认行为.</p><p><code>label</code>语句: 允许<code>break</code>和<code>continue</code>跳过任意层的循环, 调到<code>label</code>处.</p><p>命名类型: 类型声明使得我们可以很方便地给一个特殊类型一个名字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p Point</span><br></pre></td></tr></table></figure><p>指针: <code>Go</code>语言提供了指针. 指针是一种直接存储了变量内存地址的数据类型. 指针是可见的内存地址, <code>&amp;</code>操作符可以返回一个变量的内存地址, 并且<code>*</code>操作符可以获取指针指向的变量内容, 但是在<code>Go</code>语言中没有指针运算, 也就是不能像<code>c</code>语言里可以对指针进行加或减操作. </p><p>方法和接口: 方法是和命名类型关联的一类函数. 接口是一种抽象类型, 这种类型可以让我们以同样的方式来处理不同的固有类型, 不用关心它们的具体实现. </p><p>多行注释: <code>/* ... */</code>. </p><h1 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以打印以空格间隔的一个或多个值, 并在最后添加一个换行符, 从而输出一整行</span></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="comment">// os.Args变量是一个字符串的切片. os包提供了一些函数和变量, 以与平台无关的方式和操作系统打交道. 命令行参数以os包中Args名字的变量提供程序访问, 在os包外面, 使用os.Args这个名字. os.Args的第一个元素是os.Args[0], 它是命令本身的名字; 另外的元素是程序开始执行时的参数 </span></span><br><span class="line">os.Args</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该变量重程序的标准输入中读取内容. 每次调用input.Scan()函数, 即读入下一行, 并移除行末的换行符; 读取的内容可以调用input.Text()得到. Scan函数在读到一行时返回true, 在无输入时返回false</span></span><br><span class="line">input := bufio.NewScanner(os.Stdin)</span><br><span class="line">input.Scan()</span><br><span class="line">input.Text()</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Printf函数对一些表达式产生格式化输出</span></span><br><span class="line">fmt.Printf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// %d 十进制整数</span></span><br><span class="line"><span class="comment">// %x, %o, %b 十六进制, 八进制, 二进制</span></span><br><span class="line"><span class="comment">// %f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00</span></span><br><span class="line"><span class="comment">// %t 布尔: true或false</span></span><br><span class="line"><span class="comment">// %c 字符(rune)(Unicode码点)</span></span><br><span class="line"><span class="comment">// %s 字符串</span></span><br><span class="line"><span class="comment">// %q 带双引号的字符串&quot;abc&quot;或带单引号的字符&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// %v 变量的自然形式</span></span><br><span class="line"><span class="comment">// %T 变量的类型</span></span><br><span class="line"><span class="comment">// %% 字面上的百分号标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// os.Open返回两个值. 第一个值是被打开的文件(*os.File), 其后被Scanner读取. os.Open返回第二个值是内置error类型的值. </span></span><br><span class="line">os.Open()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件中写入字符串, 输入和输出流也是文件</span></span><br><span class="line">fmt.Fprintf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取指定文件的全部内容, 返回一个字节切片, 必须使用string, 才能用strings.Split进行分割</span></span><br><span class="line">ioutil.ReadFile()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把字符串切割成子串的切片</span></span><br><span class="line">strings.Split()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把字符串切片以指定分隔符连在一起</span></span><br><span class="line">strings.Join()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个字符串</span></span><br><span class="line">fmt.Sprintf(format <span class="type">string</span>, a ...any) <span class="type">string</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Go程序设计语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git进阶用法</title>
      <link href="/2023/08/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git/Git%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/"/>
      <url>/2023/08/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git/Git%E8%BF%9B%E9%98%B6%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><code>Git</code>进阶用法</p><span id="more"></span><h1 id="服务器上的Git"><a href="#服务器上的Git" class="headerlink" title="服务器上的Git"></a>服务器上的<code>Git</code></h1><p>一个远程仓库通常只是一个裸仓库<code>--</code>即一个没有当前工作目录的仓库. 因为该仓库仅仅作为合作媒介, 不需要从磁盘检查快照; 存放的只有<code>Git</code>的资料. 简单的说, 裸仓库就是你目录内的<code>.git</code>子目录内容, 不包含其他资料. </p><h2 id="常用的Git"><a href="#常用的Git" class="headerlink" title="常用的Git"></a>常用的<code>Git</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash 分支名</span><br><span class="line"></span><br><span class="line">--squash: 接受被合并的分支上的所有工作, 并将其压缩至一个变更集, 是仓库变成一个未发生合并的状态, 可以引入另外一个分支的所有改动或自己做改动, 然后再commit. 有点像rebase</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从别的拉取</span></span><br><span class="line">git pull &lt;remote&gt; &lt;branchname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时拉取, 不保存远程仓库</span></span><br><span class="line">git pull &lt;url&gt; [branchname]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不写branchname, 默认是HEAD</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看在branch1, 但不在branch2的提交, 等价于branch2..branch1</span></span><br><span class="line">git log branch1 [-p] --not branch2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找出两个分支的公共祖先</span></span><br><span class="line">git merge-base &lt;branch1&gt; &lt;branch2&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">branch2与公共祖先的差别</span></span><br><span class="line">git diff &lt;branch1&gt;...&lt;branch2&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拣选操作, Git中的拣选类似于对特定的某次提交的变基. 它会提取该提交的补丁, 之后尝试将其重新应用到当前分支上</span></span><br><span class="line">git cherry-pick &lt;commit&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将Git项目打包, 注意不会包含.git文件夹</span></span><br><span class="line">git archive master --prefix=&#x27;project/&#x27; | gzip &gt; `git describe master`.tar.gz</span><br><span class="line">git archive master --prefix=&#x27;project/&#x27; --format=zip &gt; `git describe master`.zip</span><br></pre></td></tr></table></figure><h1 id="Git工具"><a href="#Git工具" class="headerlink" title="Git工具"></a><code>Git</code>工具</h1>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的使用</title>
      <link href="/2023/08/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git/Git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/08/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><code>Git</code>的介绍和使用</p><span id="more"></span><h1 id="Git的介绍"><a href="#Git的介绍" class="headerlink" title="Git的介绍"></a><code>Git</code>的介绍</h1><p><strong>版本控制系统</strong>: 版本控制是一种记录一个或若干文件内容变化, 以便将来查阅特定版本修订情况的系统.</p><h2 id="Git的特点"><a href="#Git的特点" class="headerlink" title="Git的特点"></a><code>Git</code>的特点</h2><h3 id="直接记录快照-而非差异比较"><a href="#直接记录快照-而非差异比较" class="headerlink" title="直接记录快照, 而非差异比较"></a>直接记录快照, 而非差异比较</h3><p>在<code>Git</code>中, 每当你提交更新或保存项目状态时, 它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引. 为了效率, 如果文件没有修改, <code>Git</code>不再重新存储该文件, 而是只保留一个连接指向之前存储的文件. <code>Git</code>对待数据更像是一个<strong>快照流</strong>. </p><h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3><p>在<code>Git</code>中的绝大多数操作都只需要访问本地文件和资源, 一般不需要来自网络上其他计算机得信息. 因为你在本地磁盘上就有项目的完整历史. 例如, 要浏览项目的历史, <code>Git</code>不需要外连到服务器去获取历史, 然后在显示出来, 它只需要直接从本地数据库中读取. </p><h3 id="Git保证完整性"><a href="#Git保证完整性" class="headerlink" title="Git保证完整性"></a><code>Git</code>保证完整性</h3><p><code>Git</code>中所有的数据都在存储前计算校验和, 然后以校验和来引用. 这意味着不可能在<code>Git</code>不知情时更改任何文件内容或目录内容.</p><h3 id="Git一般只添加数据"><a href="#Git一般只添加数据" class="headerlink" title="Git一般只添加数据"></a><code>Git</code>一般只添加数据</h3><p>你执行的<code>Git</code>操作, 几乎只往<code>Git</code>数据库中添加数据. 同别的<code>VCS</code>一样, 未提交更新时有可能丢失或弄乱修改的内容. 但是一旦你提交快照到<code>Git</code>中, 就难以再丢失数据. </p><h2 id="Git的配置"><a href="#Git的配置" class="headerlink" title="Git的配置"></a><code>Git</code>的配置</h2><p><code>Git</code>的配置可以保存在三个地方.</p><ul><li><code>/etc/gitconfig</code>文件: 包含系统上每一个用户以及他们仓库的通用配置. 如果在执行<code>git config</code>时带上<code>--system</code>选项, 那么它就会读写该文件中的配置变量. </li><li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>文件: 只针对当前用户. 你可以传递<code>--global</code>选项让<code>Git</code>读写此文件, 这会对你系统上该用户的所有仓库有效. </li><li>当前使用仓库的<code>Git</code>目录中的<code>config</code>文件(<code>.git/config</code>): 针对该仓库. 你可以传递<code>--local</code>选项让<code>Git</code>强制读写该文件, 虽然默认情况下用的就是它. (这个只有你进入某个<code>Git</code>仓库中才能让该选项生效).</li></ul><p>每一个级别会覆盖上一级别的配置, 所以<code>.git/config</code>的配置会覆盖<code>/etc/gitconfig</code>中的配置变量.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所在目录的所有配置以及它们所在的文件</span></span><br><span class="line">git config --list --show-origin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置git配置</span></span><br><span class="line">git config [--system|--global|--local] &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询git配置</span></span><br><span class="line">git config [--show-origin] &lt;key&gt;</span><br></pre></td></tr></table></figure><h2 id="获得Git文档"><a href="#获得Git文档" class="headerlink" title="获得Git文档"></a>获得<code>Git</code>文档</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获得详细的文档</span></span><br><span class="line">git help &lt;verb&gt;</span><br><span class="line">git &lt;verb&gt; --help</span><br><span class="line">man git-&lt;verb&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获得简略的文档</span></span><br><span class="line">git &lt;verb&gt; -h</span><br></pre></td></tr></table></figure><h1 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a><code>Git</code>的使用</h1><h2 id="获得Git仓库"><a href="#获得Git仓库" class="headerlink" title="获得Git仓库"></a>获得<code>Git</code>仓库</h2><p>通常有两种获取<code>Git</code>项目仓库的方式:</p><ol><li>将尚未进行版本控制的本地目录装换为<code>Git</code>仓库</li><li>从其塔服务器<strong>克隆</strong>一个已存在的<code>Git</code>仓库</li></ol><h3 id="在已存在目录中初始化仓库"><a href="#在已存在目录中初始化仓库" class="headerlink" title="在已存在目录中初始化仓库"></a>在已存在目录中初始化仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init [仓库名]</span><br></pre></td></tr></table></figure><p>不写仓库名,将会在当前目录下创建<code>.git</code>的子目录, 从而管理当前目录. 但我们现在仅仅做了一个初始化操作, 并没有跟踪任何文件. </p><h3 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址 [仓库名]</span><br></pre></td></tr></table></figure><p>如果不写仓库名, 会以远程仓库命名. 这个命令, 会创建一个目录, 并在其中生成<code>.git</code>子目录. 当执行<code>git clone</code>命令的时候, 默认配置下远程仓库中的每一个文件的每一个版本都将被拉取下来. <code>Git</code>支持<code>https://</code>协议, <code>git://</code>协议和<code>SSH</code>传输协议, 例如<code>user@server:path/to/repo.git</code>.</p><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>工作目录中的每一个文件都不外乎这两种状态: <strong>已跟踪</strong>或<strong>未跟踪</strong>. <strong>已跟踪</strong>的文件是指那些被纳入了版本控制的文件. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查当前文件状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跟踪新文件或暂存已修改的文件</span></span><br><span class="line">git add 文件或目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复文件</span></span><br><span class="line">git restore [--staged] [-s tree] 文件或目录</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果指定--staged从<span class="built_in">head</span>或tree恢复index</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果指定-s, 将从tree恢复工作区</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不指定--staged和-s, 将从index恢复工作区</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">状态简介</span></span><br><span class="line">git status -s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已暂存和未暂存的修改</span></span><br><span class="line">git diff [--staged]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不加--staged, 比较的是工作区和暂存区的区别</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加--staged, 比较的时候暂存区和最后一次提交的区别</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交更新</span></span><br><span class="line">git commit [--amend] [-m 提交信息] [-a]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a: Git会自动把所有已跟踪过的文件暂存起来一并提交</span></span><br><span class="line">--amend: 取代上一次提交</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除文件</span></span><br><span class="line">git rm [-f]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个和自己手动用<span class="built_in">rm</span>移除的区别是, 这个命令会自己将移除的文件提交到暂存区, 如果自己用<span class="built_in">rm</span>, 需要自己手动添加到暂存区</span></span><br><span class="line">-f: 如果文件在工作区或暂存区被修改过, 必须要使用-f, 这是为了防止未提交的修改被删除</span><br><span class="line">--cached: 仅从index移除, 而不从工作区移除, 可以用来取消跟踪文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移动文件(重命名文件)</span></span><br><span class="line">git mv file_from file_to</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这条命令相当于, 所以使用<span class="built_in">mv</span>命令时, 记得补上后面两条</span></span><br><span class="line">mv file_from file_to</span><br><span class="line">git rm file_from</span><br><span class="line">git add file_to</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看提交历史</span></span><br><span class="line">git log [--oneline --graph] [--since|--until=&quot;yyyy-MM-dd&quot;] [--author] [--grep=&quot;&quot;[--grep=&quot;&quot;]...] [--all-match] [-S function_name] [--no-merges] [--] [dir] </span><br><span class="line"></span><br><span class="line">--: 是用来隔开参数和目录的, 没有别的作用</span><br></pre></td></tr></table></figure><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>使用<code>.gitignore</code>来忽略某些文件. 这个文件是放在仓库的根目录下的, 还可以给子目录添加<code>.gitignore</code>, 子目录下的<code>.gitignore</code>只会对子目录有效. 要养成一个开始就为新仓库设置好<code>.gitignore</code>文件的习惯, 以免将来误提交无用的文件. </p><h1 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出远程仓库</span></span><br><span class="line">git remote [-v]</span><br><span class="line"></span><br><span class="line">-v:  列出url</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加远程仓库</span></span><br><span class="line">git remote add &lt;short&gt; &lt;url&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库抓取与拉取, 这个命令会访问远程仓库, 从中拉取所有你还没有的数据. 执行完成之后, 你将会拥有那个远程仓库中所有分支的引用, 可以随时查看, 还会更新远程跟踪分支的位置</span></span><br><span class="line">git fetch &lt;remote&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送到远程仓库</span></span><br><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br><span class="line">git push &lt;remote&gt; &lt;localbranch&gt;:&lt;remotebranch&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程仓库信息, 可以查看远程仓库当前处于那个分支, 下一次抓取将会存储的分支, 远程已经删除的分支, 这个是实时的, 不需要fetch</span></span><br><span class="line">git remote show &lt;remote&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除存储在本地, 但远端已经删除的分支</span></span><br><span class="line">git remote prune &lt;remote&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">远程仓库从命名</span></span><br><span class="line">git remote rename &lt;oldname&gt; &lt;newname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除远程仓库</span></span><br><span class="line">git remote remove &lt;remote&gt;</span><br></pre></td></tr></table></figure><h1 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出标签</span></span><br><span class="line">git tag [-l &quot;blob表达式&quot;] [-n]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建轻量标签</span></span><br><span class="line">git tag &lt;tagname&gt; [hash]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建附注标签</span></span><br><span class="line">git tag -a &lt;tagname&gt; -m &quot;注释&quot; [hash]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看标签详情</span></span><br><span class="line">git show &lt;tagname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除标签</span></span><br><span class="line">git tag -d &lt;tagname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送标签到远端</span></span><br><span class="line">git push origin &lt;tagname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远端标签</span></span><br><span class="line">git push origin --delete &lt;tagname&gt;</span><br><span class="line">git push &lt;remote&gt; :[refs/tags/]&lt;tagname&gt;</span><br></pre></td></tr></table></figure><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a><code>Git</code>分支</h1><p><code>Git</code>的分支, 其实本质上仅仅是指向提交对象的可变指针. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建分支</span></span><br><span class="line">git branch &lt;branchname&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支, 在切换分支前, 需要保证工作目录和暂存区的干净, 如果tree不存在, 有且只有一个同名的本地远程分支, 将会自动创建分支, 并跟踪本地远程跟踪分支</span></span><br><span class="line">git checkout &lt;tree&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并切换分支, 如果有本地远程分支, 会自动跟踪</span></span><br><span class="line">git checkout -b &lt;newbranchname&gt; [本地远程分支]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并分支</span></span><br><span class="line">git merge &lt;需要被合并的分支&gt;</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看分支</span></span><br><span class="line">git branch [-l &lt;pattern&gt;] [-v] [--merged|--no-merged [commit]</span><br><span class="line"></span><br><span class="line">-v: 查看提交信息, 以及与本地远程分支的关系(领先或落后)</span><br><span class="line">--merged: 过滤出已经合并到当前分支的分支</span><br><span class="line">--no-merged: 过滤出尚未合并到当前分支的分支</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换跟踪分支</span></span><br><span class="line">git branch -u &lt;本地远程分支&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看跟踪分支, 这里的数据来自与从每个服务器最后一次抓取的数据. 这个命令并没有连接服务器, 它只会根据本地缓存的数据. 如果需要统计最新的领先与落后数字, 需要在运行此命令之前抓取所有的远程仓库. git fetch --all; git branch -vv</span></span><br><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h1 id="git变基"><a href="#git变基" class="headerlink" title="git变基"></a><code>git</code>变基</h1><p>变基是将一系列提交按照原有次序依次应用到另一分支上, 而合并是把最终结果合并在一起. </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不写tree, 默认是当前<span class="built_in">head</span>执行的分支</span></span><br><span class="line">git rebase 基底 [tree]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个会选中在tree2的, 但没在tree1中的提交</span></span><br><span class="line">git rebase --onto 基底 tree1 tree2</span><br></pre></td></tr></table></figure><h2 id="变基的风险"><a href="#变基的风险" class="headerlink" title="变基的风险"></a>变基的风险</h2><p>如果提交存在于你的仓库之外, 而别人可能基于这些提交进行开发, 那么不要执行变基. </p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker实践</title>
      <link href="/2023/08/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Docker/Docker%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/08/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Docker/Docker%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><code>Docker</code>使用的实践</p><span id="more"></span><h1 id="实践中遇到的问题"><a href="#实践中遇到的问题" class="headerlink" title="实践中遇到的问题"></a>实践中遇到的问题</h1><h2 id="容器时间不对"><a href="#容器时间不对" class="headerlink" title="容器时间不对"></a>容器时间不对</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决方法一</span></span><br><span class="line">docker cp -L /etc/localtime CONTAINER:/etc/localtime</span><br><span class="line">echo &#x27;Asia/Shanghai&#x27; &gt;/etc/timezone</span><br><span class="line"></span><br><span class="line">`-L`表示复制实际的内容到`/etc/localtime`, 而不是软连接. 第一步可以保证`shell`的时间正常, 第二步保证其他应用的时间正常.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决方法二</span></span><br><span class="line">docker [CONTAINER] (create|run) -v /etc/timezone:/etc/timezone:ro -v /etc/localtime:/etc/localtime:ro CONTAINER</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决办法三</span></span><br><span class="line">ENV TimeZone=Asia/Shanghai</span><br><span class="line">RUN apt update \</span><br><span class="line">&amp;&amp; apt install -y tzdata</span><br><span class="line">&amp;&amp; cp /usr/share/zoneinfo/$TimeZone /etc/localtime &amp;&amp; echo $TimeZone &gt; /etc/timezone</span><br><span class="line">&amp;&amp; rm -rf /var/cache/apt &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line">删除/var/cache/apt是为了删除缓存, 删除/var/lib/apt/lists/*是为了删除仓库的本地索引</span><br></pre></td></tr></table></figure><h2 id="解决容器无法输入中文"><a href="#解决容器无法输入中文" class="headerlink" title="解决容器无法输入中文"></a>解决容器无法输入中文</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决方法一</span></span><br><span class="line">/etc/profile中最后加上, 需要重启</span><br><span class="line">export LANG=C.UTF-08</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决方法二</span></span><br><span class="line">docker [CONTAINER] (create|run) -e LANG=C.UTF-8 CONTAINER</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解决方法三</span></span><br><span class="line">ENV LANG=&quot;C.UTF-8&quot;</span><br></pre></td></tr></table></figure><h2 id="Docker容器无法使用systemctl"><a href="#Docker容器无法使用systemctl" class="headerlink" title="Docker容器无法使用systemctl"></a><code>Docker</code>容器无法使用<code>systemctl</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尽量不要使用systemd, 这个非常不安全, 需要开启特权, centos有init, 但ubuntu没有init, 需要自己通过Dockerfile装</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">centos</span></span><br><span class="line">docker [container] (create|run) -tid --privileged=true CONTAINER:TAG /usr/sbin/init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ubuntu</span></span><br><span class="line">docker [container] (create|run) -tid --privileged=true CONTAINER:TAG /sbin/init</span><br></pre></td></tr></table></figure><p>尽量使用自己写的脚本去启动.</p><h2 id="容器无法退出"><a href="#容器无法退出" class="headerlink" title="容器无法退出"></a>容器无法退出</h2><p><code>CTRL+Q+P</code>可以退出容器, 但不关闭容器. 可以在使用<code>CTRL+D</code>无效的时候使用.</p><h2 id="开启SSH"><a href="#开启SSH" class="headerlink" title="开启SSH"></a>开启SSH</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt install -y openssh-server</span><br><span class="line">mkdir -p /var/run/sshd</span><br><span class="line">修改/etc/ssh/sshd为允许root登录(可以用sed或awk代替)</span><br><span class="line">passwd(echo &quot;username:password&quot; | chpasswd或echo password | passwd --stdin username)</span><br><span class="line">docker [container] commit [-m 描述信息] CONTAINER NAME:TAG</span><br><span class="line">docker [container] -d -p 10022:22 CONTAINER:TAG /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure><p>也可以把<code>/usr/sbin/sshd</code>写入到一个脚本中, 在<code>Dockerfile</code>中设置<code>CMD</code>来默认启动.</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker的使用</title>
      <link href="/2023/07/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Docker/Docker%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/07/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Docker/Docker%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p> 介绍<code>Docker</code>以及<code>Docker</code>中常用的命令</p><span id="more"></span><p><code>Docker</code>是基于<code>Go</code>语言实现的开源容器项目. <code>Docker</code>项目已经加入了<code>Linux</code>基金会, 并遵循<code>Apache 2.0</code>协议, 全部开源代码均在<code>https://github.com/docker</code>项目仓库进行维护.</p><h2 id="Dokder的作用"><a href="#Dokder的作用" class="headerlink" title="Dokder的作用"></a><code>Dokder</code>的作用</h2><p>把一个应用组件打包成一个镜像, 让这个镜像可以在任何安装了<code>Docker</code>的环境上运行. 这个应用组件可以是一个<code>Web</code>应用, 一个编译环境, 也可以是一套数据库平台服务, 甚至是一个操作系统或集群.</p><h3 id="Docker的作用原理"><a href="#Docker的作用原理" class="headerlink" title="Docker的作用原理"></a><code>Docker</code>的作用原理</h3><p>创建容器. 让一个应用在容器中运行. 不同的容器相互隔离, 容器之间也可以通过网络相互通信. 容器的创建和停止十分迅速, 几乎跟创建和终止原生应用一致; 另外, 容器自身对系统资源的额外需求也十分有限, 远远低于传统虚拟机.</p><h3 id="Docker与虚拟机比较"><a href="#Docker与虚拟机比较" class="headerlink" title="Docker与虚拟机比较"></a><code>Docker</code>与虚拟机比较</h3><p><code>Docker</code>容器很快, 启动和停止可以在秒级实现, 这相比传统的虚拟机方式(数分钟)要快得多.</p><p><code>Docker</code>容器对系统资源需求henshao, 一台主机可以同时运行数千个<code>Docker</code>容器.</p><p><code>Docker</code>通过类似<code>Git</code>设计理念的操作来方便用户获取, 分发和更新应用镜像, 存储复用, 增量更新.</p><h3 id="Docker中核心概念"><a href="#Docker中核心概念" class="headerlink" title="Docker中核心概念"></a><code>Docker</code>中核心概念</h3><h4 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a><code>Docker</code>镜像</h4><p><code>Docker</code>镜像类似于虚拟机镜像, 是创建<code>Docker</code>容器的基础.</p><h4 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a><code>Docker</code>容器</h4><p><code>Docker</code>容器类似于一个轻量级的沙箱, <code>Docker</code>利用容器来运行和隔离应用. 容器是从镜像创建的应用运行实例. 它可以创建, 开始, 停止, 删除, 而这些容器都是彼此相互隔离, 互不可见的.</p><h4 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a><code>Docker</code>仓库</h4><p><code>Docker</code>仓库类似与代码仓库, 是<code>Docker</code>集中存放镜像文件的场所.</p><h2 id="Docker使用"><a href="#Docker使用" class="headerlink" title="Docker使用"></a><code>Docker</code>使用</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p><code>Docker</code>运行容器前需要本地存在的镜像, 如果镜像不存在, <code>Docker</code>会尝试从默认镜像仓库下载.</p><h4 id="获得镜像"><a href="#获得镜像" class="headerlink" title="获得镜像"></a>获得镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker [image] pull NAME[:TAG]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如</span></span><br><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure><p>NAME是镜像仓库名称(用来区分镜像), TAG是镜像的标签(往往用来表示版本信息). 如果不显示指定TAG, 则默认会选择latest标签, 这回下载仓库中最新版本的镜像.</p><p>镜像文件一般由若干层组成, 每一层有一个唯一的id, 当不同的镜像包活相同的层时, 本地仅存储了层的一份内容, 减少了存储空间.</p><h4 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker images </span><br><span class="line"></span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>镜像大小信息只是表示了该镜像的逻辑体积大小, 实际由于相同的镜像层本地只会存储一份, 物理上占用的存储空间会小于各镜像逻辑体积之和.</p><h4 id="创建镜像标签副本"><a href="#创建镜像标签副本" class="headerlink" title="创建镜像标签副本"></a>创建镜像标签副本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] tag 已存在的镜像名:TAG 新的镜像名:新的TAG</span><br></pre></td></tr></table></figure><h4 id="查看镜像详情"><a href="#查看镜像详情" class="headerlink" title="查看镜像详情"></a>查看镜像详情</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] inspect NAME:TAG</span><br></pre></td></tr></table></figure><h4 id="查看镜像的层数"><a href="#查看镜像的层数" class="headerlink" title="查看镜像的层数"></a>查看镜像的层数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] history NAME:TAG</span><br></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rmi NAME:TAG [NAME:TAG...]</span><br><span class="line"></span><br><span class="line">docker image rm NAME:TAG [NAME:TAG...]</span><br></pre></td></tr></table></figure><p>这个会只会删除这个TAG, 只有当只有一个镜像时, 才会删除镜像.</p><h4 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h4><h5 id="基于已有容器创建"><a href="#基于已有容器创建" class="headerlink" title="基于已有容器创建"></a>基于已有容器创建</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] commit [-m &quot;提交信息&quot;] CONTAINERID [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><h5 id="基于本地容器模版导入"><a href="#基于本地容器模版导入" class="headerlink" title="基于本地容器模版导入"></a>基于本地容器模版导入</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] import [-m &quot;提交信息&quot;] file [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><h5 id="基于Dockerfile创建"><a href="#基于Dockerfile创建" class="headerlink" title="基于Dockerfile创建"></a>基于<code>Dockerfile</code>创建</h5><p>基于<code>Dockerfile</code>创建是最常见的方式. <code>Dockerfile</code>是一个文本文件, 利用给定的指令描述基于父镜像创建新镜像的过程.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:strech-slim</span><br><span class="line"></span><br><span class="line">LABEL version=&quot;1.0&quot; maintainer=&quot;docker user &lt;docker_user@github&gt;&quot;</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line"> apt-get install -y python3 &amp;&amp; \</span><br><span class="line"> apt-get clean &amp;&amp; \</span><br><span class="line"> rm -rf /var/lib/apt/lists/*使用</span><br></pre></td></tr></table></figure><p>使用<code>dockerfile</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] build -t dockerfile</span><br></pre></td></tr></table></figure><h4 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h4><h5 id="存出镜像"><a href="#存出镜像" class="headerlink" title="存出镜像"></a>存出镜像</h5><p>将镜像保存为一个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] save -o 文件名 NAME:TAG</span><br></pre></td></tr></table></figure><h5 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h5><p>从文件中导入镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] load -i 文件名</span><br></pre></td></tr></table></figure><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是镜像的一个运行实例. 如果认为虚拟机是模拟运行的一整套操作系统(包括内核, 应用运行态环境和其他系统环境)和跑在上面的应用. 那么<code>Docker</code>容器就是独立运行的一个(或一组)应用, 以及它们所必需的运行环境. 容器名是唯一的, 不能使用相同的容器名.</p><h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker [container] create [OPTION] NAME:TAG</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用选项</span></span><br><span class="line">-i 保持容器的标准输入打开</span><br><span class="line">-t 分配一个伪终端, 并将其绑定到容器的标准输入上</span><br><span class="line">-d 保持后台运行</span><br><span class="line">-p 指定如何映射到本地主机端口</span><br><span class="line">--name (容器名) 给容器取别名</span><br><span class="line">--rm=true|false 容器退出后, 是否删除容器</span><br><span class="line">--restart=true|false 容器的重启策略</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建的容器处于停止状态, 需要使用使用启动容器命令才能使用.</p><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] start 容器ID</span><br></pre></td></tr></table></figure><p>进程号可以通过<code>docker ps -a</code>获得</p><h4 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] stop [-t 时间] 容器ID</span><br></pre></td></tr></table></figure><p>stop该命令会首先先容器发送<code>STGTERM</code>信号, 等待一段超时时间后(默认为10秒), 再发送<code>SIGKILL</code>信号终止容器.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] kill 容器ID</span><br></pre></td></tr></table></figure><p>直接发送<code>SIGKILL</code>强行终止容器</p><h4 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] run [OPTION] NAME:TAG [命令] </span><br></pre></td></tr></table></figure><p>等价于执行<code>docker [container] create</code>, 再执行<code>docker [container] start</code>命令. 命令执行完毕后容器被自动终止.</p><h4 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] restart CONTAINER</span><br></pre></td></tr></table></figure><h4 id="容器重命令"><a href="#容器重命令" class="headerlink" title="容器重命令"></a>容器重命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] rename CONTAINER NEWNAME</span><br></pre></td></tr></table></figure><h4 id="查看容器状态"><a href="#查看容器状态" class="headerlink" title="查看容器状态"></a>查看容器状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps [-a]</span><br><span class="line"></span><br><span class="line">docker container ls [-a]</span><br></pre></td></tr></table></figure><h4 id="查看容器输出"><a href="#查看容器输出" class="headerlink" title="查看容器输出"></a>查看容器输出</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker [container] logs</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用选项</span></span><br><span class="line">-t 显示时间戳信息</span><br></pre></td></tr></table></figure><h4 id="暂停和恢复容器"><a href="#暂停和恢复容器" class="headerlink" title="暂停和恢复容器"></a>暂停和恢复容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker [container] pause 容器名</span><br><span class="line"></span><br><span class="line">docker [container] unpause 容器名</span><br></pre></td></tr></table></figure><h4 id="清除处于停止状态的容器"><a href="#清除处于停止状态的容器" class="headerlink" title="清除处于停止状态的容器"></a>清除处于停止状态的容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><h5 id="进入原先的程序"><a href="#进入原先的程序" class="headerlink" title="进入原先的程序"></a>进入原先的程序</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] attach 容器名</span><br></pre></td></tr></table></figure><p>如果在这个程序中退出, 容器会终止.</p><h5 id="开启新的程序"><a href="#开启新的程序" class="headerlink" title="开启新的程序"></a>开启新的程序</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] exec [-it] 容器名 COMMAND [ARG...]</span><br></pre></td></tr></table></figure><p>如果在这个程序中退出, 容器不会退出, 最开始的程序还在运行.</p><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker [container] rm [OPTION] 容器ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用选项</span></span><br><span class="line">-f 强行终止容器,并删除容器</span><br></pre></td></tr></table></figure><p>如果不加<code>-f</code>选项, 只能删除退出状态的容器.</p><h4 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h4><h5 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h5><p>导出一个已经创建的容器到一个文件, 不管此时这个容器是否处于运行状态.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] export -o 文件名 CONTAINER</span><br></pre></td></tr></table></figure><h5 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] import [-m &quot;提交信息&quot;] file [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p>这个会生成一个镜像, 这个与<code>load</code>命令的区别在于, 这个是容器的快照.</p><h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><h5 id="查看容器详情"><a href="#查看容器详情" class="headerlink" title="查看容器详情"></a>查看容器详情</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect CONTAINER</span><br></pre></td></tr></table></figure><h5 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] top CONTAINER</span><br></pre></td></tr></table></figure><p>这个进程就是宿主机的进程</p><h5 id="查看容器资源使用情况"><a href="#查看容器资源使用情况" class="headerlink" title="查看容器资源使用情况"></a>查看容器资源使用情况</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] stats CONTAINER</span><br></pre></td></tr></table></figure><h4 id="容器和主机间复制文件"><a href="#容器和主机间复制文件" class="headerlink" title="容器和主机间复制文件"></a>容器和主机间复制文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker [container] cp CONTAINER:SRC_PATH DEST_PATH</span><br><span class="line"></span><br><span class="line">docker [container] cp DEST_PATH CONTAINER:SRC_PATH</span><br></pre></td></tr></table></figure><h4 id="查看端口映射"><a href="#查看端口映射" class="headerlink" title="查看端口映射"></a>查看端口映射</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] port CONTAINER</span><br></pre></td></tr></table></figure><p>这个用<code>docker container inspect CONTAINER</code>也可以查到.</p><h4 id="设置容器开启策略"><a href="#设置容器开启策略" class="headerlink" title="设置容器开启策略"></a>设置容器开启策略</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker [container] [--restart=(no|on-failure:[maxretries]|always)] CONTAINER</span><br><span class="line"></span><br><span class="line">docker [container] update --restart=(no|on-failure:[maxretries]|always)] CONTAINER</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">no: 容器退出不重启, 默认</span><br><span class="line">on-failure: 只有容器退出状态为非0时, 才重新启动容器</span><br><span class="line">always: 无论容器退出状态如何, 总是重启容器</span><br></pre></td></tr></table></figure><h2 id="Docker数据管理"><a href="#Docker数据管理" class="headerlink" title="Docker数据管理"></a><code>Docker</code>数据管理</h2><p>数据卷是一个可供容器使用的特殊目录, 它将主机操作系统目录直接映射进容器. 需要在容器创建的时候就必须挂上去, 在<code>docker run</code>或者<code>docker create</code>时.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建数据卷</span></span><br><span class="line">docker volume create -d local 数据卷名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看数据卷详情</span></span><br><span class="line">docker volume inspect</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出已有的数据卷</span></span><br><span class="line">docker volume ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理无用数据卷</span></span><br><span class="line">docker volume prune</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除数据卷</span></span><br><span class="line">docker volume rm</span><br></pre></td></tr></table></figure><p>创建的数据卷会放在<code>/var/lib/docker/volumes</code>路径下.</p><h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] (run|create) --mount type=(vloume|bind|tmpfs) source=(主机绝对路径|数据卷名), destination=容器(绝对|相对)路径,(ro|rw)</span><br></pre></td></tr></table></figure><p>如果容器内的路径不存在, 会自动创建. 默认数据卷是<code>rw</code>的. 挂载文件时可能出现问题, 尽量挂载目录.</p><p><code>--mount</code>和<code>-v</code>是相互取代的.</p><h2 id="端口映射与容器互联"><a href="#端口映射与容器互联" class="headerlink" title="端口映射与容器互联"></a>端口映射与容器互联</h2><h3 id="端口映射实现容器访问"><a href="#端口映射实现容器访问" class="headerlink" title="端口映射实现容器访问"></a>端口映射实现容器访问</h3><p>用于主机和容器交互.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] (run|create) [-p (HostPort:ContainerPort|IP:HostPort:ContainerPort|IP::ContainerPort)[/(tcp/udp)]] IMAGE</span><br></pre></td></tr></table></figure><p>可以有多个端口映射. 默认是<code>tcp</code>.</p><h2 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h2><p>容器的<strong>互联</strong>是一种让多个容器中的应用进行快速交互的方式.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] (create|run) --link name:alias NAME:TAG</span><br></pre></td></tr></table></figure><p><code>alias</code>是用来更新环境变量的, 可以自定义, 和容器名解耦. <code>alias</code>作为域名来使用的.</p><h2 id="使用Dockerfile创建镜像"><a href="#使用Dockerfile创建镜像" class="headerlink" title="使用Dockerfile创建镜像"></a>使用<code>Dockerfile</code>创建镜像</h2><p><code>Dockerfile</code>的使用<code>#</code>进行注释. 名称只能为<code>Dockfile</code>, 是更具文件名来找的.</p><p>一般而言, <code>Dockerfile</code>主体内容分为四部分: 基础镜像信息, 维护者信息, 镜像操作指令和容器启动时执行命令.</p><p>主体部分首先使用<code>FROM</code>指令指明所基于的镜像名称, 接下来一般是使用<code>LABEL</code>指令说明维护者信息. 后面则是镜像操作指令, 例如<code>RUN</code>指令将对镜像执行跟随的命令. 每运行一条<code>RUN</code>指令, 镜像添加新的一层, 并提交. 最后是<code>CMD</code>指令, 来执行运行容器时的操作命令.</p><h2 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h2><h3 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h3><table><thead><tr><th>指令</th><th>作用</th><th>格式</th><th>说明</th></tr></thead><tbody><tr><td><code>ARG</code></td><td>定义创建镜像过程中使用的变量</td><td><code>ARG &lt;name&gt;=&lt;value&gt;</code></td><td>当镜像编译成功后, <code>ARG</code>指定的变量将不再存在(<code>ENV</code>指定的变量将在镜像中保留)</td></tr><tr><td><code>FROM</code></td><td>指定所创建镜像的基础镜像</td><td><code>FROM &lt;image&gt;:&lt;tag&gt;</code></td><td>任何<code>Dockerfile</code>中第一条指令必须为<code>FROM</code>指令</td></tr><tr><td><code>LABEL</code></td><td>为生成的镜像添加元数据标签信息</td><td><code>LABLE &lt;key&gt;=&lt;value&gt;</code></td><td>这些信息可以用来辅助滤出特定镜像</td></tr><tr><td><code>EXPOSE</code></td><td>声明镜像内服务监听的端口</td><td><code>EXPOSE &lt;port&gt;...</code></td><td>这个指令只起到声明作用, 并不会自动完成端口映射. 也不是暴露了才能用</td></tr><tr><td><code>ENV</code></td><td>指定环境变量</td><td><code>ENV &lt;key&gt;=&lt;value&gt;...</code></td><td>指定环境变量, 在镜像生成过程中会被后续<code>RUN</code>指令使用, 在镜像启动的容器中也会存在. 可以在执行&#96;docker (create</td></tr><tr><td><code>ENTRYPOINT</code></td><td>指定镜像的默认入口命令</td><td><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>: <code>exec</code>调用执行; <code>ENTRYPOINT command param1 param2</code>: <code>shell</code>中执行</td><td><code>Dockerfile</code>中如果有多个, 只有最后一个有效. 如果使用<code>exec</code>模式, <code>CMD</code>指令会被作为参数来指定. 如果使用<code>shell</code>模式, 会忽略<code>CMD</code>指令</td></tr><tr><td><code>VOLUME</code></td><td>创建数据卷点</td><td><code>VOLUME [&quot;/data&quot;]</code></td><td>这个相当于<code>-v</code>的匿名挂载. 宿主机的目录可以通过<code>docker [container] inspect</code>中的<code>Mounts</code>字段查看</td></tr><tr><td><code>WORKDIR</code></td><td>配置工作目录</td><td><code>WORKDIR /path/to/workdir</code></td><td>为后续的<code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>指令配置工作目录</td></tr><tr><td><code>ONBUILD</code></td><td>创建子镜像时指定自动执行的操作指令</td><td><code>ONBUILD [INSTRUCTION]</code></td><td>指定当基于所生成镜像创建子镜像时, 自动执行的操作命令</td></tr></tbody></table><h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><table><thead><tr><th>指令</th><th>作用</th><th>格式</th><th>说明</th></tr></thead><tbody><tr><td><code>RUN</code></td><td>运行指定指令</td><td><code>RUN &lt;command&gt;</code></td><td>每条<code>RUN</code>指令将在当前镜像基础上执行指定命令, 并提交为新的镜像层. 当命令较长时可以使用<code>\</code>来换行</td></tr><tr><td><code>CMD</code></td><td>启动容器时指定默认执行的命令</td><td><code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>;<code>CMD command param1 param2</code>; <code>CMD [&quot;param1&quot;, &quot;param2&quot;]</code></td><td><code>Dockerfile</code>中如果有多个, 只有最后一个有效.</td></tr><tr><td><code>ADD</code></td><td>添加命令到镜像</td><td><code>ADD &lt;src&gt; [&lt;src&gt;...] &lt;dest&gt;</code></td><td>该命令将复制指定的<code>&lt;src&gt;</code>路径下内容到容器中的<code>&lt;dest&gt;</code>路径下. 其中<code>&lt;src&gt;</code>可以是<code>Dockerfile</code>所在目录的一个相对路径<code>URL</code>, <code>tar</code>文件, <code>&lt;dest&gt;</code>可以是镜像内的绝对路径, 或者相对于工作目录<code>WORKDIR</code>的相对路径; <code>&lt;dest&gt;</code>如果不存在, 会自动创建; <code>&lt;dest&gt;</code>如果以<code>/</code>结尾会被认为是目录, 如果不以<code>/</code>结尾, 会被认为是文件; 可以指定多个<code>&lt;src&gt;</code>, 但<code>&lt;dest&gt;</code>必须以<code>/</code>结尾; <code>&lt;tar&gt;</code>文件将会自动解压, 把里面的内容放到<code>&lt;dest&gt;</code>目录下, 相当于<code>tar -x</code></td></tr><tr><td><code>COPY</code></td><td>复制内容到镜像</td><td><code>COPY &lt;src&gt; [&lt;src&gt;...] &lt;dest&gt;</code></td><td>与<code>ADD</code>类似, 但是不支持<code>URL</code>和<code>tar</code>文件(解压). 如果使用本地路径作为源目录时, 推荐使用<code>COPY</code></td></tr></tbody></table><h2 id="创建镜像-1"><a href="#创建镜像-1" class="headerlink" title="创建镜像"></a>创建镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [image] build -t NAME:TAG PATH</span><br></pre></td></tr></table></figure><p>该命令将读取指定路径下(包括子目录)的<code>Dockerfile</code>, 默认使用指定路径下的, 不使用子目录下的, 并将该路径下的所有数据作为上下文发送给<code>Docker</code>守护线程.</p><p>如果上下文过大, 会导致发送大量数据给守护线程, 延缓创建过程. 因此除非是生成镜像所必需的文件, 不然不要放在上下文路径下.</p><p>如果创建镜像成功, 会返回最终镜像的ID.</p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Systemd定时器的使用</title>
      <link href="/2023/05/28/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Systemd/Systemd%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/05/28/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Systemd/Systemd%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在服务器上搭建Git服务</title>
      <link href="/2023/04/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/04/30/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Git/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>在服务器上搭建一个<code>git</code>仓库</p><span id="more"></span><h2 id="在服务器上创建一个裸仓库"><a href="#在服务器上创建一个裸仓库" class="headerlink" title="在服务器上创建一个裸仓库"></a>在服务器上创建一个裸仓库</h2><p><strong>裸仓库</strong>是一个不带工作区的仓库, 这意位着你看不到你提交的文件, 只有<code>.git</code>中的文件. 但是可以从这种仓库<code>clone</code>, 然后得到工作区的文件.</p><h3 id="如何创建一个裸仓库"><a href="#如何创建一个裸仓库" class="headerlink" title="如何创建一个裸仓库"></a>如何创建一个裸仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果不带仓库名, 将会把.git中文件直接放在文件夹, 这个文件夹就成了裸仓库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仓库名习惯上带上.git后缀</span> </span><br><span class="line">git init --bare [仓库名]</span><br></pre></td></tr></table></figure><h2 id="通过ssh使用服务器上的裸仓库"><a href="#通过ssh使用服务器上的裸仓库" class="headerlink" title="通过ssh使用服务器上的裸仓库"></a>通过ssh使用服务器上的裸仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆仓库</span></span><br><span class="line">git clone ssh的名称@ssh的地址:裸仓库的绝对地址</span><br></pre></td></tr></table></figure><p>这个其实与 <code>scp</code>命令很像. </p>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo文章发布</title>
      <link href="/2022/11/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Hexo/Hexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83/"/>
      <url>/2022/11/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Hexo/Hexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>Hexo文章发布</p><span id="more"></span><ol><li>在hexo的根目录执行<code>hexo new -p x/y/z &quot;文章的名称&quot;</code>. <code>x/y/z</code>是文章的相对路径, 从<code>_post</code>开始的, <code>z</code>为文件系统中文件的名称, 会自动添加上<code>.md</code>后缀. 该命令会自动创建不存在的目录</li><li>本地验证<code>hexo clean; hexo g; hexo s</code></li><li>推送到远端<code>hexo d</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具使用 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
