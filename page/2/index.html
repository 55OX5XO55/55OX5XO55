<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#70B7FD"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-space.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-space.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-space.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab-space.svg" color="#70B7FD">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="醉后不知天在水,满船清梦压星河">
<meta property="og:type" content="website">
<meta property="og:title" content="space">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="space">
<meta property="og:description" content="醉后不知天在水,满船清梦压星河">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="霄剑">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>space</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<script async src="/live2d/autoload.js"> </script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">space</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">17</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">16</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">34</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="霄剑"
      src="/images/avatar.svg">
  <p class="site-author-name" itemprop="name">霄剑</p>
  <div class="site-description" itemprop="description">醉后不知天在水,满船清梦压星河</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/55OX5XO55" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;55OX5XO55" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2606863445@qq.com" title="E-Mail → 2606863445@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%8D%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/05/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%8D%B7/" class="post-title-link" itemprop="url">卷</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-05 18:08:35" itemprop="dateCreated datePublished" datetime="2023-10-05T18:08:35+08:00">2023-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 23:08:01" itemprop="dateModified" datetime="2023-11-08T23:08:01+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>835</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="卷"><a href="#卷" class="headerlink" title="卷"></a>卷</h1><p><code>pod</code>的每个容器都有自己独立的文件系统, 因为文件系统来自容器镜像. 如果想要共享磁盘, <code>container</code>需要自己进行挂载. </p>
<p><code>Kubernetes</code>定义了存储卷, 它们被定义为<code>pod</code>的一部分, 并和<code>pod</code>共享相同的声明周期. 这意味着在<code>pod</code>启动时创建卷, 并在删除<code>pod</code>时销毁卷. 因此, 在容器重新启动期间, 卷的内容将保持不变, 在重新启动容器之后, 新容器可以识别前一个容器写入卷的所有文件. </p>
<h2 id="通过卷在容器之间共享数据"><a href="#通过卷在容器之间共享数据" class="headerlink" title="通过卷在容器之间共享数据"></a>通过卷在容器之间共享数据</h2><h3 id="使用emptyDir卷"><a href="#使用emptyDir卷" class="headerlink" title="使用emptyDir卷"></a>使用<code>emptyDir</code>卷</h3><p>卷从一个空目录开始, 运行在<code>pod</code>内的应用程序可以写入它需要的任何文件. 因为卷的生存周期与<code>pod</code>的生存周期相关联, 所以当删除<code>pod</code>时, 卷的内容就会丢失. </p>
<h4 id="指定用于EMPTYDIR的介质"><a href="#指定用于EMPTYDIR的介质" class="headerlink" title="指定用于EMPTYDIR的介质"></a>指定用于<code>EMPTYDIR</code>的介质</h4><p>作为卷来使用的<code>emptyDir</code>, 是在承载<code>pod</code>的工作节点的实际磁盘上创建的, 因此其性能取决于节点的磁盘类型. 但我们可以通知<code>Kubernetes</code>在<code>tmfs</code>文件系统(存在内存而非硬盘)上创建<code>emptyDir</code>. 因此, 将<code>emptyDir</code>的<code>medium</code>设置为<code>Memory</code>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">  	<span class="attr">emptyDir:</span></span><br><span class="line">  	  <span class="attr">medium:</span> <span class="string">Memory</span></span><br></pre></td></tr></table></figure>

<h3 id="使用Git仓库作为存储卷"><a href="#使用Git仓库作为存储卷" class="headerlink" title="使用Git仓库作为存储卷"></a>使用<code>Git</code>仓库作为存储卷</h3><p><code>gitRepo</code>卷基本上也是一个<code>emptyDir</code>卷, 它通过克隆<code>Git</code>仓库并在<code>pod</code>启动时(但在创建容器之前)检出特定版本类填充数据. </p>
<p>在创建<code>gitRepo</code>卷之后, 它并不能和对应<code>repo</code>保持同步. 当向<code>Git</code>仓库推送新增的提交时, 卷中的文件将不会被更新. </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">html</span></span><br><span class="line">    <span class="attr">gitRepo:</span></span><br><span class="line">      <span class="attr">repository:</span> <span class="string">https://github.com/luksa/kubia-website-example.git</span></span><br><span class="line">      <span class="attr">directory:</span> <span class="string">.</span> </span><br></pre></td></tr></table></figure>

<h4 id="介绍sidercar容器"><a href="#介绍sidercar容器" class="headerlink" title="介绍sidercar容器"></a>介绍<code>sidercar</code>容器</h4><p><code>sidecar container</code>, 它是一种容器, 增加了对<code>pod</code>主容器的操作. 可以将一个<code>sidecar</code>添加到<code>pod</code>中, 这样就可以使用现有的容器镜像, 而不是将附加逻辑填入主应用程序的代码中, 这会使它过于复杂和不可用. </p>
<h2 id="访问工作节点文件系统上的文件"><a href="#访问工作节点文件系统上的文件" class="headerlink" title="访问工作节点文件系统上的文件"></a>访问工作节点文件系统上的文件</h2><p>大多数<code>pod</code>应该忽略它们的主机节点, 因此它们不应该访问节点文件系统上的任何文件. 但是某系系统级别的<code>pod</code>(切记, 这些通常由<code>DaemonSet</code>管理)确实需要读取节点的文件或使用节点文件系统来访问节点设备. <code>Kubernetes</code>通过<code>hostPath</code>卷实现了这一点. </p>
<h3 id="介绍hostPath卷"><a href="#介绍hostPath卷" class="headerlink" title="介绍hostPath卷"></a>介绍<code>hostPath</code>卷</h3><p><code>hostPath</code>卷是持久性存储, 因为<code>gitRepo</code>和<code>emptyDir</code>卷的内容都会在<code>pod</code>被删除时被删除, 而<code>hostPath</code>卷的内容则不会被删除. 如果删除了一个<code>pod</code>, 并且下一个<code>pod</code>使用了指向主机上相同路径的<code>hostPath</code>卷, 则新<code>pod</code>将会发现上一个<code>pod</code>留下的数据, 但前提是必须将其调度到与第一个<code>pod</code>相同的节点上. </p>
<h2 id="使用持久化存储"><a href="#使用持久化存储" class="headerlink" title="使用持久化存储"></a>使用持久化存储</h2><p>当运行在一个<code>pod</code>中的应用程序需要将数据保存到磁盘上, 并且即使该<code>pod</code>重新调度到另一个节点时也要求具有相同的数据可用. 这就不能使用<code>emptyDir</code>, <code>gitRepo</code>和<code>hostPath</code>, 由于这些数据需要从任何集群节点访问, 因此必须将其存储在某种类型的网络储存中. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/02/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/Kubernetes%E7%BC%96%E6%8E%92%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/02/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/Kubernetes%E7%BC%96%E6%8E%92%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Kubernetes编排原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-02 22:31:58" itemprop="dateCreated datePublished" datetime="2023-10-02T22:31:58+08:00">2023-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-04 20:39:18" itemprop="dateModified" datetime="2023-10-04T20:39:18+08:00">2023-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kubernetes编排原理"><a href="#Kubernetes编排原理" class="headerlink" title="Kubernetes编排原理"></a><code>Kubernetes</code>编排原理</h1><h2 id="为什么我们需要Pod"><a href="#为什么我们需要Pod" class="headerlink" title="为什么我们需要Pod"></a>为什么我们需要<code>Pod</code></h2><p><code>Pod</code>是<code>Kubernetes</code>项目中最小的<code>API</code>对象. 更专业的表述是: <code>Pod</code>是<code>Kubernetes</code>项目的原子调度单位. </p>
<p>容器的”单进程模型”并不是指容器里只能运行”一个”进程, 而是指容器无法管理多个进程. 这是因为容器里<code>PID=1</code>的进程就是应用本身, 其他进程都是这个<code>PID=1</code>进程的子进程. 可是, 用户编写的应用并不像正常操作系统里的<code>init</code>进程或者<code>systemd</code>那样拥有进程管理的功能. </p>
<p>在<code>Kubernetes</code>项目里, <code>Pod</code>的实现需要使用一个中间容器, 这个容器叫作<code>Infra</code>容器. 在这个<code>Pod</code>中, <code>Infra</code>容器永远是第一个被创建的容器, 用户定义的其他容器则通过<code>Join Network Namespace</code>的方式与<code>Infra</code>容器关联在一起. </p>
<h2 id="Pod对象使用进阶"><a href="#Pod对象使用进阶" class="headerlink" title="Pod对象使用进阶"></a><code>Pod</code>对象使用进阶</h2><p>在<code>Kubernetes</code>中有几种特殊的<code>Volume</code>, 它们存在的意义不是为了存放容器里的数据, 也不是用于容器和宿主机之间的数据交换, 而是为容器提供预先定义好的数据. </p>
<h3 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a><code>Secret</code></h3><p><code>Secret</code>的作用是帮你把<code>Pod</code>想要访问的加密数据存放在<code>etcd</code>中, 你就可以通过在<code>Pod</code>的容器里挂载<code>Volume</code>的方式访问这些<code>Secret</code>里保存的信息了. </p>
<p>像这样通过挂载方式进入容器里的<code>Secret</code>, 一旦其对应的<code>etcd</code>里的数据更新, 这些<code>Volume</code>里的文件内容也会更新. 其实, 这是<code>kubelet</code>组件在定时维护这些<code>Volume</code>. </p>
<p>需要注意的是, 这个更新可能会有一定的延时. 所以在编写应用程序时, 在发起数据库连接的代码处写好重试和超时的逻辑, 绝对是个好习惯. </p>
<h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a><code>ConfigMap</code></h3><p><code>ConfigMap</code>与<code>Secret</code>类似, 区别在于<code>ConfigMap</code>保存的是无需加密的, 应用所需要的配置信息. </p>
<h3 id="DownwardAPI"><a href="#DownwardAPI" class="headerlink" title="DownwardAPI"></a><code>DownwardAPI</code></h3><p><code>DownwardAPI</code>的作用是让<code>Pod</code>里的容器能够直接获取这个<code>PodAPI</code>对象本身的信息. </p>
<p>不过, 需要注意的是, <code>DownwardAPI</code>能够获取的信息一定是<code>Pod</code>里的容器进程启动之前就能确定下来的信息. 如果你想要获得<code>Pod</code>容器运行后才会出现的信息, 比如容器进程的<code>PID</code>, 就肯定不能使用<code>DownwardAPI</code>了, 而应该考虑在<code>Pod</code>里定义一个<code>sidecar</code>容器. </p>
<h3 id="ServiceAccountToken"><a href="#ServiceAccountToken" class="headerlink" title="ServiceAccountToken"></a><code>ServiceAccountToken</code></h3><p><code>Service Account</code>对象的作用就是<code>Kubernetes</code>系统内置的一种”服务账户”, 它是<code>Kubernetes</code>进行权限分配的对象. 比如, <code>Service Account A</code>可以只被允许对<code>Kubernetes</code>进行<code>GET</code>操作, 而<code>Service Account B</code>可以有<code>Kubernetes API</code>的所有操作的权限. </p>
<p>像这样的<code>Service Account</code>的授权信息和文件, 实际上保存在它所绑定的一个特殊的<code>Secret</code>对象里. 这个特殊的<code>Secret</code>对象叫作<code>ServiceAccountToken</code>. 任何在<code>Kubernetes</code>集群上运行的应用, 都必须使用<code>ServiceAccountToken</code>里保存的授权信息(也就是<code>token</code>), 才可以合法访问<code>API Server</code>. </p>
<h2 id="容器健康检查和恢复机制"><a href="#容器健康检查和恢复机制" class="headerlink" title="容器健康检查和恢复机制"></a>容器健康检查和恢复机制</h2><p><code>Kubernetes</code>中的重启, 实际上却是重新创建了容器. 这个功能就是<code>Kubernetes</code>里的<code>Pod</code>恢复机制, 也叫<code>restartPolicy</code>. </p>
<p>一定要强调的是, <code>Pod</code>的恢复过程永远发生在当前节点上, 而不会跑到别的节点上. 事实上, 一旦一个<code>Pod</code>与一个节点绑定, 除非这个绑定关系发生了变化<code>pod.spec.node</code>字段被修改, 否则它永远不会离开这个节点. </p>
<p>如果你想让<code>Pod</code>出现在其他的可用节点上, 就必须使用<code>Deployment</code>这样的”控制器”来管理<code>Pod</code>, 哪怕你只需要一个<code>Pod</code>副本. </p>
<p>如果你关心这个容器退出后的上下文环境, 比如容器退出后的日志, 文件和目录, 就需要将<code>restartPolicy</code>设置为<code>Never</code>. 这是因为一旦容器被自动重新创建, 这些内容就有可能丢失(被垃圾回收了). </p>
<p>只要<code>Pod</code>的<code>restartPolicy</code>指定的策略允许重启异常的容器, 那么这个<code>Pod</code>就会保持<code>Running</code>状态并重启容器, 否则<code>Pod</code>会进入<code>Failed</code>状态. </p>
<p>对于包含多个容器的<code>Pod</code>, 只有其中所有的容器都进入异常状态后, <code>Pod</code>才会进入<code>Failed</code>状态. </p>
<h2 id="PodPreset"><a href="#PodPreset" class="headerlink" title="PodPreset"></a><code>PodPreset</code></h2><p><code>PodPreset</code>里定义的内容只会在<code>Pod API</code>对象被创建之前追加在这个对象上, 而不会影响任何<code>Pod</code>的控制器的定义. 比如, 现在提交的是一个<code>nginx-deployment</code>, 那么这个<code>Deployment</code>对象永远不会被<code>PodPreset</code>改变, 被修改的只是这个<code>Deployment</code>创建出来的所有<code>Pod</code>. </p>
<p>如果你定义了同时作用于一个<code>Pod</code>对象的多个<code>PodPreset</code>, 会发生什么呢?</p>
<p>实际上, <code>Kubernetes</code>项目会帮你合并这两个<code>PodPreset</code>要做的修改, 而如果它们要做的有冲突的话, 这些冲突字段就不会被修改. </p>
<h2 id="谈谈”控制器”思想"><a href="#谈谈”控制器”思想" class="headerlink" title="谈谈”控制器”思想"></a>谈谈”控制器”思想</h2><p>像<code>Deployment</code>定义的<code>template</code>字段, 在<code>Kubernetes</code>项目中有一个专属的名字, 叫作<code>PodTemplate</code>(<code>Pod</code>模版). </p>
<h2 id="作业副本与水平扩展"><a href="#作业副本与水平扩展" class="headerlink" title="作业副本与水平扩展"></a>作业副本与水平扩展</h2><p>如果你更新了<code>Deployment</code>的<code>Pod</code>模版, 那么<code>Deployment</code>就需要遵循一种叫作滚动更新的方式, 来升级现有容器. </p>
<p>创建<code>Deployment</code>时建议指定<code>--record</code>参数, 因此创建回滚版本的时候执行的<code>kubectl</code>命令都会被记录下来, 否则通过<code>kubectl rollout history</code>命令查看历史版本时, <code>CHANGE-CAUSE</code>这一栏会是空. </p>
<h2 id="深入理解StatefulSet-一-拓扑状态"><a href="#深入理解StatefulSet-一-拓扑状态" class="headerlink" title="深入理解StatefulSet(一): 拓扑状态"></a>深入理解<code>StatefulSet(一)</code>: 拓扑状态</h2><p>这种实例之间有不对等关系, 以及实例对外部是数据有依赖关系的应用, 就称为有状态应用. </p>
<p><code>StatefulSet</code>的设计其实非常容易理解, 它把现实世界里的应用状态抽象为了两种情况. </p>
<h3 id="拓扑状态"><a href="#拓扑状态" class="headerlink" title="拓扑状态"></a>拓扑状态</h3><p>应用的多个实例之间不是完全对等的. 这些应用实例必须按照某种顺序启动, 比如应用的主节点A要先于从节点B启动. 而如果删除A和B两个<code>Pod</code>, 它们再次被创建出来时也必须严格按照这个顺序运行. 并且, 新创建出来的<code>Pod</code>必须和原来<code>Pod</code>的网络标识一样, 这丫原先的访问者才能使用同样的方法访问到这个新的<code>Pod</code>. </p>
<h3 id="存储状态"><a href="#存储状态" class="headerlink" title="存储状态"></a>存储状态</h3><p>应用的多个实际分别绑定了不同的存储数据. 对于这些应用实例来说, <code>Pod A</code>第一次读取到的数据和隔了10分钟之后再此读取到数据应该是同一份, 哪怕在此期间<code>Pod A</code>被创建过. </p>
<p><code>StatefulSet</code>的核心功能, 就是通过某种方式记录这些状态, 然后在<code>Pod</code>被重新创建时, 能够为新的<code>Pod</code>恢复这些状态. </p>
<h4 id="Service如何被访问的"><a href="#Service如何被访问的" class="headerlink" title="Service如何被访问的"></a>Service如何被访问的</h4><p>第一种是以<code>Service</code>的<code>VIP</code>(<code>virtual IP</code>, 虚拟IP)方式.</p>
<p>第二种是以<code>Service</code>的<code>DNS</code>方式. </p>
<p>在第二种<code>Service DNS</code>的方式下, 具体又可以分为两种处理方法. </p>
<p>第一种处理方法是<code>Normal Service</code>.</p>
<p>第二种处理方法是<code>Headless Service</code>. <code>Headless Service</code>中<code>cluster IP</code>字段是的值是<code>None</code>, 即这个<code>Service</code>没有一个<code>VIP</code>作为”头”. 这个<code>Service</code>被创建后并不会被分配一个<code>VIP</code>, 而是会以<code>DNS</code>记录的方式暴露出它所代理的<code>Pod</code>. </p>
<p>通过这种方法, <code>Kubernetes</code>就成功地将<code>Pod</code>的拓扑状态(比如哪个节点先启动, 哪个节点后启动), 按照<code>Pod</code>的”名字+编号”的方式固定下来. 此外, <code>Kubernetes</code>还为每个<code>Pod</code>提供了一个固定且唯一的访问入口, 即这个<code>Pod</code>对应的<code>DNS</code>记录. 这些状态在<code>StatefulSet</code>的整个生命周期里都保持不变, 绝不会因为对应<code>Pod</code>的删除或者重新创建而失败. </p>
<p><code>DNS</code>记录本身不会变, 但它解析到的<code>Pod</code>的<code>IP</code>地址并不是固定的. 这就意味着, 对于有状态应用实例的访问, 必须使用<code>DNS</code>记录或者<code>hostname</code>的方式, 而绝不应该直接访问这些<code>Pod</code>的<code>IP</code>地址. </p>
<h2 id="深入理解StatefulSet-二-存储状态"><a href="#深入理解StatefulSet-二-存储状态" class="headerlink" title="深入理解StatefulSet(二): 存储状态"></a>深入理解<code>StatefulSet(二)</code>: 存储状态</h2><p><code>StatefulSet</code>的控制器直接管理的是<code>Pod</code>. <code>Kubernetes</code>通过<code>Headless Service</code>为这些有编号的<code>Pod</code>, 在<code>DNS</code>服务器中生成带有相同编号的<code>DNS</code>编号. <code>StatefulSet</code>还为每一个<code>Pod</code>分配并创建了一个相同编号的<code>PVC</code>. </p>
<h2 id="容器化守护进程-DaemonSet"><a href="#容器化守护进程-DaemonSet" class="headerlink" title="容器化守护进程: DaemonSet"></a>容器化守护进程: <code>DaemonSet</code></h2><p>跟其他编排对象不同, <code>DaemonSet</code>开始运行的时候很多时候要比整个<code>Kubernetes</code>集群出现的时机要早. </p>
<p>在<code>Kubernetes</code>项目中, 当一个节点的网络插件尚未安装时, 该节点就会被自动加上名为<code>node.kubernetes.io/network-unavailable</code>的”污点”. 而通过这样一个<code>Toleration</code>, 调度器在调度这个<code>Pod</code>时就会忽略当前节点上的”污点”, 从而成功地将网络插件的<code>Agent</code>组件调度到这台机器上启动起来. </p>
<h2 id="撬动离线业务-Job和CronJob"><a href="#撬动离线业务-Job和CronJob" class="headerlink" title="撬动离线业务: Job和CronJob"></a>撬动离线业务: <code>Job</code>和<code>CronJob</code></h2><p>事实上, <code>restartPolicy</code>在<code>Job</code>对象里只允许设置为<code>Never</code>和<code>OnFailure</code>; 而在<code>Deployment</code>对象里, <code>restartPolicy</code>只允许设置为<code>Always</code>. </p>
<p>如果<code>restartPolicy=Never</code>, 那么离线业务失败后<code>Job Controller</code>就会不断尝试创建一个新<code>Pod</code>. 如果<code>restartPolicy=OnFailure</code>, 那么离线业务失败后, <code>Job Controller</code>就不会尝试创建新的<code>Pod</code>, 而是不断尝试重启<code>Pod</code>里的容器. </p>
<p><code>CronJob</code>是一个专门用来管理<code>Job</code>对象的控制器. </p>
<h2 id="基于角色的权限控制-RBAC"><a href="#基于角色的权限控制-RBAC" class="headerlink" title="基于角色的权限控制: RBAC"></a>基于角色的权限控制: <code>RBAC</code></h2><p>我们知道, <code>Kubernetes</code>中所有<code>API</code>对象都保存在<code>etcd</code>里. 可是, 对这些<code>API</code>对象的操作一定都是通过访问<code>kube-apiserver</code>实现的. 其中一个非常重要的原因是, 需要<code>API Server</code>来帮忙做授权工作. 而在<code>Kubernetes</code>项目中, 负责完成授权工作的机制是<code>RBAC</code>. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E6%9C%8D%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E6%9C%8D%E5%8A%A1/" class="post-title-link" itemprop="url">服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-09-24 11:20:56 / 修改时间：23:02:26" itemprop="dateCreated datePublished" datetime="2023-09-24T11:20:56+08:00">2023-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><p><code>pod</code>需要一种寻找其他<code>pod</code>的方法来使用其他<code>pod</code>提供的服务, 不想在没有<code>Kubernetes</code>的世界, 系统管理员要在用户端配置文件中明确指出服务的精确IP地址或主机名来配置每个服务短应用. </p>
<h2 id="介绍服务"><a href="#介绍服务" class="headerlink" title="介绍服务"></a>介绍服务</h2><p><code>Kubernetes</code>服务是一种为一组功能相同的<code>pod</code>提供单一不变的接入点的资源. 当服务存在是, 它的<code>IP</code>地址和端口不会改变. 客户端通过<code>IP</code>地址和端口号建立连接, 这些连接会被路由到提供该服务的任意一个<code>pod</code>上. 通过这种方式, 客户端不需要知道每个单独的提供服务的<code>pod</code>的地址, 这样这些<code>pod</code>就可以在集群中随时被创建或移除. </p>
<h3 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h3><p>服务的后端可以有不止一个<code>pod</code>. 服务的连接对所有的后端<code>pod</code>是负载均衡的. </p>
<p><code>CLUSTER-IP</code>只能在集群内部可以被访问, 是为了让集群内部的其他<code>pod</code>可以访问当前这组<code>pod</code>. </p>
<h4 id="在运行的容器中远程执行命令"><a href="#在运行的容器中远程执行命令" class="headerlink" title="在运行的容器中远程执行命令"></a>在运行的容器中远程执行命令</h4><p>嗯可以使用<code>kubectl exec</code>命令远程地在一个已经存在的<code>pod</code>容器上执行任何命令. 这样就可以很方便地了解<code>pod</code>的内容, 状态及环境. <code>--</code>代表着命令项的结束. </p>
<h4 id="配置服务的回话亲和性"><a href="#配置服务的回话亲和性" class="headerlink" title="配置服务的回话亲和性"></a>配置服务的回话亲和性</h4><p>如果希望特定客户端产生的所有请求每次都指向同一个<code>pod</code>, 可以设置服务的<code>sessionAffinity</code>属性为<code>ClientIP</code>(而不是<code>None</code>, <code>None</code>是默认值). </p>
<h4 id="同一个服务暴露多个端口"><a href="#同一个服务暴露多个端口" class="headerlink" title="同一个服务暴露多个端口"></a>同一个服务暴露多个端口</h4><p>在创建一个有多个端口的服务的时候, 必须给每个端口指定名字. </p>
<h4 id="使用命名的端口"><a href="#使用命名的端口" class="headerlink" title="使用命名的端口"></a>使用命名的端口</h4><p>服务中可以通过数字来指定端口, 也可以通过名称来指定. </p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>客户端<code>pod</code>如何知道服务的<code>IP</code>和端口. <code>Kubernetes</code>为客户端提供了发现服务的<code>IP</code>和端口的方式. </p>
<h4 id="通过环境变量发现服务"><a href="#通过环境变量发现服务" class="headerlink" title="通过环境变量发现服务"></a>通过环境变量发现服务</h4><p>在<code>pod</code>开始运行的时候, <code>Kubernetes</code>会初始化一系列的环境变量指向现在存在的服务. 如果你创建的服务中早于客户端<code>pod</code>的创建, <code>pod</code>上的进程可以根据环境变量获得服务的<code>IP</code>地址和端口号. </p>
<h4 id="通过DNS发现服务"><a href="#通过DNS发现服务" class="headerlink" title="通过DNS发现服务"></a>通过<code>DNS</code>发现服务</h4><p><code>kube-dns</code>运行<code>DNS</code>服务, 在集群中的其他<code>pod</code>都被配置成使用其作为<code>dns</code>(<code>Kubernetes</code>通过修改每个容器的<code>/etc/resolv.conf</code>文件实现). 运行在<code>pod</code>上的进程<code>DNS</code>查询都会被<code>Kubernetes</code>自身的<code>DNS</code>服务器响应, 该服务器知道系统中运行的所有服务. </p>
<p><code>pod</code>是否使用内部的<code>DNS</code>服务器是根据<code>pod</code>中的<code>spec</code>的<code>dnsPolicy</code>属性来决定的. </p>
<p>每个服务从内部<code>DNS</code>服务器中获得一个<code>DNS</code>条目, 客户端的<code>pod</code>在知道服务名称的情况下可以通过全限定域名来访问, 而不是诉诸于环境变量. </p>
<h4 id="通过全限定域名连接服务"><a href="#通过全限定域名连接服务" class="headerlink" title="通过全限定域名连接服务"></a>通过全限定域名连接服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;服务名&gt;.&lt;服务的命名空间&gt;.svc.cluster.local</span><br></pre></td></tr></table></figure>

<p>客户端仍然必须知道服务的端口后. 如果不是标准端口, 客户端可以从环境变量中获取端口号. </p>
<h2 id="连接集群外部的服务"><a href="#连接集群外部的服务" class="headerlink" title="连接集群外部的服务"></a>连接集群外部的服务</h2><h3 id="介绍服务endpoint"><a href="#介绍服务endpoint" class="headerlink" title="介绍服务endpoint"></a>介绍服务<code>endpoint</code></h3><p>服务并不是和<code>pod</code>直接相连的. 相反, 有一种资源介于两者之间<code>--</code>它就是<code>Endpoint</code>资源. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get endpoints &lt;服务名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="手动配置服务的endpoint"><a href="#手动配置服务的endpoint" class="headerlink" title="手动配置服务的endpoint"></a>手动配置服务的<code>endpoint</code></h3><p>服务的<code>endpoint</code>与服务解耦后, 可以分别配置和更新它们. </p>
<p><code>Endpoint</code>对象需要与服务具有相同的名称. </p>
<h2 id="将服务暴露给外部客户端"><a href="#将服务暴露给外部客户端" class="headerlink" title="将服务暴露给外部客户端"></a>将服务暴露给外部客户端</h2><h3 id="使用NodePort类型的服务"><a href="#使用NodePort类型的服务" class="headerlink" title="使用NodePort类型的服务"></a>使用<code>NodePort</code>类型的服务</h3><p>通过创建<code>NodePort</code>服务, 可以让<code>Kubernetes</code>在其所有节点上保留一个端口(所有节点都使用相同的端口), 并将传入的连接转发给作为服务部分的<code>pod</code>. </p>
<h3 id="通过负载均衡器将服务暴露出来"><a href="#通过负载均衡器将服务暴露出来" class="headerlink" title="通过负载均衡器将服务暴露出来"></a>通过负载均衡器将服务暴露出来</h3><h4 id="回话亲和性和Web浏览器"><a href="#回话亲和性和Web浏览器" class="headerlink" title="回话亲和性和Web浏览器"></a>回话亲和性和<code>Web</code>浏览器</h4><p>浏览器使用<code>keep-alive</code>连接, 并通过单个连接发送所有请求, 而<code>curl</code>每次都会打开一个新连接. 服务在连接级别工作, 所以当首次打开服务的连接时, 会选择一个随机集群, 然后将属于该连接的所有网络数据包全部发送到单个集群. 即使会话亲和性设置为<code>None</code>, 用户也会始终使用相同的<code>pod</code>(直到连接关闭). </p>
<h2 id="通过Ingress暴露服务"><a href="#通过Ingress暴露服务" class="headerlink" title="通过Ingress暴露服务"></a>通过<code>Ingress</code>暴露服务</h2><h4 id="为什么需要Ingress"><a href="#为什么需要Ingress" class="headerlink" title="为什么需要Ingress"></a>为什么需要Ingress</h4><p>一个重要的原因是每个<code>LoadBalancer</code>服务都需要自己的负载均衡器, 以及独有的公有<code>IP</code>地址, 而<code>Ingress</code>只需要一个公网<code>IP</code>就能为许多服务提供访问. 当客户端向<code>Ingress</code>发送<code>HTTP</code>请求时, <code>Ingress</code>会根据请求的主机名和路径决定请求转发到的服务. </p>
<h4 id="了解Ingress的工作原理"><a href="#了解Ingress的工作原理" class="headerlink" title="了解Ingress的工作原理"></a>了解<code>Ingress</code>的工作原理</h4><p><code>Ingress</code>控制器不会将请求转发给该服务, 只用它来选择一个<code>pod</code>. </p>
<h2 id="pod就绪后发出信号"><a href="#pod就绪后发出信号" class="headerlink" title="pod就绪后发出信号"></a><code>pod</code>就绪后发出信号</h2><h3 id="介绍就绪探针"><a href="#介绍就绪探针" class="headerlink" title="介绍就绪探针"></a>介绍就绪探针</h3><p>就绪探针器会定期调用, 并确定特定的<code>pod</code>是否接收客户端请求. 当容器的准备就绪探测返回成功时, 表示容器已经准备好接收请求. </p>
<h4 id="了解就绪探针的操作"><a href="#了解就绪探针的操作" class="headerlink" title="了解就绪探针的操作"></a>了解就绪探针的操作</h4><p>启动容器时, 可以为<code>Kubernetes</code>配置一个等待时间, 经过等待时间后才可以执行第一次就绪检查. 之后, 它会周期性地调用探针, 并根据就绪探针的结果采取行动. 如果某个<code>pod</code>报告它尚未准备就绪, 则会从该服务中删除该<code>pod</code>. 如果<code>pod</code>再次准备就绪, 则重新添加<code>pod</code>. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/23/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E5%92%8C%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/23/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%89%AF%E6%9C%AC%E6%9C%BA%E5%88%B6%E5%92%8C%E5%85%B6%E4%BB%96%E6%8E%A7%E5%88%B6%E5%99%A8/" class="post-title-link" itemprop="url">副本机制和其他控制器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-23 23:07:52" itemprop="dateCreated datePublished" datetime="2023-09-23T23:07:52+08:00">2023-09-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-24 11:18:00" itemprop="dateModified" datetime="2023-09-24T11:18:00+08:00">2023-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="副本机制和其他控制器-部署托管的pod"><a href="#副本机制和其他控制器-部署托管的pod" class="headerlink" title="副本机制和其他控制器: 部署托管的pod"></a>副本机制和其他控制器: 部署托管的<code>pod</code></h1><h2 id="保持pod健康"><a href="#保持pod健康" class="headerlink" title="保持pod健康"></a>保持<code>pod</code>健康</h2><p>只要<code>pod</code>调度到某个节点, 该节点上的<code>Kubelet</code>就会运行<code>pod</code>的容器, 从此只要该<code>pod</code>存在, 就会保持运行. 如果容器的主进程崩溃, <code>Kubelet</code>将重启容器. </p>
<p>程序可以能因为无限循环或死锁而停止响应, 为确保应用程序在这种情况下可以重新启动, 必须从外部检查应用程序的运行状态, 而不是依赖于应用的内部检测. </p>
<h4 id="介绍存活探针"><a href="#介绍存活探针" class="headerlink" title="介绍存活探针"></a>介绍存活探针</h4><p><code>Kubernetes</code>可以通过存活探针(liveness probe)检查容器是否还在运行. 可以为<code>pod</code>中每个容器单独指定存活探针, 如果检测失败, <code>Kubernetes</code>将定期执行探针并重启容器. </p>
<p><code>Kubernetes</code>有以下三种检测容器的机制:</p>
<p><code>HTTP GET</code>探针对容器的<code>IP</code>地址(你指定的端口和路径)执行<code>HTTP GET</code>请求. 如果探测器收到响应, 并且响应码不代表错误, 则认为探测成功. 如果服务器返回错误响应码或者根本没有响应, 那么特测被认为是失败的, 容器将被重新启动. </p>
<p><code>TCP</code>套接字探针尝试与容器指定端口建立<code>TCP</code>连接. 如果连接成功建立, 则探测成功. 否则, 容器重新启动. </p>
<p><code>Exec</code>探针在容器内执行任意命令, 并检查命令的退出状态码. 如果状态码是<code>0</code>, 则探测成功. 所有其他状态码都认为失败. </p>
<h3 id="创建基于HTTP的存活探针"><a href="#创建基于HTTP的存活探针" class="headerlink" title="创建基于HTTP的存活探针"></a>创建基于<code>HTTP</code>的存活探针</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">liveness:</span></span><br><span class="line">	<span class="attr">httpGet:</span></span><br><span class="line">		<span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">		<span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>该<code>pod</code>的描述文件定义了一个<code>httpGet</code>探针, 该探针告诉<code>Kubernetes</code>定期在端口<code>8080</code>路径上执行<code>HTTP GET</code>请求, 以确定容器是否健康. </p>
<h3 id="使用存活探针"><a href="#使用存活探针" class="headerlink" title="使用存活探针"></a>使用存活探针</h3><h4 id="获取崩溃容器的应用日志"><a href="#获取崩溃容器的应用日志" class="headerlink" title="获取崩溃容器的应用日志"></a>获取崩溃容器的应用日志</h4><p>如果容器重启, <code>Kubectl logs</code>命令将显示当前容器的日志. 当你想知道前一个容器为什么终止时. 可以通过添加<code>--previous</code>选项. </p>
<p>容器被强行终止时, 会创建一个全新的容器<code>--</code>而不是重启原来的容器. </p>
<h3 id="配置存活探针的附加属性"><a href="#配置存活探针的附加属性" class="headerlink" title="配置存活探针的附加属性"></a>配置存活探针的附加属性</h3><p>除了明确指定的存活探针选项, 还可以看到其他属性, 例如delay, timeout, period等. </p>
<p>请务必记得设置一个初始延时来说明应用程序的启动时间. </p>
<h3 id="创建有效的存活探针"><a href="#创建有效的存活探针" class="headerlink" title="创建有效的存活探针"></a>创建有效的存活探针</h3><p>对于在生产中运行的<code>pod</code>, 一定要定义一个存活探针. 没有探针的话, <code>Kubernetes</code>无法知道你的应用是否还活着. 只要进程还存在, <code>Kubernetes</code>会认为容器是健康的. </p>
<h2 id="了解ReplicationController"><a href="#了解ReplicationController" class="headerlink" title="了解ReplicationController"></a>了解<code>ReplicationController</code></h2><p><code>ReplicationController</code>是一种<code>Kubernetes</code>资源, 可确保它的<code>pod</code>始终保持运行状态. </p>
<h3 id="ReplicationController的操作"><a href="#ReplicationController的操作" class="headerlink" title="ReplicationController的操作"></a><code>ReplicationController</code>的操作</h3><p><code>RelicationController</code>会持续监控正在运行的<code>pod</code>列表, 并保证相应”类型”的<code>pod</code>的数目与期望的相符. </p>
<h4 id="介绍控制器的协调流程"><a href="#介绍控制器的协调流程" class="headerlink" title="介绍控制器的协调流程"></a>介绍控制器的协调流程</h4><p><code>ReplicationController</code>的工作是确保<code>pod</code>的数量始终与其标签选择器匹配. 如果不匹配, 则<code>ReplicationController</code>将根据所需, 采取适当地操作来协调<code>pod</code>的数量. </p>
<h2 id="使用DaemonSet在每个节点上运行一个pod"><a href="#使用DaemonSet在每个节点上运行一个pod" class="headerlink" title="使用DaemonSet在每个节点上运行一个pod"></a>使用<code>DaemonSet</code>在每个节点上运行一个<code>pod</code></h2><h2 id="运行执行单个任务的pod"><a href="#运行执行单个任务的pod" class="headerlink" title="运行执行单个任务的pod"></a>运行执行单个任务的<code>pod</code></h2><h3 id="介绍Job资源"><a href="#介绍Job资源" class="headerlink" title="介绍Job资源"></a>介绍<code>Job</code>资源</h3><p>在发生节点故障时, 该节点上由<code>Job</code>管理的<code>pod</code>将按照<code>ReplicaSet</code>的<code>pod</code>的方式, 重新安排到其他节点. 如果进程本身异常退出(进程返回错误退出代码时), 可以将<code>Job</code>配置为重新启动容器. </p>
<h2 id="安排Job定期运行或在将来运行一次"><a href="#安排Job定期运行或在将来运行一次" class="headerlink" title="安排Job定期运行或在将来运行一次"></a>安排<code>Job</code>定期运行或在将来运行一次</h2><p><code>Job</code>资源在创建时会立即运行<code>pod</code>. 但是许多批处理任务需要在特定时间运行, 或者在指定的时间间隔內重复运行. 在<code>Linux</code>和类<code>UNIX</code>操作系统中, 这些任务通常被称为<code>cron</code>任务. </p>
<h3 id="了解计划任务的运行方式"><a href="#了解计划任务的运行方式" class="headerlink" title="了解计划任务的运行方式"></a>了解计划任务的运行方式</h3><p>在正常情况下, <code>CronJob</code>总是计划为配置中的每个执行创建一个<code>Job</code>, 但是可能会同时创建两个<code>Job</code>, 或者根本没有创建. 为了解决第一个问题, 你的任务应该是幂等的. 对于第二个问题, 请确保下一个任务完成本应该由上一次的(错过的)运行完成的工作. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E8%BF%90%E8%A1%8C%E4%BA%8EKubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E8%BF%90%E8%A1%8C%E4%BA%8EKubernetes%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/" class="post-title-link" itemprop="url">运行于Kubernetes中的容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-20 22:50:03" itemprop="dateCreated datePublished" datetime="2023-09-20T22:50:03+08:00">2023-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-02 15:35:21" itemprop="dateModified" datetime="2023-10-02T15:35:21+08:00">2023-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="运行于Kubernetes中的容器"><a href="#运行于Kubernetes中的容器" class="headerlink" title="运行于Kubernetes中的容器"></a>运行于<code>Kubernetes</code>中的容器</h1><h2 id="介绍pod"><a href="#介绍pod" class="headerlink" title="介绍pod"></a>介绍<code>pod</code></h2><p>在实际应用中我们不会单独部署容器, 更多的是针对一组<code>pod</code>的容器进行部署和操作. </p>
<h3 id="为何需要pod"><a href="#为何需要pod" class="headerlink" title="为何需要pod"></a>为何需要<code>pod</code></h3><h4 id="为何多个容器比单个容器包含多个进程要好"><a href="#为何多个容器比单个容器包含多个进程要好" class="headerlink" title="为何多个容器比单个容器包含多个进程要好"></a>为何多个容器比单个容器包含多个进程要好</h4><p>容积被设计为每个容器只运行一个进程(除非进程本身产生进程). 如果在单个容器中运行多个不相关的进程, 那么保持所有进程运行, 管理它们的日志等将会是我们的责任. </p>
<h3 id="了解pod"><a href="#了解pod" class="headerlink" title="了解pod"></a>了解<code>pod</code></h3><h4 id="同一pod中容器之间的部分隔离"><a href="#同一pod中容器之间的部分隔离" class="headerlink" title="同一pod中容器之间的部分隔离"></a>同一<code>pod</code>中容器之间的部分隔离</h4><p>容器之间彼此是完全隔离的, 但是此时我们期望的是隔离容器组, 而不是单个容器, 并让每个容器组内的容器共享一些资源, 而不是全部. <code>Kubernetes</code>通过配置<code>Docker</code>来让一个<code>pod</code>内的所有容器共享相同的<code>Linux</code>命名空间, 而不是每个容器都有自己的一组命名空间. </p>
<h4 id="容器如何共享相同的IP和端口空间"><a href="#容器如何共享相同的IP和端口空间" class="headerlink" title="容器如何共享相同的IP和端口空间"></a>容器如何共享相同的IP和端口空间</h4><p>由于一个<code>pod</code>中的容器运行于相同的<code>Network</code>命名空间中, 因此它们共享相同的<code>IP</code>地址和端口空间. 有可能会产生端口冲突, 但这只涉及同一个<code>pod</code>中的容器. </p>
<h4 id="介绍平坦pod间网络"><a href="#介绍平坦pod间网络" class="headerlink" title="介绍平坦pod间网络"></a>介绍平坦<code>pod</code>间网络</h4><p><code>Kubernetes</code>集群中的所有<code>pod</code>都在同一个共享网络地址空间中, 这意味着每个<code>pod</code>都可以通过其他<code>pod</code>的<code>IP</code>地址来实现相互访问. </p>
<h3 id="通过pod合理管理容器"><a href="#通过pod合理管理容器" class="headerlink" title="通过pod合理管理容器"></a>通过<code>pod</code>合理管理容器</h3><p>将多层应用分散到多个<code>pod</code>中, 同时基于扩缩容考虑而分割到多个<code>pod</code>中. 当应用可能由一个主进程和一个或多个辅助进程时, 才有可能将多个容器添加到单个<code>pod</code>中. </p>
<h4 id="决定何时在pod中使用多个容器"><a href="#决定何时在pod中使用多个容器" class="headerlink" title="决定何时在pod中使用多个容器"></a>决定何时在<code>pod</code>中使用多个容器</h4><p>当决定是将两个容器放入到一个<code>pod</code>还是两个独立的<code>pod</code>时, 我们可以问自己以下几个问题: </p>
<ol>
<li>它们需要一起运行还是可以在不同的主机上运行?</li>
<li>它们代表的是一个整体还是相互独立的组件?</li>
<li>它们必须一起进行扩缩容还是可以分别进行?</li>
</ol>
<h2 id="以YAML或JSON描述文件创建pod"><a href="#以YAML或JSON描述文件创建pod" class="headerlink" title="以YAML或JSON描述文件创建pod"></a>以<code>YAML</code>或<code>JSON</code>描述文件创建<code>pod</code></h2><p><code>pod</code>和其他<code>Kubernetes</code>资源通常是通过向<code>Kubernetes REST API</code>提供<code>JSON</code>或<code>YAML</code>描述文件来创建的. 此外还有其他更简单的创建资源的方法, 比如<code>kubectl run</code>命令, 但这些方法通常只允许你配置一组有限的属性. </p>
<h3 id="检查现有pod的YAML描述文件"><a href="#检查现有pod的YAML描述文件" class="headerlink" title="检查现有pod的YAML描述文件"></a>检查现有<code>pod</code>的<code>YAML</code>描述文件</h3><p>获得<code>pod</code>的<code>yaml</code>信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods &lt;pod名称&gt; -o yaml</span><br></pre></td></tr></table></figure>

<h4 id="介绍pod定义的主要部分"><a href="#介绍pod定义的主要部分" class="headerlink" title="介绍pod定义的主要部分"></a>介绍<code>pod</code>定义的主要部分</h4><p><code>pod</code>定义由这么几个部分组成: 首先是<code>YAML</code>中使用的<code>Kubernetes API</code>版本和<code>YAML</code>描述的资源类型; 其次是几乎在所有<code>Kubernetes</code>资源中都可以找到的三大重要部分:</p>
<ol>
<li><code>metedata</code>包括名称, 命名空间, 标签和关于该容器的其他信息</li>
<li><code>spec</code>包含<code>pod</code>内容的实际说明, 例如<code>pod</code>的容器, 卷和其他数据.</li>
<li><code>status</code>包含运行中的<code>pod</code>的当前信息, 例如<code>pod</code>所处的条件, 每个容器的描述和状态, 以及内部<code>IP</code>和其他基本信息.</li>
</ol>
<h3 id="为pod创建一个简单的YAML描述文件"><a href="#为pod创建一个简单的YAML描述文件" class="headerlink" title="为pod创建一个简单的YAML描述文件"></a>为<code>pod</code>创建一个简单的<code>YAML</code>描述文件</h3><h4 id="使用kubectl-explain来发现可能的API对象字段"><a href="#使用kubectl-explain来发现可能的API对象字段" class="headerlink" title="使用kubectl explain来发现可能的API对象字段"></a>使用<code>kubectl explain</code>来发现可能的<code>API</code>对象字段</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl explain pods</span><br><span class="line"></span><br><span class="line">kubectl explain pod.spec</span><br></pre></td></tr></table></figure>

<h3 id="使用kubectl-create来创建pod"><a href="#使用kubectl-create来创建pod" class="headerlink" title="使用kubectl create来创建pod"></a>使用<code>kubectl create</code>来创建<code>pod</code></h3><p><code>kubectl create -f</code>命令用于从<code>yaml</code>或<code>json</code>文件中创建任何资源(不只是<code>pod</code>).</p>
<h3 id="查看应用程序日志"><a href="#查看应用程序日志" class="headerlink" title="查看应用程序日志"></a>查看应用程序日志</h3><p>容器化的应用程序通常会将日志记录到标准输出和标准错误流, 而不是将其写入文件. </p>
<p>容器运行时将这些流重定向到文件, 并允许我们运行以下命令来获取容器的日志:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;container id&gt;</span><br></pre></td></tr></table></figure>

<p>使用<code>ssh</code>命令登录到<code>pod</code>正在运行的节点, 并使用<code>docker logs</code>命令查看其日志, 但<code>Kubernetes</code>提供了一种更为简单的方法. </p>
<h4 id="使用kubectl-logs命令获取pod日志"><a href="#使用kubectl-logs命令获取pod日志" class="headerlink" title="使用kubectl logs命令获取pod日志"></a>使用<code>kubectl logs</code>命令获取<code>pod</code>日志</h4><p>为了查看<code>pod</code>的日志(更准确地说是容器的日志), 只需要在本地机器上运行以下命令(不需要<code>ssh</code>到任何地方): </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod名称&gt;</span><br></pre></td></tr></table></figure>

<h4 id="获取多容器pod的日志时指定容器名称"><a href="#获取多容器pod的日志时指定容器名称" class="headerlink" title="获取多容器pod的日志时指定容器名称"></a>获取多容器<code>pod</code>的日志时指定容器名称</h4><p>如果我们的<code>pod</code>包含多个容器, 在运行<code>kubectl logs</code>命令时则必须通过包含<code>-c &lt;容器名称&gt;</code>选项来显示指定容器名称. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;pod名称&gt; -c &lt;容器名称&gt;</span><br></pre></td></tr></table></figure>

<p>我们只能获取仍然存在的<code>pod</code>的日志. 当一个<code>pod</code>被删除时, 它的日志也会被删除. 如果希望在<code>pod</code>删除之后仍然可以获取其日志, 我们需要设置中心化的, 集群范围的日志系统, 将所有日志存储到中心存储中. </p>
<h3 id="向pod发送请求"><a href="#向pod发送请求" class="headerlink" title="向pod发送请求"></a>向<code>pod</code>发送请求</h3><h4 id="将本地网络端口转发到pod中的端口"><a href="#将本地网络端口转发到pod中的端口" class="headerlink" title="将本地网络端口转发到pod中的端口"></a>将本地网络端口转发到<code>pod</code>中的端口</h4><p>如果想要在不通过<code>service</code>的情况下与某个特定的<code>pod</code>进行通信(出于调试或其他原因), <code>Kubernetes</code>将允许我们配置端口转发到该<code>pod</code>. 可以通过<code>kubectl port-forward</code>命令完成上述操作. 例如以下命名会将机器的本地端口<code>8888</code>转发到目标<code>pod</code>的端口<code>8080</code>: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl port-forward &lt;pod名称&gt; 8888:8080</span><br></pre></td></tr></table></figure>

<h2 id="使用标签组织pod"><a href="#使用标签组织pod" class="headerlink" title="使用标签组织pod"></a>使用标签组织<code>pod</code></h2><p>我们需要一种能够基于任意标准将上述<code>pod</code>组织成更小群体的方式. 此外, 我们希望通过一次操作对属于某个组的所有<code>pod</code>进行操作, 而不必单独为每个<code>pod</code>执行操作. </p>
<p>通过标签来组织<code>pod</code>和所有其他<code>Kubernetes</code>对象. </p>
<h3 id="介绍标签"><a href="#介绍标签" class="headerlink" title="介绍标签"></a>介绍标签</h3><p>标签是一种简单却功能强大的<code>Kubernetes</code>特性, 不仅可以组织<code>pod</code>, 也可以组织所有其他的<code>Kubernetes</code>资源. 详细来说, 标签是可以附加到任意资源的任意键值对, 用以选择具有该确切标签的资源(这是通过标签选择器完成的). 只要标签的<code>key</code>在资源内是唯一的, 一个资源便可以拥有多个标签. 通常我们创建资源时就会将标签附加到资源上, 但之后我们也可以在添加其他标签, 或者修改现有标签的值, 而无须重新创建资源. </p>
<p>金丝雀发布是指在部署新版本时, 先只让小部分用户体验新版本以观察新版本的表现, 然后再向所有用户进行推广, 这样可以防止暴露有问题的版本给过多的用户. </p>
<h3 id="创建pod时指定标签"><a href="#创建pod时指定标签" class="headerlink" title="创建pod时指定标签"></a>创建<code>pod</code>时指定标签</h3><h4 id="显示所有标签"><a href="#显示所有标签" class="headerlink" title="显示所有标签"></a>显示所有标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --show-labels</span><br></pre></td></tr></table></figure>

<h4 id="显示特定标签"><a href="#显示特定标签" class="headerlink" title="显示特定标签"></a>显示特定标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -L &lt;label1的key&gt;,&lt;label2的key&gt;</span><br></pre></td></tr></table></figure>

<h3 id="修改现有pod的标签"><a href="#修改现有pod的标签" class="headerlink" title="修改现有pod的标签"></a>修改现有<code>pod</code>的标签</h3><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label po &lt;pod的名称&gt; &lt;新label的key&gt;=&lt;新label的value&gt; </span><br></pre></td></tr></table></figure>

<h4 id="修改标签"><a href="#修改标签" class="headerlink" title="修改标签"></a>修改标签</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl label po &lt;pod的名称&gt; &lt;已存在label的key&gt;=&lt;label的值&gt;</span><br></pre></td></tr></table></figure>

<h2 id="通过标签选择器列出pod子集"><a href="#通过标签选择器列出pod子集" class="headerlink" title="通过标签选择器列出pod子集"></a>通过标签选择器列出<code>pod</code>子集</h2><p>标签选择器允许我们选择标记有特定标签的<code>pod</code>子集, 并对这些<code>pod</code>执行操作. 可以说标签选择器是一种能够根据是否包含具有特定值的特定标签来过滤资源的准则. </p>
<p>标签选择器根据资源的以下条件来选择资源:</p>
<p>包含(或不包含)使用特定键的标签</p>
<p>包含具有特定键和值的标签</p>
<p>包含就有特定值的标签, 但其值与我们指定的不同</p>
<h3 id="使用标签选择器列出pod"><a href="#使用标签选择器列出pod" class="headerlink" title="使用标签选择器列出pod"></a>使用标签选择器列出<code>pod</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po -l &#x27;&lt;label的key&gt;&#x27;</span><br><span class="line">kubectl get po -l &#x27;!&lt;label的key&gt;&#x27;</span><br><span class="line">kubectl get po -l &lt;label的key&gt;=&lt;label的value&gt;</span><br><span class="line">kubectl get po -l &lt;label的key&gt;!=&lt;label的value&gt;</span><br><span class="line">kubectl get po -l &lt;label的key&gt;in (&lt;label的value&gt;, &lt;label的value&gt;)</span><br><span class="line">kubectl get po -l &lt;label的key&gt;notin (&lt;label的value&gt;, &lt;label的value&gt;)</span><br></pre></td></tr></table></figure>

<h3 id="在标签选择器中使用多个条件"><a href="#在标签选择器中使用多个条件" class="headerlink" title="在标签选择器中使用多个条件"></a>在标签选择器中使用多个条件</h3><p>在包含多个逗号分隔的情况下, 可以在标签选择器中同时使用多个条件, 此时资源需要全部匹配才算成功匹配了选择器. </p>
<h2 id="使用标签和选择器来约束pod调度"><a href="#使用标签和选择器来约束pod调度" class="headerlink" title="使用标签和选择器来约束pod调度"></a>使用标签和选择器来约束<code>pod</code>调度</h2><h3 id="使用标签分类工作节点"><a href="#使用标签分类工作节点" class="headerlink" title="使用标签分类工作节点"></a>使用标签分类工作节点</h3><p>标签可以附加到任何<code>kubernetes</code>对象上, 包括节点. </p>
<h3 id="将pod调度到特定节点"><a href="#将pod调度到特定节点" class="headerlink" title="将pod调度到特定节点"></a>将<code>pod</code>调度到特定节点</h3><p>为了让调度器只在合适节点上进行选择, 我们需要在<code>pod</code>的<code>YAML</code>文件中添加一个节点选择器. 我们只是在<code>spec</code>部分添加了一个<code>nodeSelector</code>字段. </p>
<h3 id="调度到一个特定节点"><a href="#调度到一个特定节点" class="headerlink" title="调度到一个特定节点"></a>调度到一个特定节点</h3><p>同样地, 我们也可以将<code>pod</code>调度到某个确定的节点, 由于每个节点都有一个唯一标签, 其中键为<code>kubernetes.io/hostname</code>, 值为该节点的实际主机名, 因此我们也可以将<code>pod</code>调度到某个确定的节点. 我们绝不应该考虑单个节点, 而是应该通过标签选择器考虑符合特定标准的逻辑节点组. </p>
<h2 id="注解pod"><a href="#注解pod" class="headerlink" title="注解pod"></a>注解<code>pod</code></h2><p>除标签外, <code>pod</code>和其他对象还可以包含注解. 注解也是键值对, 所以它们本质上与标签非常相似. 但与标签不同, 注解并不是为了保存标识信息而存在的, 它们不能像标签一样用于对对象进行分组. </p>
<p>大量使用注解可以为每个<code>pod</code>或其他<code>API</code>对象添加说明, 以便每个使用该集群的人都可以快速查找有关每个单独对象的信息. </p>
<h3 id="查找对象的注解"><a href="#查找对象的注解" class="headerlink" title="查找对象的注解"></a>查找对象的注解</h3><p>为了查看注解, 我们需要获取<code>pod</code>的完整<code>YAML</code>文件或使用<code>kubectl describe</code>命令. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po &lt;pod的名称&gt; -o yaml</span><br><span class="line"></span><br><span class="line">kubectl describe</span><br></pre></td></tr></table></figure>

<h3 id="添加和修改注解"><a href="#添加和修改注解" class="headerlink" title="添加和修改注解"></a>添加和修改注解</h3><p>和标签一样, 注解可以在创建是就添加到<code>pod</code>中, 也可以在之后再对现有的<code>pod</code>进行添加或修改. 其中将注解添加到现有对象的最简单的方式是通过<code>kubectl annotate</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl annotate pod &lt;pod的名称&gt; &lt;注解的键&gt;=&lt;注解的值&gt;</span><br></pre></td></tr></table></figure>

<h2 id="使用命名空间对资源进行分组"><a href="#使用命名空间对资源进行分组" class="headerlink" title="使用命名空间对资源进行分组"></a>使用命名空间对资源进行分组</h2><p><code>Kubernetes</code>命名空间简单地为对象名称提供了一个作用域. 此时我们并不会将所有资源都放在同一个命名空间中, 而是将它们组织到多个命名空间中, 这样可以允许我们多次使用相同的资源名称. </p>
<h3 id="发现其他命名空间及其pod"><a href="#发现其他命名空间及其pod" class="headerlink" title="发现其他命名空间及其pod"></a>发现其他命名空间及其<code>pod</code></h3><p>列出命名空间: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ns</span><br></pre></td></tr></table></figure>

<p>当使用<code>kubectl get</code>命令列出资源时, 我们从未明确指定命名空间, 因此<code>kubectl</code>总是默认为<code>default</code>命名空间, 只显示该命名空间下的对象. </p>
<p>得到指定命名空间下的对象: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get po -n &lt;命名空间&gt;</span><br></pre></td></tr></table></figure>

<p><code>namespace</code>使我们能够将不属于一组的资源分到不重叠的组中. 如果有多个用户或用户组正在使用同一个<code>Kubernetes</code>集群, 并且它们都各自管理自己独特的资源集合, 那么它们就应该使用各自的命名空间. 这样一来, 它们就不用特别担心无意中修改或删除其他用户的资源, 也无须关心名称冲突. 如前所述, 命名空间为资源名称提供了一个作用域. </p>
<p>除了隔离资源, 命名空间还可用于仅允许某些用户访问特定资源, 甚至限制单个用户可用的计算资源数量. </p>
<h3 id="创建一个命名空间"><a href="#创建一个命名空间" class="headerlink" title="创建一个命名空间"></a>创建一个命名空间</h3><p>命名空间是一种和其他资源一样的<code>Kubernetes</code>资源, 因此可以通过将<code>YAML</code>文件提交到<code>Kubernetes API</code>服务器来创建该资源. </p>
<p>还可以使用<code>kubectl create namespace</code>命令创建命名空间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create namespace &lt;命名空间&gt;</span><br></pre></td></tr></table></figure>

<p>命名空间只能包含字母, 数字, 横杠</p>
<h3 id="管理其他命名空间中的对象"><a href="#管理其他命名空间中的对象" class="headerlink" title="管理其他命名空间中的对象"></a>管理其他命名空间中的对象</h3><p>如果想在指定的命名空间中创建资源, 可以选择在<code>metedata</code>字段中添加一个<code>namespace: custom-namespace</code>属性, 也可以使用<code>kubectl create</code>命令创建资源时指定命名空间: </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f 模版 -n &lt;命名空间&gt;</span><br></pre></td></tr></table></figure>

<p>在列出, 描述, 修改或删除其他命名空间中的对象时, 需要给<code>kubectl</code>命令传递<code>--namespace</code>(或<code>-n</code>)选项. 如果不指定命名空间, <code>kubectl</code>将在当前上下文中配置的默认命名空间中执行操作. </p>
<h3 id="命名空间提供的隔离"><a href="#命名空间提供的隔离" class="headerlink" title="命名空间提供的隔离"></a>命名空间提供的隔离</h3><p>尽管命名空间将对象分隔到不同组, 只允许你对属于特定命名空间的对象进行操作, 但实际上命名空间之间并不提供对正在运行的对象的任何隔离. </p>
<h2 id="停止和移除pod"><a href="#停止和移除pod" class="headerlink" title="停止和移除pod"></a>停止和移除<code>pod</code></h2><h3 id="按名称删除pod"><a href="#按名称删除pod" class="headerlink" title="按名称删除pod"></a>按名称删除<code>pod</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete po &lt;po的名称&gt; [&lt;pod名称&gt;...]</span><br></pre></td></tr></table></figure>

<p>在删除<code>pod</code>的过程中, 实际上我们在指示<code>Kubernetes</code>终止该<code>pod</code>中的所有容器. <code>Kubernetes</code>向进程发送一个<code>SIGTERM</code>信号并等待一定的秒数(默认为30), 使其正常关闭. 如果它没有及时关闭, 则通过<code>SIGKILL</code>终止该进程. 因此, 为了确保你的进程总是正常关闭, 进程需要正确处理<code>SIGTERM</code>信号. </p>
<h3 id="使用标签选择器删除pod"><a href="#使用标签选择器删除pod" class="headerlink" title="使用标签选择器删除pod"></a>使用标签选择器删除<code>pod</code></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete po -l &lt;label的名称&gt;=&lt;label的值&gt;</span><br></pre></td></tr></table></figure>

<h3 id="通过删除整个命名空间来删除pod"><a href="#通过删除整个命名空间来删除pod" class="headerlink" title="通过删除整个命名空间来删除pod"></a>通过删除整个命名空间来删除<code>pod</code></h3><p>可以通过删除整个命名空间来删除这个命名空间, 以及这个命名空间下的<code>pod</code>. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete ns &lt;命名空间&gt;</span><br></pre></td></tr></table></figure>

<h3 id="删除命名空间中所有pod-当保留命名空间"><a href="#删除命名空间中所有pod-当保留命名空间" class="headerlink" title="删除命名空间中所有pod, 当保留命名空间"></a>删除命名空间中所有<code>pod</code>, 当保留命名空间</h3><p>删除当前命名空间中的所有<code>pod</code>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete po --all</span><br></pre></td></tr></table></figure>

<h3 id="删除命名空间中的-几乎-所有资源"><a href="#删除命名空间中的-几乎-所有资源" class="headerlink" title="删除命名空间中的(几乎)所有资源"></a>删除命名空间中的(几乎)所有资源</h3><p>通过使用单个命令删除当前命名空间中的所有资源:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete all --all</span><br></pre></td></tr></table></figure>

<p>使用<code>all</code>关键字删除所有内容并不是真的删除所有内容. 一些资源会被保留下来, 并且需要被明确指定删除. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Kubernetes%E5%92%8CDocker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/20/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Kubernetes%E5%92%8CDocker/" class="post-title-link" itemprop="url">开始使用Kubernetes和Docker</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-20 21:54:21" itemprop="dateCreated datePublished" datetime="2023-09-20T21:54:21+08:00">2023-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 23:09:21" itemprop="dateModified" datetime="2023-11-08T23:09:21+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>545</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="开始使用Kubernetes和Docker"><a href="#开始使用Kubernetes和Docker" class="headerlink" title="开始使用Kubernetes和Docker"></a>开始使用<code>Kubernetes</code>和<code>Docker</code></h1><h2 id="在Kubernetes上运行第一个应用"><a href="#在Kubernetes上运行第一个应用" class="headerlink" title="在Kubernetes上运行第一个应用"></a>在<code>Kubernetes</code>上运行第一个应用</h2><h3 id="部署Node-js应用"><a href="#部署Node-js应用" class="headerlink" title="部署Node.js应用"></a>部署<code>Node.js</code>应用</h3><p>部署应用程序最简单的方式是使用<code>kubectl run</code>命令, 该命令可以创建所有必要的组件而无需<code>JSON</code>或<code>YAML</code>. </p>
<h4 id="介绍pod"><a href="#介绍pod" class="headerlink" title="介绍pod"></a>介绍<code>pod</code></h4><p>一个<code>pod</code>是一组紧密相关的容器, 它们总是运行在同一个工作节点上, 以及同一个<code>Linux</code>命名空间中. 每个<code>pod</code>就像一个独立的逻辑机器, 拥有自己的IP, 主机名, 进程等, 运行一个独立的应用程序. </p>
<h4 id="列出pod"><a href="#列出pod" class="headerlink" title="列出pod"></a>列出<code>pod</code></h4><p>不能列出单个容器, 因为它们不是独立的<code>Kubernetes</code>对象, 但是可以列出<code>pod</code>. 要查看有关<code>pod</code>的更多信息, 还可以使用<code>kubectl describe pod</code>命令. </p>
<h3 id="访问WEB应用"><a href="#访问WEB应用" class="headerlink" title="访问WEB应用"></a>访问<code>WEB</code>应用</h3><p>每个<code>pod</code>都有自己的IP地址, 但是这个地址是集群内部的, 不能从集群外部访问. 要让<code>pod</code>能够从外部访问, 需要通过服务对象公开它, 要创建一个特殊的<code>LoadBalancer</code>类型的服务. 因为如果你创景一个常规服务(一个<code>ClusterIP</code>服务), 比如<code>pod</code>, 它也只能从集群内部访问. 通过创建<code>LoaBalancer</code>类型的服务, 将创建一个外部的负载均衡, 通过负载均衡的公共IP访问<code>pod</code>. </p>
<h4 id="创建一个服务对象"><a href="#创建一个服务对象" class="headerlink" title="创建一个服务对象"></a>创建一个服务对象</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose &lt;需要暴露的pod类型&gt; &lt;需要暴露的pod名称&gt; --type=&lt;暴露的类型&gt; --name=&lt;暴露的名称&gt; </span><br></pre></td></tr></table></figure>

<h4 id="列出服务"><a href="#列出服务" class="headerlink" title="列出服务"></a>列出服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure>

<h3 id="系统的逻辑部分"><a href="#系统的逻辑部分" class="headerlink" title="系统的逻辑部分"></a>系统的逻辑部分</h3><p>一个服务被创建时, 它会得到一个静态的<code>IP</code>, 在服务的生命周期中这个IP不会发生改变. 客户端应该通过固定IP地址连接到服务, 而不是直接连接<code>pod</code>. </p>
<p>服务表示一组或多组提供相同服务的<code>pod</code>的静态地址. 到达服务<code>IP</code>和端口的请求将被转发到属于该服务的一个容器的<code>IP</code>和端口</p>
<h4 id="水平伸缩应用"><a href="#水平伸缩应用" class="headerlink" title="水平伸缩应用"></a>水平伸缩应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale &lt;需要暴露的pod类型&gt; &lt;需要暴露的pod名称&gt; --replicas=&lt;数量&gt;</span><br></pre></td></tr></table></figure>

<h4 id="列出pod时显示pod-IP和pod的节点"><a href="#列出pod时显示pod-IP和pod的节点" class="headerlink" title="列出pod时显示pod IP和pod的节点"></a>列出<code>pod</code>时显示<code>pod IP</code>和<code>pod</code>的节点</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/18/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/Kubernetes%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/18/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/Kubernetes%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">Kubernetes介绍</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-18 23:11:17" itemprop="dateCreated datePublished" datetime="2023-09-18T23:11:17+08:00">2023-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-08 23:05:39" itemprop="dateModified" datetime="2023-11-08T23:05:39+08:00">2023-11-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kubernete介绍"><a href="#Kubernete介绍" class="headerlink" title="Kubernete介绍"></a>Kubernete介绍</h1><p><code>Kubernetes</code>使开发者可以自主部署应用, 并且控制部署的频率, 完全脱离运维团队的版主. <code>Kubernetes</code>同时能够让运维团队监控整个系统, 并且在硬件故障时重新调度应用. 系统管理员的工作重心, 从监管应用转移到了监管<code>Kubernetes</code>, 以及剩余的系统资源, 因为<code>Kubernetes</code>会帮助监管所有的应用. </p>
<h2 id="Kubernetes系统的需求"><a href="#Kubernetes系统的需求" class="headerlink" title="Kubernetes系统的需求"></a><code>Kubernetes</code>系统的需求</h2><h3 id="从单体应用到微服务"><a href="#从单体应用到微服务" class="headerlink" title="从单体应用到微服务"></a>从单体应用到微服务</h3><p>单体应用由很多个组件构成, 这些组件紧密地耦合在一起, 由于它们在同一操作系统进程中运行, 所以在开发, 部署, 管理的时候必须以同一个实体运行. 对单体应用来说, 即使是某个组件中一个小的修改, 都需要重新部署整个应用. 组件间缺乏严格的边界定义, 相互依赖, 日积月累导致系统复杂度提升, 整体质量也急剧恶化. </p>
<h4 id="将应用拆解为多个微服务"><a href="#将应用拆解为多个微服务" class="headerlink" title="将应用拆解为多个微服务"></a>将应用拆解为多个微服务</h4><p>这个问题迫使我们将复杂的大体单体应用, 拆分为小的可独立部署的微服务组件. 每个微服务以独立的进程运行, 并通过简单且定义良好的接口<code>(API)</code>与其他的微服务通信. </p>
<p>因为每个微服务都是独立的进程, 提供相对静态的<code>API</code>, 所以独立开发和部署单个微服务成为了可能. 只要<code>API</code>不变或者向前兼容, 改动一个微服务, 并不会要求其他微服务进行改动或重新部署. </p>
<h4 id="微服务的扩容"><a href="#微服务的扩容" class="headerlink" title="微服务的扩容"></a>微服务的扩容</h4><p>面向单体系统, 扩容针对的是整个系统, 而面向微服务架构, 库容却只需要针对单个服务, 这意味着你可以选择扩容那些需要更多资源的服务而保持其他的服务仍然维持在原来的规模. </p>
<h4 id="部署微服务"><a href="#部署微服务" class="headerlink" title="部署微服务"></a>部署微服务</h4><p>像大多数情况一样, 微服务也有缺点. 部署微服务, 部署者需要正确地配置所有服务来使其作为一个单一系统能正确工作, 随着微服务的数量不断增加, 配置工作变得冗余且易错.</p>
<p>微服务还带来其他问题, 比如因为垮了多个进程和机器, 使得调试代码和定位异常调用变得困难. </p>
<h3 id="为应用程序提供一个一致的环境"><a href="#为应用程序提供一个一致的环境" class="headerlink" title="为应用程序提供一个一致的环境"></a>为应用程序提供一个一致的环境</h3><p>不管你同时开发和部署多少个独立组件, 开发和运维团队总是需要解决的一个最大的问题是程序运行环境的差异性. 为了减少会在生产环境才会暴露的问题, 最理想的做法是让应用在开发和生产可以运行在完全一样的环境下. </p>
<h3 id="迈向持续交付-DevOps和无运维"><a href="#迈向持续交付-DevOps和无运维" class="headerlink" title="迈向持续交付: DevOps和无运维"></a>迈向持续交付: <code>DevOps</code>和无运维</h3><p>让同一个团队参与应用的开发, 部署, 运维的整个生命周期更好. 这意味着开发, <code>QA</code>和运维团队彼此之间的合作需要贯穿整个流程. 这种实践称为<code>DevOps</code>. </p>
<p>理想情况是, 开发者自己部署程序本身, 不需要知道硬件基础设施的任何情况, 也不需要和运维团队交涉, 这被叫作<code>NoOps</code>. 很明显, 你仍然需要有一些人来关心硬件基础设施, 但这些人不需要再处理应用程序的独特性. </p>
<p>正如你所看到的, <code>Kubernetes</code>能让我们实现所有这些想法. 通过对实际硬件做抽象, 然后将自身暴露成一个平台, 用于部署和运行应用程序. 它允许开发者自己配置和部署应用程序, 而不需要系统管理员的任何帮助, 让系统管理员聚焦于保持底层基础设施运转正常的同时, 不需要关注实际运行在平台上的应用程序. </p>
<h2 id="介绍容器技术"><a href="#介绍容器技术" class="headerlink" title="介绍容器技术"></a>介绍容器技术</h2><p><code>Kubernetes</code>使用<code>Linux</code>容器技术来提供应用隔离. </p>
<h3 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h3><p>当一个应用程序仅由较少数量的大组件构成时, 完全可以接受给每个组件分配专用的虚拟机, 以及通过给每个组件提供自己的操作系统实例来隔离它们的环境. 当时当这些组件开始变小且数量开始增长时, 如果你不想浪费硬件资源, 又想持续压低硬件成本, 就不能给每个组件配置一个虚拟机了. </p>
<h4 id="用Linux容器技术隔离组件"><a href="#用Linux容器技术隔离组件" class="headerlink" title="用Linux容器技术隔离组件"></a>用Linux容器技术隔离组件</h4><p>开发者不是使用虚拟机来隔离每个微服务环境, 而是正在转向<code>Linux</code>容器技术. 容器允许你在同一台机器上运行多个服务, 不经是提供不同的环境给每个服务, 而且将它们互相隔离. 容器类似虚拟机, 但开销小很多. </p>
<p>一个容器里运行的进程实际上运行在宿主机的操作系统上, 就像所有其他进程一样(不像虚拟机, 进程是运行在不同的操作系统上的). 但在容器里的进程仍然是和其他进程隔离的. 对于容器内进程本身而言, 就好像是在机器和操作系统上运行的唯一一个进程. </p>
<h4 id="比较虚拟机和容器"><a href="#比较虚拟机和容器" class="headerlink" title="比较虚拟机和容器"></a>比较虚拟机和容器</h4><p>和虚拟机计较, 容器更加轻量级, 它允许在相同的硬件上运行更多数量的组件. 主要是因为每个虚拟机需要运行自己的一组系统进程, 这就产生了除组件进程消耗以外的额外计算资源损耗. 从另一方面说, 一个容器仅仅是运行在宿主机上被隔离的单个进程, 仅消耗应用容器消耗的资源, 不会有其他进程的开销. </p>
<p>虚拟机需要一个管理程序, 它将物理硬件资源分成较小部分的虚拟硬件资源, 从而被每个虚拟机里的操作系统使用. 运行在那些虚拟机里的应用程序会执行虚拟机操作系统的系统调用, 然后虚拟机内核会通过管理程序在宿主机上的物理CPU执行指令. </p>
<p>多个容器则会完全执行运行在宿主机上的同一个内核的系统调用, 此内核是唯一一个在宿主机操作系统上执行指令的内核. CPU也不需要做任何对虚拟机那样的虚拟化. </p>
<p>虚拟机的主要好处是它们提供完全隔离的环境, 因为每个虚拟机运行在它自己的<code>Linux</code>内核上, 而容器都是调用同一个内核, 这自然会有安全隐患. 如果你的硬件资源有限, 那当你有少量进程需要隔离的时候, 虚拟机就可以成为一个选项. 为了在同一台机器上运行大量被隔离的进程, 容器因它的低消耗而成为一个更好的选择. </p>
<h4 id="容器实现隔离机制介绍"><a href="#容器实现隔离机制介绍" class="headerlink" title="容器实现隔离机制介绍"></a>容器实现隔离机制介绍</h4><p>容器如何隔离进程的, 有两个机制可用: 第一个是<code>Linux</code>命名空间, 它使每个进程只能看到它自己的系统视图(文件, 进程, 网络接口, 主机名等); 第二个是<code>Linux</code>控制组(<code>cgroups</code>), 它限制了进程能使用的资源量(CPU, 内存, 网络带宽等). </p>
<h4 id="用Linux命名空间隔离进程"><a href="#用Linux命名空间隔离进程" class="headerlink" title="用Linux命名空间隔离进程"></a>用<code>Linux</code>命名空间隔离进程</h4><p>默认情况下, 每个<code>Linux</code>系统最初仅有一个命名空间. 所有系统资源(诸如文件系统, 用户ID, 网络接口等)属于这一个命名空间. 但是你能创建额外的命名空间, 以及在它们之间组织资源. 对于进程, 可以在其中一个命名空间中运行它. 进程将只能看到同一个命名空间下的资源. 当然, 会存在多种类型的多个命名空间, 所以一个进程不单单只属于某一个命名空间, 而属于每个类型的一个命名空间. </p>
<p>存在以下类型的命名空间:</p>
<ol>
<li><code>Mount(mnt)</code></li>
<li><code>Process(pid)</code></li>
<li><code>Network(net)</code></li>
<li><code>Inter-process communication(ipd)</code></li>
<li><code>UTS</code></li>
<li><code>User Id(user)</code></li>
</ol>
<p>每种命名空间被用来隔离一组特定的资源. </p>
<h4 id="限制进程的可用资源"><a href="#限制进程的可用资源" class="headerlink" title="限制进程的可用资源"></a>限制进程的可用资源</h4><p>另外的隔离性就是限制容器能使用的系统资源. 这通过<code>cgroups</code>来实现. <code>cgroups</code>是一个<code>Linux</code>内核功能, 它被用来限制一个进程或者一组进程的资源使用. 一个进程的资源(CPU, 内存, 网络带宽等)使用量不能超出被分配使用的量. 这种方式下, 进程不能过分使用为其他进程保留的资源, 这和进程运行在不同的机器上是类似的. </p>
<h3 id="Docker容器平台介绍"><a href="#Docker容器平台介绍" class="headerlink" title="Docker容器平台介绍"></a><code>Docker</code>容器平台介绍</h3><p><code>Docker</code>不仅简化了打包应用的流程, 也简化了打包应用的库和依赖, 甚至整个操作系统地文件都能被打包成一个简单的可移植的包, 这个包可以被用来在任何其他运行<code>Docker</code>的机器上使用. </p>
<h4 id="Docker的概念"><a href="#Docker的概念" class="headerlink" title="Docker的概念"></a><code>Docker</code>的概念</h4><p><code>Docker</code>是一个打包, 分发和运行应用程序的平台. <code>Docker</code>中三个主要的概念.</p>
<ol>
<li>镜像: <code>Docker</code>镜像里包含了你打包的应用程序及其所依赖的环境. 它包含应用程序可用的文件系统和其他元数据, 如镜像运行时的可执行文件路径. </li>
<li>镜像仓库: <code>Docker</code>镜像仓库用于存放<code>Docker</code>镜像, 以及促进不同人和不同电脑之间共享这些镜像. </li>
<li>容器: <code>Docker</code>容器通常是一个<code>Linux</code>容器, 它基于<code>Dokcer</code>镜像被创建. 一个运行中的容器是一个运行在<code>Docker</code>主机的进程, 但它和主机, 以及所有运行在主机的其他进程都是隔离的. 这个进程也是资源受限的, 意味着它只能访问和使用分配给它的资源(CPU, 内存等).</li>
</ol>
<h4 id="镜像层"><a href="#镜像层" class="headerlink" title="镜像层"></a>镜像层</h4><p>层不仅使分发更高效, 也助于减少镜像的存储空间. 每一层被存一次, 当基于相同基础层的镜像被创建成两个容器时, 它们就能够读取相同的文件. 但是如果其中一个容器写入某些文件, 另外一个是无法看见文件变更的. 因此, 即使它们共享文件, 仍然彼此隔离. 这是因为容器镜像层是只读的. 容器运行时, 一个新的可写在镜像层之上被创建. 容器中进程写入位于底层的一个文件时, 此文件的一个拷贝在顶层被创建, 进程写的是此拷贝. </p>
<h4 id="容器镜像可移植性的限制"><a href="#容器镜像可移植性的限制" class="headerlink" title="容器镜像可移植性的限制"></a>容器镜像可移植性的限制</h4><p>理论上, 一个容器镜像能运行在任何一个运行<code>Docker</code>的机器上. 但是如果一个容器化的应用需要一个特定的内核版本, 那它可能不能在每台机器上都工作. 如果一台机器运行了一个不匹配的<code>Linux</code>内核版本, 或者没有相同内核模块可用,  那么此应用就不能在其上运行. </p>
<h2 id="Kubernetes介绍"><a href="#Kubernetes介绍" class="headerlink" title="Kubernetes介绍"></a><code>Kubernetes</code>介绍</h2><h3 id="深入浅出地了解Kubernetes"><a href="#深入浅出地了解Kubernetes" class="headerlink" title="深入浅出地了解Kubernetes"></a>深入浅出地了解<code>Kubernetes</code></h3><p><code>Kubernets</code>是一个软件系统, 它允许你在其上很容易地部署和管理容器化的应用. <code>Kubernetes</code>使你在数以千计的电脑节点上运行软件时就像所有节点是单个大节点一样. </p>
<h4 id="Kubenetes的核心功能"><a href="#Kubenetes的核心功能" class="headerlink" title="Kubenetes的核心功能"></a><code>Kubenetes</code>的核心功能</h4><p>整个系统由一个主节点和若干个工作节点组成. 开发者把一个应用列表提交到主节点, <code>Kubernetes</code>会将它们部署到集群的工作节点. </p>
<p>开发者能指定一些应用必须一起运行, <code>Kubernets</code>将会在一个工作节点上部署它们. 其他的将被分散部署到集群中, 但是不管部署在哪儿, 它们都能以相同的方式相互通信. </p>
<h3 id="Kubernetes集群架构"><a href="#Kubernetes集群架构" class="headerlink" title="Kubernetes集群架构"></a><code>Kubernetes</code>集群架构</h3><p>在硬件级别, 一个<code>Kubernetes</code>集群由很多节点组成, 这些节点被分成以下两种类型:</p>
<ol>
<li>主节点: 它承载着<code>Kubernetes</code>控制和管理整个集群系统地控制面板</li>
<li>工作节点: 它们运行用户实际部署的应用</li>
</ol>
<h4 id="控制面板"><a href="#控制面板" class="headerlink" title="控制面板"></a>控制面板</h4><p>控制面板用于控制集群并使它工作. 它包含多个组件, 组件可以运行在单个主节点或者通过副本分别部署在多个主节点以确保高可用性. 这些组件是:</p>
<ol>
<li><code>Kubernetes API</code>服务器, 你和其他控制面板组件都要和它通信.</li>
<li><code>Scheduler</code>, 它调度你的应用(为应用的每个部署组件分配一个工作节点).</li>
<li><code>Controller Mananger</code>, 它执行集群基本的工作, 如复制组件, 持续跟踪工作节点, 处理节点失败等. </li>
<li><code>etcd</code>, 一个可靠的分布式数据存储, 它能持久化存储集群配置.</li>
</ol>
<p>控制面板的组件持有并控制集群状态, 但是它们不运行你的应用程序. 这是由工作节点完成的. </p>
<h4 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h4><p>工作节点是运行容器化应用的机器. 运行, 监控和管理应用服务的任务是由以下组件完成的: </p>
<ol>
<li><code>Docker</code>, <code>rtk</code>或其他的容器类型</li>
<li><code>Kubelet</code>, 它与API服务器通信, 并管理它所在节点的容器</li>
<li><code>Kubernetes Service Proxy(kube-proxy)</code>, 它负责组件之间的负载均衡网络流量</li>
</ol>
<h3 id="在Kubernetes中运行应用"><a href="#在Kubernetes中运行应用" class="headerlink" title="在Kubernetes中运行应用"></a>在<code>Kubernetes</code>中运行应用</h3><h4 id="描述信息怎样成为一个运行的容器"><a href="#描述信息怎样成为一个运行的容器" class="headerlink" title="描述信息怎样成为一个运行的容器"></a>描述信息怎样成为一个运行的容器</h4><p>当<code>API</code>服务器处理应用描述时, 调度器选择可用的工作节点. 选择时基于所需要的计算资源, 以及调度时每个节点未分配的资源. 然后, 那些节点上的<code>Kubelet</code>指示容器运行时拉取所需要的镜像并运行容器. </p>
<h4 id="保持容器运行"><a href="#保持容器运行" class="headerlink" title="保持容器运行"></a>保持容器运行</h4><p>一旦应用程序运行起来, <code>Kubernetes</code>就会不断地确认应用程序的部署状态始终与你提供的描述相匹配. 如果实例之一停止了正常工作, 比如进程崩溃或停止响应时, <code>Kubernetes</code>将自动重启它. </p>
<p>同理, 如果整个工作节点死亡或无法访问, <code>Kubernetes</code>将为在故障节点上运行的所有容器选择新节点, 并在新选择地节点上运行它们. </p>
<h4 id="扩展副本数量"><a href="#扩展副本数量" class="headerlink" title="扩展副本数量"></a>扩展副本数量</h4><p>当应用程序运行时, 可以决定要增加或减少副本量, 而<code>Kubernetes</code>将分别增加附加的或停止多余的副本. 甚至可以把决定最佳副本数目的工作交给<code>Kubernetes</code>. 它可以根据实时指标(CPU负载, 内存消耗, 每秒查询或应用程序公开的任何其他指标)自动调整副本数. </p>
<h4 id="命中移动目标"><a href="#命中移动目标" class="headerlink" title="命中移动目标"></a>命中移动目标</h4><p><code>Kubernetes</code>可能需要在集群中迁移你的容器. 当它们运行的节点失败时, 或者为了给其他容器腾出地方而从节点移除时, 就会发生这种情况.</p>
<p>为了让客户能够轻松找到提供特定服务的容器, 可以告诉<code>Kubernetes</code>哪些容器提供相同的服务, 而<code>Kubernetes</code>将通过一个静态IP地址暴露所有容器, 并将该地址暴露给集群中运行的所有应用程序. 这是通过环境变量完成的, 但是客户端也可以通过良好的DNS查找服务器IP. 服务的IP地址保持不变, 因此客户端始终可以连接到它的容器, 即使它们在集群中移动. </p>
<h3 id="使用Kubernetes的好处"><a href="#使用Kubernetes的好处" class="headerlink" title="使用Kubernetes的好处"></a>使用<code>Kubernetes</code>的好处</h3><p>如果在所有服务器上都部署了<code>Kubernetes</code>, 那么运维团队就不需要在部署应用程序. </p>
<h4 id="简化应用程序部署"><a href="#简化应用程序部署" class="headerlink" title="简化应用程序部署"></a>简化应用程序部署</h4><p>由于<code>Kubernetes</code>将其所有工作节点作为一个部署平台, 因此应用程序开发人员可以开始自己开始部署应用程序, 不需要了解组成集群的服务器. </p>
<h4 id="健康检查和自修复"><a href="#健康检查和自修复" class="headerlink" title="健康检查和自修复"></a>健康检查和自修复</h4><p>当服务器发生故障时, 拥有一个允许在任何时候跨集群迁移应用程序的系统也很有价值. </p>
<p><code>Kubernetes</code>监控你的应用程序组件和它们运行的节点, 并在节点出现故障时自动将它们重新调度到其他节点. 这使运维团队不必手动迁移应用程序组件, 并允许团队立即专注与修复节点本身, 并将其修好送回到可用的硬件资源池中. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/13/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/Kubernetes%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">Kubernetes集群搭建与配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-13 21:28:16" itemprop="dateCreated datePublished" datetime="2023-09-13T21:28:16+08:00">2023-09-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-02 22:28:50" itemprop="dateModified" datetime="2023-10-02T22:28:50+08:00">2023-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>170</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Kubernetes集群搭建和配置"><a href="#Kubernetes集群搭建和配置" class="headerlink" title="Kubernetes集群搭建和配置"></a><code>Kubernetes</code>集群搭建和配置</h1><h2 id="Kubernetes部署利器-kubeadm"><a href="#Kubernetes部署利器-kubeadm" class="headerlink" title="Kubernetes部署利器: kubeadm"></a><code>Kubernetes</code>部署利器: <code>kubeadm</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个Master节点</span></span><br><span class="line">kubeadm init</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个Node节点加入当前集群</span></span><br><span class="line">kubeadm join &lt;Master节点的IP和端口&gt;</span><br></pre></td></tr></table></figure>

<h3 id="kubeadm的工作原理"><a href="#kubeadm的工作原理" class="headerlink" title="kubeadm的工作原理"></a><code>kubeadm</code>的工作原理</h3><p>在部署时, 它的每个组件都是一个需要被执行的, 单独的二进制文件. </p>
<h4 id="Kubernetes集群初始化"><a href="#Kubernetes集群初始化" class="headerlink" title="Kubernetes集群初始化"></a><code>Kubernetes</code>集群初始化</h4><p><code>Kubernetes</code>中有一种特殊的容器启动方法, 叫做<code>static pod</code>. 它允许你把要部署的<code>pod</code>的<code>YAML</code>文件放在一个指定的目录中. 这样, 当这台机器上的<code>kubelet</code>启动时, 它会自动检查该目录, 加载所有的<code>Pod YAML</code>文件并在这台机器上启动它们. </p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/Goroutines%E5%92%8CChannels/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/05/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/Goroutines%E5%92%8CChannels/" class="post-title-link" itemprop="url">Goroutines和Channels</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-05 23:04:24" itemprop="dateCreated datePublished" datetime="2023-09-05T23:04:24+08:00">2023-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-10 01:30:43" itemprop="dateModified" datetime="2023-09-10T01:30:43+08:00">2023-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Goroutines和Channels"><a href="#Goroutines和Channels" class="headerlink" title="Goroutines和Channels"></a><code>Goroutines</code>和<code>Channels</code></h1><p><code>Go</code>语言中的并发程序可以用两种手段来实现. <code>goroutine</code>和<code>channel</code>, 其支持”顺序通信进程”<code>(CSP)</code>. <code>CSP</code>是一种现代的并发编程模型, 在这种编程模型中值会在不同的运行实例<code>goroutine</code>中传递, 尽管大多数情况下仍然是被限制在单一实例中. </p>
<h2 id="Goroutines"><a href="#Goroutines" class="headerlink" title="Goroutines"></a><code>Goroutines</code></h2><p>在<code>Go</code>语言中, 每一个并发的执行单元叫作一个<code>goroutine</code>. 当一个程序启动时, 其主函数即在一个单独的<code>goroutine</code>中运行, 我们叫它<code>main goroutine</code>. 新的<code>gorountine</code>会用<code>go</code>语句来创建. 在语法上, <code>go</code>语句是一个普通的函数或方法调用前加上关键字<code>go</code>. <code>go</code>语句会使其语句中的函数在一个新创建的<code>goroutine</code>中运行. 而<code>go</code>语句本身会迅速地完成. </p>
<p>主函数返回时, 所有的<code>goroutine</code>都会被直接打断, 程序退出. 除了从主函数退出或者直接终止程序之外, 没有其它的编程方法能够让一个<code>goroutine</code>来打断另一个执行, 但是之后可以看到一种方式来实现这个目的, 通过<code>goroutine</code>之间的通信来让一个<code>goroutine</code>请求其它的<code>goroutine</code>, 让被请求的<code>goroutine</code>自行结束执行. </p>
<h2 id="示例-并发的Clock服务"><a href="#示例-并发的Clock服务" class="headerlink" title="示例: 并发的Clock服务"></a>示例: 并发的<code>Clock</code>服务</h2><p><code>time.Time.Format</code>将时间格式化. <code>time.Parse</code>将字符串转化为时间. </p>
<h2 id="示例-并发的Echo服务"><a href="#示例-并发的Echo服务" class="headerlink" title="示例: 并发的Echo服务"></a>示例: 并发的<code>Echo</code>服务</h2><p>函数值在循环体中才会出现捕获迭代变量的情况. </p>
<h2 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a><code>Channels</code></h2><p>如果说<code>goroutine</code>是<code>Go</code>语言程序的并发体的话, 那么<code>channels</code>是它们之间的通信机制. 一个<code>channels</code>是一个通信机制, 它可以让一个<code>goroutine</code>通过它给另一个<code>goroutine</code>发送值信息. 每个<code>channel</code>都有一个特殊的类型, 也就是<code>channels</code>可以发送的数据类型. 一个可以发送<code>int</code>类型数据的<code>channel</code>一般写作<code>chan int</code>.</p>
<p>使用内置的<code>make</code>函数, 我们可以创建一个<code>channel</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>和<code>map</code>类似, <code>channel</code>也是一个对应<code>make</code>创建的底层数据结构的引用. 当我们复制一个<code>channel</code>或用于函数传递参数时, 我们只是拷贝了一个<code>channel</code>引用, 因此调用者和被调用者讲引用同一个<code>channel</code>对象. 和其他的引用类型一样, <code>channel</code>的零值也是<code>nil</code>. </p>
<p>两个相同类型的<code>channel</code>可以使用<code>==</code>运算符比较. 如果两个<code>channel</code>引用的是相通的对象, 那么比较的结果为真. 一个<code>channel</code>也可以和<code>nil</code>进行比较. </p>
<p><code>channel</code>支持<code>close</code>操作, 用于关闭<code>channel</code>, 随后对与基于该<code>channel</code>的任何发送操作都将都导致<code>panic</code>异常. </p>
<h3 id="不带缓存的Channels"><a href="#不带缓存的Channels" class="headerlink" title="不带缓存的Channels"></a>不带缓存的<code>Channels</code></h3><p>一个基于无缓存<code>channel</code>的发送操作将导致发送者<code>goroutine</code>阻塞, 直到另一个<code>goroutine</code>在相同的<code>channel</code>上执行接收操作, 当发送的值通过<code>channel</code>成功传输之后, 两个<code>goroutine</code>可以继续执行后面的语句. 反之, 如果接收操作先发生, 那么接收者<code>goroutine</code>也将阻塞, 直到有另一个<code>goroutine</code>在相同的<code>channel</code>上执行发送操作. </p>
<h3 id="串联的channels-pipeline"><a href="#串联的channels-pipeline" class="headerlink" title="串联的channels(pipeline)"></a>串联的<code>channels(pipeline)</code></h3><p><code>channel</code>也可以用于将多个<code>goroutine</code>链接在一起, 一个<code>channel</code>的输出作为下一个<code>channel</code>输入. 这种串联的<code>channel</code>就是所谓的管道<code>pipeline</code>. </p>
<p>当一个<code>channel</code>被关闭后, 再向该<code>channel</code>发送数据将导致<code>panic</code>异常. 当一个被关闭的<code>channel</code>中已经发送的数据都被成功接收后, 后续的接收操作将不再阻塞, 它们会立即返回一个零值. </p>
<p>没有办法直接测试一个<code>channel</code>是否被关闭, 但是接收操作有一个变体形式: 它多接收一个结果, 多接收的第二个结果是一个布尔值, <code>true</code>表示成功从<code>channel</code>接收到值, <code>false</code>表示<code>channel</code>已经被关闭并且里面没有值可被接收. </p>
<p><code>Go</code>语言的<code>range</code>循环可直接在<code>channel</code>上迭代, 它依次从<code>channel</code>接收数据, 当<code>channel</code>被关闭并且没有值可被接收时跳出循环. </p>
<p>并不需要关闭每一个<code>channel</code>. 不管一个<code>channel</code>是否被关闭, 当它没有被引用时会被<code>Go</code>语言的垃圾自动回收器回收. </p>
<p>试图重复关闭一个<code>channel</code>将导致<code>panic</code>异常, 试图关闭一个<code>nil</code>的<code>channel</code>也将导致<code>panic</code>异常. 关闭<code>channel</code>还会触发一个广播机制. </p>
<h3 id="单方向的channel"><a href="#单方向的channel" class="headerlink" title="单方向的channel"></a>单方向的<code>channel</code></h3><p>当一个<code>channel</code>作为函数参数时, 它一般总是被专门用于只发送或者只接收. </p>
<p>为了表示这种意图并防止被滥用, <code>Go</code>语言的类型系统提供了单方向的<code>channel</code>类型, 分别用于只发送或只接收的<code>channel</code>. 类型<code>chan&lt;- int</code>表示一个只发送<code>int</code>的<code>channel</code>, 只能发送不能接收. 相反, 类型<code>&lt;-chan int</code>表示一个只接收<code>int</code>的<code>channel</code>, 只能接收不能发送. 这种限制将在编译期检测. </p>
<p>因为<code>close</code>操作说明了通道上没有数据再发送, 仅仅在发送方<code>goroutine</code>上才能调用它, 所以试图关闭一个仅能接收的<code>channel</code>在编译时会报错. </p>
<p>任何双向<code>channel</code>向单向<code>channel</code>变量的赋值操作都将导致隐式转换. 这里没有反向转换的语法, 也就是不能将单向<code>channel</code>转换为双向<code>channel</code>. </p>
<h3 id="带缓存的channel"><a href="#带缓存的channel" class="headerlink" title="带缓存的channel"></a>带缓存的<code>channel</code></h3><p>带缓存的<code>channel</code>内部持有一个元素队列. 队列的最大容量是在调用<code>make</code>函数创建<code>channel</code>时通过第二个参数指定的. </p>
<p>向缓存<code>channel</code>的发送操作就是向内部缓存队列的尾部插入元素, 接收操作则是从队列的头部删除元素. 如果内部缓存队列是满的, 那么发送操作将阻塞直到因另一个<code>goroutine</code>执行接收从而释放了新的队列空间. 相反, 如果<code>channel</code>是空的, 接收操作将阻塞直到有另一个<code>goroutine</code>执行发送操作而向队列插入元素. </p>
<p>在某些特殊情况下, 程序可能需要知道<code>channel</code>内部缓存的容量, 可以用内置的<code>cap</code>函数获取. </p>
<p>同样, 对于内置的<code>len</code>函数, 如果传入的是<code>channel</code>, 那么将返回<code>channel</code>内部缓存队列中有效元素的个数. </p>
<p><code>goroutine</code>可能因为<code>channel</code>无法接收可卡住, 导致<code>goroutine</code>泄露. 泄漏的<code>goroutine</code>并不会被自动回收, 因此确保每个不再需要的<code>goroutine</code>能正常退出是重要的. </p>
<h2 id="并发的循环"><a href="#并发的循环" class="headerlink" title="并发的循环"></a>并发的循环</h2><p>每个子问题都是完全彼此独立的问题叫做易并行问题. 易并行问题是最容易被实现成并行的一类问题, 并且是最能够享受并发带来的好处, 能够随着并行的规模线性地扩展. </p>
<p>为了知道最后一个<code>goroutine</code>什么时候结束, 我们需要一个递增的计数器, 在每一个<code>goroutine</code>启动时加一, 在<code>goroutine</code>退出时减一. 这需要一种特殊的计数器, 这个计数器需要多个<code>goroutine</code>操作时做到安全并且提供在其减为零之前一直等待的一种方法. 这种计数类型被称为<code>sync.WaitGroup</code>. </p>
<h2 id="实例-并发的Web爬虫"><a href="#实例-并发的Web爬虫" class="headerlink" title="实例: 并发的Web爬虫"></a>实例: 并发的<code>Web</code>爬虫</h2><p>注意<code>channel</code>可能造成死锁. </p>
<p>限制<code>goroutine</code>数量的方法. 使用缓存队列. </p>
<p>终止程序的方法. </p>
<p>限制<code>goroutine</code>数量的方法. 保持长活<code>goroutine</code>. </p>
<h2 id="基于select的多路复用"><a href="#基于select的多路复用" class="headerlink" title="基于select的多路复用"></a>基于<code>select</code>的多路复用</h2><p><code>time.Tick</code>函数返回一个<code>channel</code>, 程序会周期性的像一个节拍器一样向这个<code>channel</code>发送事件. 每一个事件的值是一个时间搓. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- ch1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> x := &lt;- ch2:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> ch3 &lt;- y:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>select</code>会等待<code>case</code>中有能够执行的<code>case</code>时去执行. 当条件满足时, <code>select</code>才会去通信并执行<code>case</code>之后的语句; 这时候其它通信是不会执行的. 一个没有任何<code>case</code>的<code>select</code>语句写作<code>select&#123;&#125;</code>, 会永远地等待下去. </p>
<p><code>time.After</code>函数会立即返回一个<code>channel</code>, 并起一个新的<code>goroutine</code>在经过特定的时间后向该<code>channel</code>发送一个独立的值. </p>
<p>如果多个<code>case</code>同时就绪, <code>select</code>会随机地选择一个执行, 这样保证每一个<code>channel</code>都有平等的被<code>select</code>的机会. </p>
<p><code>Tick</code>函数挺方便, 但是只有当程序整个生命周期都需要这个时间时我们使用它才比较合适. 否则应该使用, 下面这种模式. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">&lt;-ticker.C</span><br><span class="line">ticker.Stop()</span><br></pre></td></tr></table></figure>

<p>有时候我们希望能够从<code>channel</code>中发送或者接收值, 并避免因为发送或者接收导致的阻塞, 尤其是当<code>channel</code>没有准备好写或者读时. <code>select</code>语句就可以实现这样的功能. <code>select</code>会有一个<code>default</code>来设置当其它的操作都不能够被马上处理时程序需要执行哪些逻辑. </p>
<p>因为对一个<code>nil</code>的<code>channel</code>发送和接收操作会被永远阻塞, 在<code>select</code>语句中操作<code>nil</code>的<code>channel</code>永远都不会被<code>select</code>到. </p>
<p>这使得我们可以使用<code>nil</code>来激活或者禁用<code>case</code>, 来达成处理其它输入或输出事件时超时和取消的逻辑. </p>
<h2 id="示例-并发的字典遍历"><a href="#示例-并发的字典遍历" class="headerlink" title="示例: 并发的字典遍历"></a>示例: 并发的字典遍历</h2><p><code>nil</code>的<code>channel</code>可以和<code>select</code>配合来达到关闭<code>case</code>的效果. </p>
<h2 id="并发的退出"><a href="#并发的退出" class="headerlink" title="并发的退出"></a>并发的退出</h2><p><code>Go</code>语言并没有提供一个<code>goroutine</code>中终止另一个<code>goroutine</code>的方法, 由于这样会导致<code>goroutine</code>之间的共享变量落在未定义的状态上. </p>
<p>可以创建一个退出<code>channel</code>, 只用退出来, 作为一个广播. </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelled</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- done:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例-聊天服务"><a href="#实例-聊天服务" class="headerlink" title="实例: 聊天服务"></a>实例: 聊天服务</h2><p>学习<code>broadcaster</code>中的<code>select</code>用法.</p>
<h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获得文件的属性</span></span><br><span class="line">os.Stat()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获得目录下的所有文件</span></span><br><span class="line">ioutil.ReadDir()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">读取命令行参数</span></span><br><span class="line">flag.Args()</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/09/03/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/%E4%B9%A6%E7%B1%8D/Go%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-03 21:46:58" itemprop="dateCreated datePublished" datetime="2023-09-03T21:46:58+08:00">2023-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-09-12 23:21:13" itemprop="dateModified" datetime="2023-09-12T23:21:13+08:00">2023-09-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>在<code>Go</code>语言中接口类型的独特之处在于它是满足隐式实现的. 也就是说, 我们没有必要对于给定的具体类型定义所有满足的接口类型; 简单地拥有一些必需的方法就足够了. 这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义; 当我们使用的类型来自于不受我们控制的包时这种设计尤其有用. </p>
<h2 id="接口约定"><a href="#接口约定" class="headerlink" title="接口约定"></a>接口约定</h2><p>接口类型是一种抽象的类型. 它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合; 它们只会展示出它们自己的方法. 也就是说当你看到一个接口类型的值时, 你不知道它时什么, 唯一知道的就是可以通过它的方法来做些什么. </p>
<p>一个类型可以自由的使用另一个满足相同接口的类型来进行替换被称作可替换性(LSP里氏替换). </p>
<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>接口类型具体描述了一系列方法的集合, 一个实现了这些方法的具体类型是这个接口类型的实例. </p>
<p>新的接口类型可以通过组合已有的接口来定义. </p>
<h2 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h2><p>一个类型如果拥有一个接口需要的所有方法, 那么这个类型就实现了这个接口. </p>
<p><code>interface&#123;&#125;</code>被称为空接口类型. 因为空接口类型对实现它的类型没有要求, 所以我们可以将任意一个值赋给空接口类型. </p>
<p>判断是否实现了接口只需要比较具体类型和接口类型的方法, 所以没有必要在具体类型的定义中声明这种关系. </p>
<p>非空的接口类型比如<code>io.Writer</code>经常被指针类型实现, 尤其当一个或多个接口方法像<code>Write</code>方法那样隐式地给接受者带来变化的时候. 一个结构体的指针是非常常见的承载方法的类型. </p>
<h2 id="flag-Value接口"><a href="#flag-Value接口" class="headerlink" title="flag.Value接口"></a><code>flag.Value</code>接口</h2><p>调用<code>flag.CommandLine.Var</code>方法把标记加入到应用的命令行标记集合中. </p>
<h2 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h2><p>概念上讲一个接口的值, 接口值, 由两个部分组成, 一个具体的类型和那个类型的值. 通常被称为接口的动态类型和动态值. 对于像<code>Go</code>语言这种静态类型的语言, 类型是编译期的概念: 因此一个类型不是一个值. 在我们的概念中, 用类型描述符提供每个类型的具体信息, 比如它的名字和方法. 对于一个接口值, 类型部分就用对应的类型描述符来表述. </p>
<p>在<code>Go</code>语言中, 变量总是被一个定义明确的值初始化, 即使接口类型也不例外. 对于一个接口的零值就是它的类型和值的部分都是<code>nil</code>. </p>
<p>一个接口值基于它的动态类型被描述为空或非空. 可以通过<code>==nil</code>或<code>!=nil</code>来判断接口值是是否为空. 调用一个空接口值上的任意方法都会产生<code>panic</code>. </p>
<p>一般来讲, 在编译时我们无法知道一个接口值的动态类型会是什么, 所以通过接口来做调用必须需要使用动态分发. 编译器必须生成一段代码来从类型描述符拿到名为<code>write</code>的方法地址, 在间接调用该方法地址. 调用的接收者就是接口的动态值. </p>
<p>接口值可以用<code>==</code>和<code>!=</code>操作符来做比较. 如果两个接口值都是<code>nil</code>或者二者的动态类型完全一致且二者动态值相等(使用动态类型的<code>==</code>操作符来比较), 那么两个接口值相等. 应为接口值是可以比较的, 所以它们可以作为<code>map</code>的键, 也可以作为<code>switch</code>语句的操作数. </p>
<p>然而, 如果两个接口值的动态类型相同, 但是这个动态类型时不可比较的(比如切片), 将它们进行比较就是失败且<code>panic</code>. </p>
<p>考虑到这点, 接口类型时非常与众不同的. 其它类型那么是安全地可比较类型(如基本类型和指针)要么是完全不可比较的类型(如切片, 映射类型, 和函数), 但是在比较接口值或者包含了接口值的聚合类型时, 我们必须要意识到潜在的<code>panic</code>. 同样的风险也存在与使用接口作为<code>map</code>的键或者<code>switch</code>的操作数. 只能比较你非常确定的动态值是可比较类型的接口值. </p>
<h3 id="警告-一个包含nil指针的接口不是nil接口"><a href="#警告-一个包含nil指针的接口不是nil接口" class="headerlink" title="警告: 一个包含nil指针的接口不是nil接口"></a>警告: 一个包含<code>nil</code>指针的接口不是<code>nil</code>接口</h3><p>空的接口值(其中不包含任何信息)与仅仅动态值为<code>nil</code>的接口值是不一样的. </p>
<h2 id="sort-Interface接口"><a href="#sort-Interface接口" class="headerlink" title="sort.Interface接口"></a><code>sort.Interface</code>接口</h2><p>需要实现<code>sort.Interface</code>接口, 然后使用<code>sort.Sort</code>进行排序, 检查是否有序<code>sort.IsSorted</code>. </p>
<h2 id="http-Handler接口"><a href="#http-Handler接口" class="headerlink" title="http.Handler接口"></a><code>http.Handler</code>接口</h2><p>了解<code>ServerMux</code>. </p>
<h2 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a><code>error</code>接口</h2><p><code>error</code>类型就是一个<code>interface</code>类型, 这个类型有一个返回错误信息的单一方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言是一个使用在接口值上的操作. 语法它看起来像<code>x.(T)</code>, 其中<code>x</code>是一个接口类型的表达式, 而<code>T</code>是一个类型(称为断言类型). 一个类型断言检查它操作对象的动态类型是否和断言的类型匹配. </p>
<p>这里有两种情况. 第一种, 如果断言的类型<code>T</code>是一个具体的类型, 然后断言类型检查<code>x</code>的动态类型是否和<code>T</code>相同. 如果检查成功了, 这个断言的结果是<code>x</code>的动态值, 当然的类型是<code>T</code>. 如果检查失败, 这个检查失败, 将会抛出<code>panic</code>. </p>
<p>第二种情况, 如果断言的类型<code>T</code>是一个接口类型, 然后断言检查是否<code>x</code>的动态类型满足<code>T</code>. 如果检查成功, 这个结果是一个有相同类型和值部分的接口值, 但是结果类型为<code>T</code>. </p>
<p>如果断言操作的对象是一个<code>nil</code>接口值, 那么不论被断言的类型是什么类型断言都会失败. 我们几乎不需要对一个更少限制的接口类型做断言, 因为它表现得就像赋值操作一样, 除了对于<code>nil</code>接口值的情况. </p>
<p>如果类型断言出现在一个预期有两个结果的赋值操作中, 这个操作不会在失败的时候发生<code>panic</code>, 但是用第二个布尔值来表示转换成功或失败. 失败时, 第一个值是被断言类型的零值. </p>
<h2 id="基于类型断言区别错误类型"><a href="#基于类型断言区别错误类型" class="headerlink" title="基于类型断言区别错误类型"></a>基于类型断言区别错误类型</h2><p>通过检查错误消息是否含有特定的子字符串从而来区分错误的类型是非常不成熟的. 一个更可靠的方式是使用一个专门的类型来描述结构化的错误. </p>
<h2 id="类型开关"><a href="#类型开关" class="headerlink" title="类型开关"></a>类型开关</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>, <span class="type">uint</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="type">bool</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:	</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从输入s中解析出一个变量.</span> </span><br><span class="line">fmt.Sscanf()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符串排序</span></span><br><span class="line">sort.Strings()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-leaf"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">霄剑</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">74k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:28</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/55OX5XO55" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
