<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#70B7FD"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-space.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-space.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-space.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab-space.svg" color="#70B7FD">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="为什么要学习设计模式 如何评价代码的好坏 面向对象, 设计原则, 设计模式, 编程规范, 重构都是什么 面向对象, 设计原则, 设计模式, 编程规范, 重构有何关系 什么是面向对象编程和面向对象编程语言 如何判定一门语言是否是面向对象编程语言 面向对象编程和面向对象编程之间的关系 什么是面向对象分析和面向对象设计 面向对象的四大特性是什么, 它们的作用分别是什么 什么是面向过程编程和面向过程编程">
<meta property="og:type" content="article">
<meta property="og:title" content="评价代码质量的标准">
<meta property="og:url" content="http://example.com/2023/11/26/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AF%84%E4%BB%B7%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84%E6%A0%87%E5%87%86/index.html">
<meta property="og:site_name" content="space">
<meta property="og:description" content="为什么要学习设计模式 如何评价代码的好坏 面向对象, 设计原则, 设计模式, 编程规范, 重构都是什么 面向对象, 设计原则, 设计模式, 编程规范, 重构有何关系 什么是面向对象编程和面向对象编程语言 如何判定一门语言是否是面向对象编程语言 面向对象编程和面向对象编程之间的关系 什么是面向对象分析和面向对象设计 面向对象的四大特性是什么, 它们的作用分别是什么 什么是面向过程编程和面向过程编程">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-26T09:56:21.000Z">
<meta property="article:modified_time" content="2024-01-28T10:00:59.061Z">
<meta property="article:author" content="霄剑">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2023/11/26/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AF%84%E4%BB%B7%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84%E6%A0%87%E5%87%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2023/11/26/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AF%84%E4%BB%B7%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84%E6%A0%87%E5%87%86/","path":"2023/11/26/编程思想/设计模式/设计模式之美/评价代码质量的标准/","title":"评价代码质量的标准"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>评价代码质量的标准 | space</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<script async src="/live2d/autoload.js"> </script>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">space</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">14</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">32</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E6%AF%8F%E4%B8%AA%E7%A8%8B%E5%BA%8F%E5%91%98%E9%83%BD%E8%A6%81%E5%B0%BD%E6%97%A9%E5%9C%B0%E5%AD%A6%E4%B9%A0%E5%B9%B6%E6%8E%8C%E6%8F%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">为什么说每个程序员都要尽早地学习并掌握设计模式相关知识?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要学习设计模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%93%AA%E4%BA%9B%E7%BB%B4%E5%BA%A6%E8%AF%84%E4%BB%B7%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84%E5%A5%BD%E5%9D%8F-%E5%A6%82%E4%BD%95%E5%85%B7%E5%A4%87%E5%86%99%E5%87%BA%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="nav-number">2.</span> <span class="nav-text">从哪些维度评价代码质量的好坏? 如何具备写出高质量代码的能力</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA"><span class="nav-number">2.1.</span> <span class="nav-text">最常用的评价标准有哪几个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%86%99%E5%87%BA%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.</span> <span class="nav-text">如何才能写出高质量的代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83-%E9%87%8D%E6%9E%84-%E8%BF%99%E4%BA%94%E8%80%85%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB"><span class="nav-number">3.</span> <span class="nav-text">面向对象, 设计原则, 设计模式, 编程规范, 重构, 这五者有何关系?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">3.2.</span> <span class="nav-text">设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83"><span class="nav-number">3.4.</span> <span class="nav-text">编程规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84"><span class="nav-number">3.5.</span> <span class="nav-text">代码重构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.6.</span> <span class="nav-text">五者之间的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%B8%80-%E5%BD%93%E8%AE%A8%E8%AE%BA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%97%B6%E5%80%99-%E6%88%91%E4%BB%AC%E5%88%B0%E5%BA%95%E5%9C%A8%E8%B0%88%E8%AE%BA%E4%BB%80%E4%B9%88"><span class="nav-number">4.</span> <span class="nav-text">理论一: 当讨论面向对象的时候, 我们到底在谈论什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">4.1.</span> <span class="nav-text">什么是面向对象编程和面向对象编程语言?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E4%B8%80%E4%B8%AA%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%98%AF%E5%90%A6%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">4.2.</span> <span class="nav-text">如何判定一个编程语言是否是面向对象编程语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E5%85%B3%E7%B3%BB"><span class="nav-number">4.3.</span> <span class="nav-text">面向对象编程和面向对象编程语言之间有何关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.4.</span> <span class="nav-text">什么是面向对象分析和面向对象设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85-%E6%8A%BD%E8%B1%A1-%E7%BB%A7%E6%89%BF-%E5%A4%9A%E6%80%81%E5%88%86%E5%88%AB%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%93%AA%E4%BA%9B%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">封装, 抽象, 继承, 多态分别可以解决哪些编程问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">5.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1"><span class="nav-number">5.2.</span> <span class="nav-text">抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">5.3.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">5.4.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%B8%89-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9C%9F%E7%9A%84%E8%BF%87%E6%97%B6%E4%BA%86%E5%90%97"><span class="nav-number">6.</span> <span class="nav-text">理论三: 面向对象相比面向过程有哪些优势? 面向过程真的过时了吗?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">6.1.</span> <span class="nav-text">什么是面向过程编程与面向过程编程语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9B%B8%E6%AF%94%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF"><span class="nav-number">6.2.</span> <span class="nav-text">面向对象编程相比面向过程编程有哪些优势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%9B%9B-%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E7%9C%8B%E4%BC%BC%E6%97%B6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AE%9E%E9%99%85%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">理论四: 哪些代码设计看似时面向对象, 实际是面向过程?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E7%9C%8B%E4%BC%BC%E6%97%B6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AE%9E%E9%99%85%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">哪些代码设计看似时面向对象, 实际是面向过程?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%A5%E7%94%A8getter-setter%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.1.</span> <span class="nav-text">滥用getter, setter方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%A5%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95"><span class="nav-number">7.1.2.</span> <span class="nav-text">滥用全局变量和全局方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%92%8C%E6%96%B9%E6%B3%95%E7%9B%B8%E5%88%86%E7%A6%BB%E7%9A%84%E7%B1%BB"><span class="nav-number">7.1.3.</span> <span class="nav-text">定义数据和方法相分离的类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%AD-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E6%98%93%E5%86%99%E5%87%BA%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E9%A3%8E%E6%A0%BC%E4%BB%A3%E7%A0%81"><span class="nav-number">7.2.</span> <span class="nav-text">在面向对象编程中, 为什么容易写出面向过程风格代码?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%B0%B1%E7%9C%9F%E7%9A%84%E6%B2%A1%E6%9C%89%E7%94%A8%E4%BA%86%E5%90%97"><span class="nav-number">7.3.</span> <span class="nav-text">面向过程编程就真的没有用了吗?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%BA%94-%E6%8E%A5%E5%8F%A3VS%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB-%E5%A6%82%E4%BD%95%E7%94%A8%E6%99%AE%E9%80%9A%E7%9A%84%E7%B1%BB%E6%A8%A1%E6%8B%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.</span> <span class="nav-text">理论五: 接口VS抽象类的区别? 如何用普通的类模拟抽象类和接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="nav-number">8.1.</span> <span class="nav-text">抽象类和接口区别在哪里?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E8%83%BD%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.</span> <span class="nav-text">抽象类和接口能解决什么编程问题?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E4%B8%A4%E4%B8%AA%E8%AF%AD%E6%B3%95%E6%A6%82%E5%BF%B5"><span class="nav-number">8.3.</span> <span class="nav-text">如何模拟抽象类和接口两个语法概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E8%AF%A5%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E8%BF%98%E6%98%AF%E6%8E%A5%E5%8F%A3"><span class="nav-number">8.4.</span> <span class="nav-text">如何决定该用抽象类还是接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%85%AD-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B-%E6%9C%89%E5%BF%85%E8%A6%81%E4%B8%BA%E6%AF%8F%E4%B8%AA%E7%B1%BB%E9%83%BD%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3%E5%90%97"><span class="nav-number">9.</span> <span class="nav-text">理论六: 为什么基于接口而非实现编程? 有必要为每个类都定义接口吗?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E8%AF%BB%E5%8E%9F%E5%88%99%E4%B8%AD%E7%9A%84%E2%80%9D%E6%8E%A5%E5%8F%A3%E2%80%9D%E4%BA%8C%E5%AD%97"><span class="nav-number">9.1.</span> <span class="nav-text">如何解读原则中的”接口”二字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.2.</span> <span class="nav-text">如何设计一个好的接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%B8%BA%E6%AF%8F%E4%B8%AA%E7%B1%BB%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="nav-number">9.3.</span> <span class="nav-text">是否需要为每个类定义接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%B8%83-%E4%B8%BA%E4%BD%95%E8%AF%B4%E8%A6%81%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF-%E5%A6%82%E4%BD%95%E5%86%B3%E5%AE%9A%E8%AF%A5%E7%94%A8%E7%BB%84%E5%90%88%E8%BF%98%E6%98%AF%E7%BB%A7%E6%89%BF"><span class="nav-number">10.</span> <span class="nav-text">理论七: 为何说要多用组合少用继承? 如何决定该用组合还是继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="nav-number">10.1.</span> <span class="nav-text">为什么不推荐使用继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E4%B8%80-%E4%B8%8A-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E4%BA%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84MVC%E6%9E%B6%E6%9E%84%E8%BF%9D%E8%83%8COOP%E5%90%97"><span class="nav-number">11.</span> <span class="nav-text">实战一(上): 业务开发常用的基于贫血模型的MVC架构违背OOP吗?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8E%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.1.</span> <span class="nav-text">什么是基于贫血模型的开发模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8E%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">11.2.</span> <span class="nav-text">什么是基于充血模型的开发模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E4%B8%80-%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E8%99%9A%E6%8B%9F%E9%92%B1%E5%8C%85%E7%B3%BB%E7%BB%9F"><span class="nav-number">12.</span> <span class="nav-text">实战一(下): 如何利用充血模型开发一个虚拟钱包系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E4%BA%8C-%E4%B8%8A-%E5%A6%82%E4%BD%95%E5%AF%B9%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E8%BF%99%E6%A0%B7%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E5%81%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90"><span class="nav-number">13.</span> <span class="nav-text">实战二(上): 如何对接口鉴权这样一个功能开发做面向对象分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB"><span class="nav-number">13.1.</span> <span class="nav-text">重放攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98%E4%BA%8C-%E4%B8%8B-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%92%8C%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E5%8A%9F%E8%83%BD"><span class="nav-number">14.</span> <span class="nav-text">实战二(下): 如何利用面向对象设计和编程开发接口鉴权功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1"><span class="nav-number">15.</span> <span class="nav-text">如何面向对象分析和设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%B8%80-%E5%AF%B9%E4%BA%8E%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E6%9F%90%E4%B8%AA%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%B6%B3%E5%A4%9F%E2%80%9D%E5%8D%95%E4%B8%80%E2%80%9D"><span class="nav-number">16.</span> <span class="nav-text">理论一: 对于单一职责原则, 如何判定某个类的职责是否足够”单一”?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="nav-number">16.1.</span> <span class="nav-text">如何理解单一职责原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%B6%B3%E5%A4%9F%E5%8D%95%E4%B8%80"><span class="nav-number">16.2.</span> <span class="nav-text">如何判断类的职责是否足够单一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%B6%B3%E5%A4%9F%E5%8D%95%E4%B8%80%E7%9A%84%E5%87%A0%E4%B8%AA%E6%8A%80%E5%B7%A7"><span class="nav-number">16.3.</span> <span class="nav-text">判断类的职责是否足够单一的几个技巧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E8%81%8C%E8%B4%A3%E6%98%AF%E5%90%A6%E8%AE%BE%E8%AE%A1%E5%BE%97%E8%B6%8A%E5%8D%95%E4%B8%80%E8%B6%8A%E5%A5%BD"><span class="nav-number">16.4.</span> <span class="nav-text">类的职责是否设计得越单一越好</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%BA%8C-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E2%80%9D%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE-%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD%E2%80%9D-%E6%89%A9%E5%B1%95%E5%92%8C%E4%BF%AE%E6%94%B9%E5%90%84%E6%8C%87%E4%BB%80%E4%B9%88"><span class="nav-number">17.</span> <span class="nav-text">理论二: 如何做到”对扩展开放, 修改关闭”? 扩展和修改各指什么?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9D%E5%AF%B9%E6%89%A9%E5%B1%95%E5%BC%80%E6%94%BE-%E4%BF%AE%E6%94%B9%E5%85%B3%E9%97%AD%E2%80%9D"><span class="nav-number">17.1.</span> <span class="nav-text">如何理解”对扩展开放, 修改关闭”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%B8%89-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E8%B7%9F%E5%A4%9A%E6%80%81%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB-%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81%E8%BF%9D%E8%83%8C%E4%BA%86%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2"><span class="nav-number">18.</span> <span class="nav-text">理论三: 里氏替换跟多态有何区别? 哪些代码违背了里氏替换?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9D%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E2%80%9D"><span class="nav-number">18.1.</span> <span class="nav-text">如何理解”里氏替换”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E2%80%9D%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="nav-number">18.2.</span> <span class="nav-text">“里氏替换”的目的</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%9B%9B-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%B8%89%E7%A7%8D%E5%BA%94%E7%94%A8-%E5%8E%9F%E5%88%99%E4%B8%AD%E7%9A%84%E2%80%9D%E6%8E%A5%E5%8F%A3%E2%80%9D%E8%AF%A5%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="nav-number">19.</span> <span class="nav-text">理论四: 接口隔离原则有哪三种应用? 原则中的”接口”该如何理解?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E2%80%9D%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E2%80%9D"><span class="nav-number">19.1.</span> <span class="nav-text">如何理解”接口隔离原则”?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BA%94%E7%94%A8"><span class="nav-number">19.2.</span> <span class="nav-text">接口隔离原则的三种应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%BA%94-%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-%E8%BF%99%E4%B8%89%E8%80%85%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">20.</span> <span class="nav-text">理论五: 控制反转, 依赖反转, 依赖注入, 这三者有何区别和联系?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9D%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E2%80%9D"><span class="nav-number">20.1.</span> <span class="nav-text">什么是”控制反转”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E2%80%9D"><span class="nav-number">20.2.</span> <span class="nav-text">什么是”依赖注入”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9D%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A1%86%E6%9E%B6%E2%80%9D"><span class="nav-number">20.3.</span> <span class="nav-text">什么是”依赖注入框架”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E2%80%9D%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99%E2%80%9D"><span class="nav-number">20.4.</span> <span class="nav-text">怎么理解”依赖反转原则”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E2%80%9D%E5%92%8C%E2%80%9D%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">20.5.</span> <span class="nav-text">“依赖注入”和”基于接口而非实现编程”的区别和联系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%85%AD-%E6%88%91%E4%B8%BA%E4%BD%95%E8%AF%B4KISS-YANGI%E5%8E%9F%E5%88%99%E7%9C%8B%E4%BC%BC%E7%AE%80%E5%8D%95-%E5%8D%B4%E7%BB%8F%E5%B8%B8%E8%A2%AB%E7%94%A8%E9%94%99"><span class="nav-number">21.</span> <span class="nav-text">理论六: 我为何说KISS, YANGI原则看似简单, 却经常被用错?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFKISS%E5%92%8CYANGI%E5%8E%9F%E5%88%99"><span class="nav-number">21.1.</span> <span class="nav-text">什么是KISS和YANGI原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%B8%83-%E9%87%8D%E5%A4%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B0%B1%E4%B8%80%E5%AE%9A%E8%BF%9D%E8%83%8CDRY%E5%90%97-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A4%8D%E7%94%A8%E6%80%A7"><span class="nav-number">22.</span> <span class="nav-text">理论七: 重复的代码就一定违背DRY吗? 如何提高代码的复用性?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E6%80%A7"><span class="nav-number">22.1.</span> <span class="nav-text">如何提高代码复用性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%85%AB-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E5%AE%9E%E7%8E%B0%E2%80%9D%E9%AB%98%E5%86%85%E8%81%9A-%E6%9D%BE%E8%80%A6%E5%90%88%E2%80%9D"><span class="nav-number">23.</span> <span class="nav-text">理论八: 如何利用迪米特法则实现”高内聚, 松耦合”?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9D%E9%AB%98%E5%86%85%E8%81%9A-%E6%9D%BE%E8%80%A6%E5%90%88%E2%80%9D"><span class="nav-number">23.1.</span> <span class="nav-text">什么是”高内聚, 松耦合”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C%E9%AB%98%E5%86%85%E8%81%9A%E2%80%9D%E5%92%8C%E2%80%9D%E6%9D%BE%E8%80%A6%E5%90%88%E2%80%9D%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">23.2.</span> <span class="nav-text">“高内聚”和”松耦合”之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E2%80%9D%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E2%80%9D"><span class="nav-number">23.3.</span> <span class="nav-text">什么是”迪米特法则”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E8%B7%B5%E2%80%9D%E9%AB%98%E5%86%85%E8%81%9A%E2%80%9D%E5%92%8C%E2%80%9D%E6%9D%BE%E8%80%A6%E5%90%88%E2%80%9D"><span class="nav-number">23.4.</span> <span class="nav-text">如何实践”高内聚”和”松耦合”</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%B8%80-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%A6%81%E9%87%8D%E6%9E%84-%E5%88%B0%E5%BA%95%E9%87%8D%E6%9E%84%E4%BA%9B%E4%BB%80%E4%B9%88-%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E9%87%8D%E6%9E%84"><span class="nav-number">24.</span> <span class="nav-text">理论一: 什么情况下要重构? 到底重构些什么? 又该如何重构?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E7%9A%84%E7%9B%AE%E7%9A%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E6%9E%84"><span class="nav-number">24.1.</span> <span class="nav-text">重构的目的: 为什么要重构?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E7%9A%84%E5%AF%B9%E8%B1%A1-%E5%88%B0%E5%BA%95%E9%87%8D%E6%9E%84%E4%BB%80%E4%B9%88"><span class="nav-number">24.2.</span> <span class="nav-text">重构的对象: 到底重构什么?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%9E%84%E7%9A%84%E6%97%B6%E6%9C%BA-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%87%8D%E6%9E%84"><span class="nav-number">24.3.</span> <span class="nav-text">重构的时机: 什么时候重构?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%BA%8C-%E4%B8%BA%E4%BA%86%E4%BF%9D%E8%AF%81%E9%87%8D%E6%9E%84%E4%B8%8D%E5%87%BA%E9%94%99-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9D%9E%E5%B8%B8%E8%83%BD%E8%90%BD%E5%9C%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E6%89%8B%E6%AE%B5"><span class="nav-number">25.</span> <span class="nav-text">理论二: 为了保证重构不出错, 有哪些非常能落地的技术手段?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">25.1.</span> <span class="nav-text">什么是单元测试?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%99%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">25.2.</span> <span class="nav-text">为什么要写单元测试?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E4%B8%89-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7-%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">26.</span> <span class="nav-text">理论三: 什么是代码的可测试性? 如何写出可测试性好的代码?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7"><span class="nav-number">26.1.</span> <span class="nav-text">什么是代码的可测试性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8B%E8%AF%95%E6%80%A7%E4%B8%8D%E5%8F%8B%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">26.2.</span> <span class="nav-text">常见的测试性不友好的代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%9B%9B-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E5%B0%81%E8%A3%85-%E6%8A%BD%E8%B1%A1-%E6%A8%A1%E5%9D%97%E5%8C%96-%E4%B8%AD%E9%97%B4%E5%B1%82%E7%AD%89%E8%A7%A3%E8%80%A6%E4%BB%A3%E7%A0%81"><span class="nav-number">27.</span> <span class="nav-text">理论四: 如何通过封装, 抽象, 模块化, 中间层等解耦代码?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C%E8%A7%A3%E8%80%A6%E2%80%9D%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81"><span class="nav-number">27.1.</span> <span class="nav-text">“解耦”为什么非常重要?</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="霄剑"
      src="/images/avatar.svg">
  <p class="site-author-name" itemprop="name">霄剑</p>
  <div class="site-description" itemprop="description">醉后不知天在水,满船清梦压星河</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/55OX5XO55" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;55OX5XO55" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/2606863445@qq.com" title="E-Mail → 2606863445@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/26/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BE%8E/%E8%AF%84%E4%BB%B7%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84%E6%A0%87%E5%87%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.svg">
      <meta itemprop="name" content="霄剑">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="space">
      <meta itemprop="description" content="醉后不知天在水,满船清梦压星河">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="评价代码质量的标准 | space">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          评价代码质量的标准
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-26 17:56:21" itemprop="dateCreated datePublished" datetime="2023-11-26T17:56:21+08:00">2023-11-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-01-28 18:00:59" itemprop="dateModified" datetime="2024-01-28T18:00:59+08:00">2024-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/" itemprop="url" rel="index"><span itemprop="name">编程思想</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>38 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <ul>
<li>为什么要学习设计模式</li>
<li>如何评价代码的好坏</li>
<li>面向对象, 设计原则, 设计模式, 编程规范, 重构都是什么</li>
<li>面向对象, 设计原则, 设计模式, 编程规范, 重构有何关系</li>
<li>什么是面向对象编程和面向对象编程语言</li>
<li>如何判定一门语言是否是面向对象编程语言</li>
<li>面向对象编程和面向对象编程之间的关系</li>
<li>什么是面向对象分析和面向对象设计</li>
<li>面向对象的四大特性是什么, 它们的作用分别是什么</li>
<li>什么是面向过程编程和面向过程编程语言</li>
<li>面向对象编程相比面向过程有哪些优势</li>
<li>有在开发过程中, 有哪些操作是在进行面向过程编程</li>
<li>为什么在面向对象编程时, 容易写出面向过程的代码</li>
<li>面向过程编程就真的没有用了吗</li>
<li>抽象类和接口有什么区别? 分别是为了解决什么问题</li>
<li>如何用抽象类和普通类模拟接口</li>
<li>如何决定该用抽象类还是接口</li>
<li>如何理解”基于接口而非实现编程”中”接口”二字</li>
<li>如何定义一个好的接口</li>
<li>是否需要为每个类定义接口</li>
<li>为什么不推荐继承</li>
<li>什么是基于贫血模型的开发模式</li>
<li>什么是基于充血模型的开发模式</li>
<li>什么是重放攻击</li>
<li>如何面向对象分析和设计</li>
<li>如何判断类的职责是否足够单一</li>
<li>判断类的职责是否单一的几个技巧</li>
<li>类的职责是否设计得越单一越好</li>
<li>如何理解”对扩展开放, 修改关闭”</li>
<li>如何理解”里氏替换”</li>
<li>“里氏替换”的目的</li>
<li>如何理解”接口隔离原则”</li>
<li>“接口隔离原则”的三种应用</li>
<li>什么是”控制反转”</li>
<li>什么是”依赖注入”</li>
<li>什么是”依赖注入框架”</li>
<li>怎么理解”依赖反转原则”</li>
<li>什么是<code>KISS</code>原则和<code>YANGI</code>原则</li>
<li>如何提高代码复用性</li>
<li>什么是”高内聚”和”松耦合”</li>
<li>“高内聚”和”松耦合”之间的关系</li>
<li>什么是”迪米特法则”</li>
<li>如何实践”高内聚”和”松耦合”</li>
<li>为什么要重构, 重构的对象是什么, 什么时候进行重构</li>
<li>什么是单元测试, 为什么要编写单元测试</li>
<li>什么是代码的可测试性, 常见的测试性不友好的代码</li>
<li>“解耦”为什么非常重要</li>
</ul>
<span id="more"></span>

<h2 id="为什么说每个程序员都要尽早地学习并掌握设计模式相关知识"><a href="#为什么说每个程序员都要尽早地学习并掌握设计模式相关知识" class="headerlink" title="为什么说每个程序员都要尽早地学习并掌握设计模式相关知识?"></a>为什么说每个程序员都要尽早地学习并掌握设计模式相关知识?</h2><p>如果说数据结构和算法是教你如何写出高效代码, 那设计模式讲的是如何写出可扩展, 可读, 可维护的高质量代码.</p>
<h3 id="为什么要学习设计模式"><a href="#为什么要学习设计模式" class="headerlink" title="为什么要学习设计模式"></a>为什么要学习设计模式</h3><ul>
<li>应对面试中的设计模式相关问题</li>
<li>提高复杂代码的设计和开发能力</li>
<li>让读源码, 学框架事半功倍</li>
<li>为你的职场发展做铺垫</li>
</ul>
<h2 id="从哪些维度评价代码质量的好坏-如何具备写出高质量代码的能力"><a href="#从哪些维度评价代码质量的好坏-如何具备写出高质量代码的能力" class="headerlink" title="从哪些维度评价代码质量的好坏? 如何具备写出高质量代码的能力"></a>从哪些维度评价代码质量的好坏? 如何具备写出高质量代码的能力</h2><h3 id="最常用的评价标准有哪几个"><a href="#最常用的评价标准有哪几个" class="headerlink" title="最常用的评价标准有哪几个"></a>最常用的评价标准有哪几个</h3><ul>
<li><p>可维护性: <strong>可维护性</strong>, 所谓维护就是修改<code>bug</code>, 修改老的代码, 增加新的代码. “代码易维护”就是值能很容易的修改老代码, 在老代码上添加新的功能.</p>
</li>
<li><p>可读性: 这个主要是看代码是否符合编码规范. </p>
</li>
<li><p>可扩展性: 它表示了我们代码应对未来需求变化的能力, 我们在不修改或少量修改原有代码的情况下, 通过扩展的方式添加新的功能代码.</p>
</li>
<li><p>可理解性: 别人能否很容易理解代码. </p>
</li>
<li><p>可复用性: 写的代码能否被很多人使用.</p>
</li>
</ul>
<h3 id="如何才能写出高质量的代码"><a href="#如何才能写出高质量的代码" class="headerlink" title="如何才能写出高质量的代码"></a>如何才能写出高质量的代码</h3><p>要写出满足满足可维护性, 可读性, 可扩展性, 可理解性, 可复用性的代码, 我们需要掌握一些更加细化, 更加能落地的编程方法论, 包括面向对象设计思想, 设计原则, 设计模式, 编码规范, 重构技巧等.</p>
<h2 id="面向对象-设计原则-设计模式-编程规范-重构-这五者有何关系"><a href="#面向对象-设计原则-设计模式-编程规范-重构-这五者有何关系" class="headerlink" title="面向对象, 设计原则, 设计模式, 编程规范, 重构, 这五者有何关系?"></a>面向对象, 设计原则, 设计模式, 编程规范, 重构, 这五者有何关系?</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>主流的编程范式或者时编程风格有三种, 它们分别是面向过程, 面向对象和函数式编程. 面向对象这种编程风格又是这其中最主流的. 现在比较流行的编程语言大部分都是面向对象编程语言. 大部分项目也都是基于面向对象编程风格开发的. 面向对象编程因为其具有丰富的特性(封装, 抽象, 继承, 多态), 可以实现很多复杂的设计思路, 是很多设计原则, 设计模式编码实现的基础.</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p><strong>设计原则</strong>是指导我们代码设计的一些经验总结. </p>
<p>常用的<strong>设计原则</strong>:</p>
<ul>
<li><code>SOLID</code>原则: 单一职责原则</li>
<li><code>SOLID</code>原则: 开闭原则</li>
<li><code>SOLID</code>原则: 里氏替换原则</li>
<li><code>SOLID</code>原则: 接口隔离原则</li>
<li><code>SOLID</code>原则: 依赖装置原则</li>
<li><code>DRY</code>原则, <code>KISS</code>原则, <code>YAGNI</code>原则, <code>LOD</code>法则</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><strong>设计模式</strong>是针对软件开发中经常遇到的一些设计问题, 总结出来的一套解决方案或者设计思路.</p>
<h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><p><strong>编程规范</strong>主要解决的是代码的可读性问题.</p>
<h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>在软件开发过程中, 只要软件在不停地迭代, 就没有一劳永逸的设计. 随着需求的变化, 代码的不停堆砌, 原有的设计必定会存在这样那样的问题. 针对这些问题, 我们就需要进行代码重构. <strong>重构</strong>是软件开发过程中非常重要的一个环节. 持续重构是保持代码质量不下降的有效手段, 能有效比买呢代码腐化到无可救药的地步. </p>
<h3 id="五者之间的关系"><a href="#五者之间的关系" class="headerlink" title="五者之间的关系"></a>五者之间的关系</h3><ol>
<li><p><strong>面向对象编程</strong>因为具有丰富的特性(封装, 抽象, 继承, 多态), 可以实现很多复杂的设计思路, 是很多设计原则, 设计模式等编码实现的基础.</p>
</li>
<li><p><strong>设计原则</strong>是指导我们代码设计的一些经验总结.</p>
</li>
<li><p><strong>设计模式</strong>是针对软件开发过程中遇到的一些问题, 总结出来的一套解决方案或者设计思路. 应用设计模式的主要目的是提高代码的可扩展性. 从抽象程度上来讲, 设计原则比设计默哀时更加抽象. 设计模式更加juti,更加可执行.</p>
</li>
<li><p><strong>编程规范</strong>主要解决的是代码的可读性问题.</p>
</li>
<li><p><strong>重构</strong>作为保持代码质量不下降的有效手段, 利用的就是面向对象, 设计原则, 设计模式, 编程规范这些理论.</p>
</li>
</ol>
<h2 id="理论一-当讨论面向对象的时候-我们到底在谈论什么"><a href="#理论一-当讨论面向对象的时候-我们到底在谈论什么" class="headerlink" title="理论一: 当讨论面向对象的时候, 我们到底在谈论什么?"></a>理论一: 当讨论面向对象的时候, 我们到底在谈论什么?</h2><h3 id="什么是面向对象编程和面向对象编程语言"><a href="#什么是面向对象编程和面向对象编程语言" class="headerlink" title="什么是面向对象编程和面向对象编程语言?"></a>什么是面向对象编程和面向对象编程语言?</h3><p><strong>面向对象编程</strong>是一种编程范式或编程风格. 它以类或者对象作为组织代码的基本单元, 并将封装, 继承, 多态三个特性, 作为代码设计和实现的基石.</p>
<p><strong>面向对象编程语言</strong>是支持类或者对象的语法机制, 并有现成的语法机制, 能方便地实现面向对象三大特性的编程语言. </p>
<h3 id="如何判定一个编程语言是否是面向对象编程语言"><a href="#如何判定一个编程语言是否是面向对象编程语言" class="headerlink" title="如何判定一个编程语言是否是面向对象编程语言"></a>如何判定一个编程语言是否是面向对象编程语言</h3><p>如果严格按照定义, 需要有现成的语法支持类, 对象, 三大特性才能叫作面向对象编程语言. 如果放宽要求的话, 只要某种编程语言支持类, 对象语法机制, 那基本上就可以说这种编程语言是面向对象编程语言了, 并不一定非得要求具有所有的三大特性.</p>
<h3 id="面向对象编程和面向对象编程语言之间有何关系"><a href="#面向对象编程和面向对象编程语言之间有何关系" class="headerlink" title="面向对象编程和面向对象编程语言之间有何关系"></a>面向对象编程和面向对象编程语言之间有何关系</h3><p>面向对象编程一般使用面向对象变成语言来进行, 但是, 不用面向对象编程语言, 我们照样可以进行面向对象编程. 反过来说, 即便我们使用面向对象编程语言, 写出来的代码也不一定是面向对象编程风格的, 也有可能是面向过程编程风格的. </p>
<h3 id="什么是面向对象分析和面向对象设计"><a href="#什么是面向对象分析和面向对象设计" class="headerlink" title="什么是面向对象分析和面向对象设计"></a>什么是面向对象分析和面向对象设计</h3><p>简单点讲, 面向对象分析就是要搞清楚做做什么, 面向对象设计就是要搞清楚怎么做. 两个阶段最终的产出就是类的设计, 包括程序被拆解为哪些类, 每个类有哪些属性方法, 类与类之间如何交互等等. </p>
<h2 id="封装-抽象-继承-多态分别可以解决哪些编程问题"><a href="#封装-抽象-继承-多态分别可以解决哪些编程问题" class="headerlink" title="封装, 抽象, 继承, 多态分别可以解决哪些编程问题"></a>封装, 抽象, 继承, 多态分别可以解决哪些编程问题</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>封装</strong>也叫做信息隐藏或者数据访问保护. 类通过暴露有限的访问接口, 授权外部仅能通过类提供的方式(或者叫函数)来访问信息或者数据. </p>
<p>如果我们对类中属性的访问不做限制, 那任何代码都可以访问, 修改类中的属性, 虽然这样看起来很灵活, 但从另一方面来说, 过度灵活也意味着不可控, 属性可以随意被各种奇葩的方式修改.</p>
<p>除此之外, 类仅仅通过有限的方法暴露必要的操作, 也能提供类的易用性. 如果我们把类属性都暴露给类的调用者, 调用者想要正确地操作这些属性, 就势必要对业务细节有足够的了解. 而这对于调用者来说也是一种负担. 相反, 如果我们将属性分装起来, 暴露少许的几个必要的方法给调用者, 调用者就不需要了解太多背后的细节业务, 用错的概率就减少很多.</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p><strong>封装</strong>主要讲的是如何隐藏信息, 保护数据, 而抽象讲的是如何隐藏方法的具体实现, 让调用者只需要关心方法提供了哪些功能, 并不需要知道这些功能是如何实现的.</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>继承</strong>最大的好处就是代码复用. 我们也可以通过其他方式来解决这个代码复用的问题, 比如利用组合.</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><strong>多态</strong>是指, 子类可以替换父类或接口, 在实际运行过程中, 调用子类实现的方法. 除了利用”继承加方法重写”这种实现方式外, 我们还有其他两种比较常见的实现方式, 一个是利用接口类语法, 另一个是利用<code>duck-typing</code>语法.</p>
<p><code>duck-typing</code>是编程语言中动态类型语言中的一种设计风格, 一个对象的特性不是由父类决定的, 而是通过对象的方法决定.</p>
<p><strong>多态</strong>特性能提高代码的可扩展性和复用性, 是很多设计原则, 设计模式的基础.</p>
<h2 id="理论三-面向对象相比面向过程有哪些优势-面向过程真的过时了吗"><a href="#理论三-面向对象相比面向过程有哪些优势-面向过程真的过时了吗" class="headerlink" title="理论三: 面向对象相比面向过程有哪些优势? 面向过程真的过时了吗?"></a>理论三: 面向对象相比面向过程有哪些优势? 面向过程真的过时了吗?</h2><h3 id="什么是面向过程编程与面向过程编程语言"><a href="#什么是面向过程编程与面向过程编程语言" class="headerlink" title="什么是面向过程编程与面向过程编程语言"></a>什么是面向过程编程与面向过程编程语言</h3><p><strong>面向过程编程</strong>也是一种编程范式或编程风格. 它以函数作为组织代码的基本单元, 以数据与方法相分离为主要的特点. 面向过程风格是一种流程化的编程风格, 通过拼接一组顺序执行的方法来操作数据完成一项功能.</p>
<p><strong>面向过程编程语言</strong>最大的特点时不支持类和对象两个语法概念, 不直接支持面向对象编程的特性(比如封装, 继承, 多态).</p>
<h3 id="面向对象编程相比面向过程编程有哪些优势"><a href="#面向对象编程相比面向过程编程有哪些优势" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势"></a>面向对象编程相比面向过程编程有哪些优势</h3><ul>
<li>OOP更能够应对大规模复杂程序的开发: 面向对象编程是以类为思考对象. 在面向对象编程的时候, 我们并不是一上来就去思考, 如何将复杂的流程拆解为一个一个方法, 而是先思考如何给业务建模, 如何将需求翻译为类, 如何给类之间建立交互关系, 而完成这些工作完全不需要思考错综复杂的处理流程. 当我们有了类的设计之后, 然后再像搭积木一样, 按照处理流程, 将类组织起来形成整个程序. 这种开发模式, 思考问题的方式, 能让我们在应对复杂程序开发的时候, 思路更加清晰. 除此之外, 免洗那个对象编程还提供了一种更加清晰的, 更加模块化的代码组织思路.</li>
<li>OOP风格更易复用, 易扩展, 易维护: 继承可以提高复用性, 多态可以让程序更扩展, 同时还能提高复用性, 封装让程序容易维护.</li>
</ul>
<h2 id="理论四-哪些代码设计看似时面向对象-实际是面向过程"><a href="#理论四-哪些代码设计看似时面向对象-实际是面向过程" class="headerlink" title="理论四: 哪些代码设计看似时面向对象, 实际是面向过程?"></a>理论四: 哪些代码设计看似时面向对象, 实际是面向过程?</h2><h3 id="哪些代码设计看似时面向对象-实际是面向过程"><a href="#哪些代码设计看似时面向对象-实际是面向过程" class="headerlink" title="哪些代码设计看似时面向对象, 实际是面向过程?"></a>哪些代码设计看似时面向对象, 实际是面向过程?</h3><h4 id="滥用getter-setter方法"><a href="#滥用getter-setter方法" class="headerlink" title="滥用getter, setter方法"></a>滥用<code>getter</code>, <code>setter</code>方法</h4><p>面向对象封装的定义是: 通过访问权限控制, 隐藏内部数据, 外部仅能通过类提供的游戏爱你接口访问, 修改内部数据. 所以, 暴露不应该暴露的<code>setter</code>方法, 明显违反了面向对象的封装特性. 数据没有访问权限控制, 任何代码都可以随意修改它, 代码就退化成面向过程编程风格的了.</p>
<h4 id="滥用全局变量和全局方法"><a href="#滥用全局变量和全局方法" class="headerlink" title="滥用全局变量和全局方法"></a>滥用全局变量和全局方法</h4><p>在面向对象编程中, 常见的全局变量有单例类对象, 静态成员, 常量等, 常见的方法有静态方法. 全局变量可以被很多对象访问, 没有办法进行权限访问控制, 而静态方法也没有和数据绑定, 可以操作很多静态变量.</p>
<p><code>Constants</code>类和<code>Utils</code>类是最常见的全局变量和全局方法, 它们其实是几乎是无法避免的. <code>Constants</code>类其实并不会带来太问题, 做好分类或者把常量定义在要使用的类中. <code>Utils</code>类是用来防止以写通用的静态方法, 这些方法要操作很多个类中的数据, 但这些类又不好抽象出一个父类, 这时可以把这些方法放在一起, 作为一个<code>Utils</code>类. 当然, 也可以可以把这些类中的数据抽象出一个父类, 把静态方法写为成员方法也行.</p>
<h4 id="定义数据和方法相分离的类"><a href="#定义数据和方法相分离的类" class="headerlink" title="定义数据和方法相分离的类"></a>定义数据和方法相分离的类</h4><p>在编写WEB项目时, 通常会定义定义<code>BO(Business)</code>, <code>Entity</code>类, 这些类中通常只会定义数据, 不会定义操作它们的方法, 所有操作这些数据的业务逻辑都定义在对应的<code>Controller</code>类, <code>Service</code>类, <code>Repository</code>类中, 这样数据和方法相分离了. 实际上, 这种开发模式叫做基于贫血模型的开发模式.</p>
<h3 id="在面向对象编程中-为什么容易写出面向过程风格代码"><a href="#在面向对象编程中-为什么容易写出面向过程风格代码" class="headerlink" title="在面向对象编程中, 为什么容易写出面向过程风格代码?"></a>在面向对象编程中, 为什么容易写出面向过程风格代码?</h3><p>因为人做一件事情时, 通常是先干什么, 再干什么, 这就是面向过程的思考方式, 自然而然, 也就很容写出面向过程的代码. 而面向对象编程, 是一种自底向上的思考方式, 先把任务分解成子任务, 在组合子任务, 这种模式适合复杂的事情, 人思考简单的事情时, 不会特意思考去分解任务.</p>
<h3 id="面向过程编程就真的没有用了吗"><a href="#面向过程编程就真的没有用了吗" class="headerlink" title="面向过程编程就真的没有用了吗?"></a>面向过程编程就真的没有用了吗?</h3><p>在编写简单的功能时, 使用面向过程编程更方便, 也更快捷. 面向对象编程中编写方法时, 其实就是在使用面向过程编程.</p>
<h2 id="理论五-接口VS抽象类的区别-如何用普通的类模拟抽象类和接口"><a href="#理论五-接口VS抽象类的区别-如何用普通的类模拟抽象类和接口" class="headerlink" title="理论五: 接口VS抽象类的区别? 如何用普通的类模拟抽象类和接口"></a>理论五: 接口<code>VS</code>抽象类的区别? 如何用普通的类模拟抽象类和接口</h2><p>在面向对象编程中, 抽象类和接口是两个经常被用到的语法概念, 是面向对象四大特性, 以及很多设计模式, 设计思想, 设计原则编程思想的基础. 比如, 我们可以使用借口来实现面向对象的抽象特性, 多态特性和基于接口而非实现的设计原则, 使用抽象类来实现面向对象继承特性和模版设计模式等等.</p>
<h3 id="抽象类和接口区别在哪里"><a href="#抽象类和接口区别在哪里" class="headerlink" title="抽象类和接口区别在哪里?"></a>抽象类和接口区别在哪里?</h3><p>从语法特性上来说, 接口不能拥有成员属性, 所有属性都是静态属性. 在java8之前, 接口不能拥有方法体, 8和8之后支持了静态方法和默认方法, 可以有方法体. 继承要求必须实现抽象方法, 而接口要求实现所有方法. 同时, 一个类只能继承一个类, 但是可以实现多个接口. 继承关系是一种<code>is-a</code>关系, 接口表示一种<code>has-a</code>关系, 表示具有某些功能.</p>
<h3 id="抽象类和接口能解决什么编程问题"><a href="#抽象类和接口能解决什么编程问题" class="headerlink" title="抽象类和接口能解决什么编程问题?"></a>抽象类和接口能解决什么编程问题?</h3><p>抽象类会被继承, 可以用来解决代码复用问题, 相比继承普通类, 可以实现自己不实现方法, 但要求子类必须实现的功能, 这种情况在设计父类时经常遇到.</p>
<p>抽象类更多是为了代码复用, 而接口更强调解耦, 隔离接口和具体实现, 提高代码的扩展性. 接口的实现对调用者透明, 不让调用者知道具体实现, 减少调用者使用方法的难度, 也让实现者更自由. 接口中没有成员属性, 只有方法, 因此定义了实现类能有怎样的行为, 是对行为的一种抽象. </p>
<h3 id="如何模拟抽象类和接口两个语法概念"><a href="#如何模拟抽象类和接口两个语法概念" class="headerlink" title="如何模拟抽象类和接口两个语法概念"></a>如何模拟抽象类和接口两个语法概念</h3><p>接口中没有成员变量, 只有方法声明, 没有方法实现, 实现接口的类必须实现接口中的所有方法.. 只要满足这样几点, 从设计的角度上来说, 我们就可以把它称为接口. 也就是抽象类没有成员方法, 所有方法都是抽象方法. 这时从语法特性上来说, 这个抽象类就相当于一个接口.</p>
<p>如果没有抽象类, 如何实现接口呢? 首先, 普通类没有成员属性, 所有的方法直接抛出异常来告诉实现类必须实现这些方法, 最后将构造器设置为<code>protected</code>, 来防止被包外的类初始化.</p>
<h3 id="如何决定该用抽象类还是接口"><a href="#如何决定该用抽象类还是接口" class="headerlink" title="如何决定该用抽象类还是接口"></a>如何决定该用抽象类还是接口</h3><p>实际上, 判断的标准很简单. 如果我们要表示一种<code>is-a</code>的关系, 并且是为了解决代码复用问题, 我们就用抽象类; 如果我们要表示一种<code>has-a</code>关系, 并且是为了解决抽象而非代码复用的问题, 那我们就可以使用接口.</p>
<p>从类的继承层次上来看, 抽象类是一种自下而上的设计思路, 先有子类的代码重复, 然后再抽象成上层父类. 而接口正好相反, 它是一种自上而下的设计思路. </p>
<p>我们在编程的时候, 一般都是先设计接口, 再考虑具体的实现, 发现有子类代码重复, 然后抽象成父类或抽象类.</p>
<h2 id="理论六-为什么基于接口而非实现编程-有必要为每个类都定义接口吗"><a href="#理论六-为什么基于接口而非实现编程-有必要为每个类都定义接口吗" class="headerlink" title="理论六: 为什么基于接口而非实现编程? 有必要为每个类都定义接口吗?"></a>理论六: 为什么基于接口而非实现编程? 有必要为每个类都定义接口吗?</h2><h3 id="如何解读原则中的”接口”二字"><a href="#如何解读原则中的”接口”二字" class="headerlink" title="如何解读原则中的”接口”二字"></a>如何解读原则中的”接口”二字</h3><p>“接口”就是一组”协议”或者”约定”, 是功能提供者提供给使用者的一个功能列表. 从编程语言上来说, 接口可以理解为接口类或者抽象类.</p>
<p>这条原则能非常有效地提高代码质量, 之所以这么说, 那是因为, 应用这条原则, 可以将接口和实现相分离, 封装不稳定的实现, 暴露稳定的接口. 上游系统面向接口而非实现编程, 不依赖不稳定的实现细节, 这样当实现发生变化的时候, 上游系统的代码基本不需要做改动, 以此来降低耦合性, 提高扩展性.</p>
<h3 id="如何设计一个好的接口"><a href="#如何设计一个好的接口" class="headerlink" title="如何设计一个好的接口"></a>如何设计一个好的接口</h3><p>在设计接口的时候, 我们要多思考一下, 这样的接口设计是否足够通用, 时是否能做到在替换具体的接口实现的时候, 不需要任何接口定义的改动.</p>
<h3 id="是否需要为每个类定义接口"><a href="#是否需要为每个类定义接口" class="headerlink" title="是否需要为每个类定义接口"></a>是否需要为每个类定义接口</h3><p>如果上游系统非常稳定, 实现的代码只可能有一种, 这时就没有必要去设计接口, 因为这时接口的实现只有这一种, 并不会体现接口带来的扩展性. 如果上游系统可以依赖多种实现, 这时才需要设计接口.</p>
<h2 id="理论七-为何说要多用组合少用继承-如何决定该用组合还是继承"><a href="#理论七-为何说要多用组合少用继承-如何决定该用组合还是继承" class="headerlink" title="理论七: 为何说要多用组合少用继承? 如何决定该用组合还是继承"></a>理论七: 为何说要多用组合少用继承? 如何决定该用组合还是继承</h2><h3 id="为什么不推荐使用继承"><a href="#为什么不推荐使用继承" class="headerlink" title="为什么不推荐使用继承"></a>为什么不推荐使用继承</h3><p>当一些类需要增加一些特性, 但是另外一些类又不需要增加这些特性时, 如果使用继承, 就需要新增加一个有这些特性的父类. 如果这样的场景很多, 就会有很多这样的父类, 会导致类的继承层次越来深, 继承关系会越来越复杂. 同时, 如果一个类既需要A特性, 也需要B特性, 在不支持多继承的语言中, 会有重复代码.</p>
<h2 id="实战一-上-业务开发常用的基于贫血模型的MVC架构违背OOP吗"><a href="#实战一-上-业务开发常用的基于贫血模型的MVC架构违背OOP吗" class="headerlink" title="实战一(上): 业务开发常用的基于贫血模型的MVC架构违背OOP吗?"></a>实战一(上): 业务开发常用的基于贫血模型的MVC架构违背OOP吗?</h2><h3 id="什么是基于贫血模型的开发模式"><a href="#什么是基于贫血模型的开发模式" class="headerlink" title="什么是基于贫血模型的开发模式"></a>什么是基于贫血模型的开发模式</h3><p>将<code>Entity</code>, <code>BO</code>, <code>VO</code>与<code>Repository</code>, <code>Business</code>, <code>Controller</code> 相互分离. <code>Entity</code>, <code>BO</code>, <code>VO</code>是纯粹的数据结构, 只包含数据, 不包含任何业务逻辑. 它们的操作都放在<code>Repository</code>, <code>Business</code>, <code>Controller</code>中, 这样的模型就是贫血模型. 这种贫血模型将数据与操作分离, 破坏了面向对象的封装特性, 是一种典型的面向过程的编程风格.</p>
<h3 id="什么是基于充血模型的开发模式"><a href="#什么是基于充血模型的开发模式" class="headerlink" title="什么是基于充血模型的开发模式"></a>什么是基于充血模型的开发模式</h3><p>在贫血模型中, 数据和业务逻辑被分割到不同的类中. 充血模型正好相反, 数据和对应的业务逻辑被封装到同一个类中. 因此, 这种充血模型满足面向对象的封装特性, 是典型的面向对象编程风格.</p>
<p>在基于贫血的传统开发模式中, <code>Service</code>层包含<code>Service</code>和<code>BO</code>类两个部分, <code>BO</code>是贫血模型, 只包含数据, 不包含具体的业务逻辑. 业务逻辑集中在<code>Service</code>类中. 在基于充血模型的开发模式中, <code>Service</code>层包含<code>Service</code>类中<code>Domain</code>类两部分. <code>Domain</code>就相当于贫血模型中的<code>BO</code>. 不过, <code>Domain</code>与<code>BO</code>的区别在于它是基于充血模型开发的, 既包含数据, 也包含业务逻辑. 而<code>Service</code>类变得非常单薄. 总结一下就是, 基于贫血模型的传统的开发模式, 重<code>Service</code>轻<code>BO</code>; 基于充血模型的开发模式, 轻<code>Service</code>重<code>Domain</code>.</p>
<h2 id="实战一-下-如何利用充血模型开发一个虚拟钱包系统"><a href="#实战一-下-如何利用充血模型开发一个虚拟钱包系统" class="headerlink" title="实战一(下): 如何利用充血模型开发一个虚拟钱包系统"></a>实战一(下): 如何利用充血模型开发一个虚拟钱包系统</h2><ol>
<li><p>将不用依赖别的<code>Domain</code>的业务逻辑放在<code>Domain</code>中.</p>
</li>
<li><p>使<code>Service</code>类负责与<code>Repository</code>交流.</p>
</li>
</ol>
<h2 id="实战二-上-如何对接口鉴权这样一个功能开发做面向对象分析"><a href="#实战二-上-如何对接口鉴权这样一个功能开发做面向对象分析" class="headerlink" title="实战二(上): 如何对接口鉴权这样一个功能开发做面向对象分析"></a>实战二(上): 如何对接口鉴权这样一个功能开发做面向对象分析</h2><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>拿着完全一样的信息, 发送请求. 这个信息可以不从通信过程中获得. 如果使用了<code>https</code>, 别人是无法获得这些信息的. 重放攻击无法避免, 服务器只能通过信息来判断, 如果信息完全相同, 服务器是无法知道发送方还是不是原来那个. 但是重放攻击可以减轻, 减少信息的有效时间, 可以防止别人拿这个信息一直用.</p>
<h2 id="实战二-下-如何利用面向对象设计和编程开发接口鉴权功能"><a href="#实战二-下-如何利用面向对象设计和编程开发接口鉴权功能" class="headerlink" title="实战二(下): 如何利用面向对象设计和编程开发接口鉴权功能"></a>实战二(下): 如何利用面向对象设计和编程开发接口鉴权功能</h2><p>面向对象分析的产出是详细的需求描述. 面向对象设计的产出是类. </p>
<h2 id="如何面向对象分析和设计"><a href="#如何面向对象分析和设计" class="headerlink" title="如何面向对象分析和设计"></a>如何面向对象分析和设计</h2><p>根据需求描述, 找到其中涉及的功能点, 一个一个罗列出来, 识别其中的动词, 作为候选方法. 然后在把功能点中涉及的名词, 作为候选属性. 然后把操作相同的属性的功能点, 看是否能归位一个类.</p>
<h2 id="理论一-对于单一职责原则-如何判定某个类的职责是否足够”单一”"><a href="#理论一-对于单一职责原则-如何判定某个类的职责是否足够”单一”" class="headerlink" title="理论一: 对于单一职责原则, 如何判定某个类的职责是否足够”单一”?"></a>理论一: 对于单一职责原则, 如何判定某个类的职责是否足够”单一”?</h2><h3 id="如何理解单一职责原则"><a href="#如何理解单一职责原则" class="headerlink" title="如何理解单一职责原则"></a>如何理解单一职责原则</h3><p>一个类只负责完成一个职责或者功能. 不要设计大而全的类, 要设计粒度小, 功能单一的类. 单一职责原则是为了实现代码高内聚, 低耦合, 提高代码的复用性, 可读性, 可维护性.</p>
<h3 id="如何判断类的职责是否足够单一"><a href="#如何判断类的职责是否足够单一" class="headerlink" title="如何判断类的职责是否足够单一"></a>如何判断类的职责是否足够单一</h3><p>不同的应用场景, 不同阶段的需求背景下, 对同一个类的职责是否单一的判定, 可能都是不一样的. 在某种应用场景或者当下的需求背景下, 一个类的设计可以已经满足单一职责原则了, 但如果换个应用场景或者在未来的某个需求背景下, 可能就不满足了, 需要继续拆分成粒度更细的类.</p>
<p>评价一个类的职责是否足够单一, 我们并没有一个非常明确的, 可以量化的标准, 可以说, 这是件非常主观, 仁者见仁智者见智的事情. 实际上, 在真正的软件开发中, 我们也没有必要过于未雨绸缪, 过度设计. 所以, 我们可以先写一个粗粒度的类, 满足业务需求. 随着业务的发展, 如果粗粒度的类越来越庞大, 代码越来越多, 这个时候, 我们就可以将这个粗粒度的类, 拆分成几个粒度更细的类. 这就是所谓的持续重构.</p>
<h3 id="判断类的职责是否足够单一的几个技巧"><a href="#判断类的职责是否足够单一的几个技巧" class="headerlink" title="判断类的职责是否足够单一的几个技巧"></a>判断类的职责是否足够单一的几个技巧</h3><ul>
<li>类中的代码行数, 函数或属性过多, 会影响代码的可读性和可维护性, 我们就需要考虑对类进行拆分.</li>
<li>类依赖的其他类过多, 不符合高内聚, 低耦合的设计思想, 我们就需要考虑对类进行拆分.</li>
<li>比较难给类起一个合适的名字, 很难用一个业务名词概括, 或者只能用一些笼统的<code>Manager</code>, <code>Context</code>之类的词语来命名, 这就说明类的职责定义得可能不够清晰.</li>
<li>类中大量的方法都是集中操作类中的某几个属性, 那就可以考虑将这几个属性和对应的方法拆出来.</li>
</ul>
<h3 id="类的职责是否设计得越单一越好"><a href="#类的职责是否设计得越单一越好" class="headerlink" title="类的职责是否设计得越单一越好"></a>类的职责是否设计得越单一越好</h3><p>比如说一个类有编码和解码两个方法, 你可以说这是两个功能, 给它分别放入到编码类和解码类中. 但是编码和解码通常是有联系的, 用一种方式编码, 就只能用特定的方式解码, 如果分开就有可能出现编码和解码不匹配的情况. 这个就是不满足高内聚带来的后果.</p>
<h2 id="理论二-如何做到”对扩展开放-修改关闭”-扩展和修改各指什么"><a href="#理论二-如何做到”对扩展开放-修改关闭”-扩展和修改各指什么" class="headerlink" title="理论二: 如何做到”对扩展开放, 修改关闭”? 扩展和修改各指什么?"></a>理论二: 如何做到”对扩展开放, 修改关闭”? 扩展和修改各指什么?</h2><h3 id="如何理解”对扩展开放-修改关闭”"><a href="#如何理解”对扩展开放-修改关闭”" class="headerlink" title="如何理解”对扩展开放, 修改关闭”"></a>如何理解”对扩展开放, 修改关闭”</h3><p>具体一点来说就是, 添加一个新的功能应该是, 在已有代码基础上扩展代码(新增模块, 类, 方法等), 而非修改已有代码(修改模块, 类, 方法等). 开闭原则并不是完全杜绝修改, 而是以最小的修改代码的代价来完成新功能的开发. 同时, 同样的代码改动, 在粗代码粒度下, 可能被认定为”修改”; 在细代码粒度下, 可能又被认定为”扩展”.</p>
<h2 id="理论三-里氏替换跟多态有何区别-哪些代码违背了里氏替换"><a href="#理论三-里氏替换跟多态有何区别-哪些代码违背了里氏替换" class="headerlink" title="理论三: 里氏替换跟多态有何区别? 哪些代码违背了里氏替换?"></a>理论三: 里氏替换跟多态有何区别? 哪些代码违背了里氏替换?</h2><h3 id="如何理解”里氏替换”"><a href="#如何理解”里氏替换”" class="headerlink" title="如何理解”里氏替换”"></a>如何理解”里氏替换”</h3><p>子类对象能替换程序中父类对象出现的任何地方, 并且保证原来程序的正确性不被破坏. 从定义描述和代码实现上看, 多态和里氏替换有点类似, 但它们关注的角度是不一样的. 多态面向对象语言的一种语法, 我们可以使用它来解决问题, 是一种代码实现的思路. 里氏替换是一种设计原则, 是用来指导继承关系中子类该如何设计, 子类的设计要保证在替换父类的时候, 不改变原有程序的逻辑以及破坏原有程序的正确性.</p>
<h3 id="“里氏替换”的目的"><a href="#“里氏替换”的目的" class="headerlink" title="“里氏替换”的目的"></a>“里氏替换”的目的</h3><p>里氏替换是为了要求子类遵守父类方法的功能描述.</p>
<h2 id="理论四-接口隔离原则有哪三种应用-原则中的”接口”该如何理解"><a href="#理论四-接口隔离原则有哪三种应用-原则中的”接口”该如何理解" class="headerlink" title="理论四: 接口隔离原则有哪三种应用? 原则中的”接口”该如何理解?"></a>理论四: 接口隔离原则有哪三种应用? 原则中的”接口”该如何理解?</h2><h3 id="如何理解”接口隔离原则”"><a href="#如何理解”接口隔离原则”" class="headerlink" title="如何理解”接口隔离原则”?"></a>如何理解”接口隔离原则”?</h3><p>客户端不应该强迫依赖它不需要的接口. 接口隔离原则可以看作实现单一职责的一种方式, 通过调用者如何使用接口来间接地判定. 如果调用者只使用部分”接口”或”接口”的部分功能, 那”接口”的设计就不够职责单一.</p>
<h3 id="接口隔离原则的三种应用"><a href="#接口隔离原则的三种应用" class="headerlink" title="接口隔离原则的三种应用"></a>接口隔离原则的三种应用</h3><ul>
<li>把”接口”认为是模块或类提供的一组<code>api</code>.</li>
<li>把”接口”认为是语言中类实现的接口.</li>
<li>把”接口”认为是一个方法声明.</li>
</ul>
<h2 id="理论五-控制反转-依赖反转-依赖注入-这三者有何区别和联系"><a href="#理论五-控制反转-依赖反转-依赖注入-这三者有何区别和联系" class="headerlink" title="理论五: 控制反转, 依赖反转, 依赖注入, 这三者有何区别和联系?"></a>理论五: 控制反转, 依赖反转, 依赖注入, 这三者有何区别和联系?</h2><h3 id="什么是”控制反转”"><a href="#什么是”控制反转”" class="headerlink" title="什么是”控制反转”"></a>什么是”控制反转”</h3><p>框架提供了一个扩展的代码骨架, 用来组装对象, 管理整个执行流程. 程序员利用框架进行开发的时候, 只需要往预留的扩展点上, 添加跟自己业务相关的代码, 就可以利用框架来驱动整个程序流程的执行.</p>
<p>这里的”控制”指的是对程序执行流程的控制, 而”反转”指的是在没有使用框架之前, 程序员自己控制整个程序的执行. 在使用框架之后, 整个程序的执行流程可以通过框架来控制. 流程的控制权从程序员”反转”到了框架.</p>
<p>实际上, 实现控制反转的方法很多, 除了刚才例子中所示的类似于模版设计模式的方法之外, 还有依赖注入等方法. 所以, 控制反转并不是一种具体的实现技巧, 而是一个比较笼统的设计思想, 一般用来指导框架层面的设计.</p>
<h3 id="什么是”依赖注入”"><a href="#什么是”依赖注入”" class="headerlink" title="什么是”依赖注入”"></a>什么是”依赖注入”</h3><p>依赖注入和控制反转恰恰相反, 它是一种具体的编码技巧.不通过<code>new()</code>的方式在类内部创建依赖类的对象, 而是将依赖的类对象在外部创建好之后, 通过构造函数, 函数参数等方式传递(或注入)给类使用.</p>
<h3 id="什么是”依赖注入框架”"><a href="#什么是”依赖注入框架”" class="headerlink" title="什么是”依赖注入框架”"></a>什么是”依赖注入框架”</h3><p>在采用依赖注入实现的类中, 虽然我们不需要用类似<code>hard code</code>的方式, 在类内部通过<code>new</code>来创建依赖对象, 但是, 这个创建对象, 组装(或注入)对象的工作仅仅是被移动到更上层代码而已, 还是需要我们程序员自己来实现.</p>
<p>在实际的软件开发中, 一些项目可能会涉及几十, 上百, 甚至几百个类, 类对象的创建和依赖注入会非常复杂. 如果这部分工作都是靠程序员自己写代码来完成, 容易出错且开发成本也比较高. 而对象创建和依赖注入的工作, 本身跟具体的业务无关, 我们完全可以抽象成框架来自动完成.</p>
<p>这个框架就是”依赖注入框架”. 我们只要通过依赖注入框架提供的扩展点, 简单配置一下所有需要创建的类对象, 类和类之间的依赖关系, 就可以实现有框架来自动创建对象, 管理对象的生命周期, 依赖注入等原本需要程序员来做的事情.</p>
<h3 id="怎么理解”依赖反转原则”"><a href="#怎么理解”依赖反转原则”" class="headerlink" title="怎么理解”依赖反转原则”"></a>怎么理解”依赖反转原则”</h3><p>高层模块不要依赖低层模块. 高层模块和低层模块应该通过抽象来相互依赖. 除此之外, 抽象不要依赖具体实现细节, 具体实现细节依赖抽象.</p>
<h3 id="“依赖注入”和”基于接口而非实现编程”的区别和联系"><a href="#“依赖注入”和”基于接口而非实现编程”的区别和联系" class="headerlink" title="“依赖注入”和”基于接口而非实现编程”的区别和联系"></a>“依赖注入”和”基于接口而非实现编程”的区别和联系</h3><p>依赖注入是一种具体的编程技巧, 关注的是对象创建和类之间的关系, 提高了代码的扩展性, 我们可以灵活地替换依赖的类.</p>
<p>基于接口而非实现编程是一种设计原则, 关注抽象和实现, 上下游调用的稳定性, 目的是降低耦合性, 提高扩展性.</p>
<p>它们都是基于开闭原则思路, 提高代码扩展性.</p>
<h2 id="理论六-我为何说KISS-YANGI原则看似简单-却经常被用错"><a href="#理论六-我为何说KISS-YANGI原则看似简单-却经常被用错" class="headerlink" title="理论六: 我为何说KISS, YANGI原则看似简单, 却经常被用错?"></a>理论六: 我为何说<code>KISS</code>, <code>YANGI</code>原则看似简单, 却经常被用错?</h2><h3 id="什么是KISS和YANGI原则"><a href="#什么是KISS和YANGI原则" class="headerlink" title="什么是KISS和YANGI原则"></a>什么是<code>KISS</code>和<code>YANGI</code>原则</h3><p><code>KISS</code>原则做事情尽量保持简单, <code>YANGI</code>原则你不需要它, 遇到现在不需要做的事情就不要做, 留下扩展点就行.</p>
<h2 id="理论七-重复的代码就一定违背DRY吗-如何提高代码的复用性"><a href="#理论七-重复的代码就一定违背DRY吗-如何提高代码的复用性" class="headerlink" title="理论七: 重复的代码就一定违背DRY吗? 如何提高代码的复用性?"></a>理论七: 重复的代码就一定违背<code>DRY</code>吗? 如何提高代码的复用性?</h2><p><code>DRY</code>不用重复你自己. 重复的代码通常违背<code>DRY</code>原则, 可以先用一个, 如何以后有特殊处理, 在抽出来就行.</p>
<h3 id="如何提高代码复用性"><a href="#如何提高代码复用性" class="headerlink" title="如何提高代码复用性"></a>如何提高代码复用性</h3><ul>
<li>减少代码耦合</li>
<li>满足单一职责原则</li>
<li>业务代码和业务代码逻辑分离</li>
<li>继承, 多态, 抽象, 封装</li>
<li>应用模版等设计模式</li>
</ul>
<h2 id="理论八-如何利用迪米特法则实现”高内聚-松耦合”"><a href="#理论八-如何利用迪米特法则实现”高内聚-松耦合”" class="headerlink" title="理论八: 如何利用迪米特法则实现”高内聚, 松耦合”?"></a>理论八: 如何利用迪米特法则实现”高内聚, 松耦合”?</h2><h3 id="什么是”高内聚-松耦合”"><a href="#什么是”高内聚-松耦合”" class="headerlink" title="什么是”高内聚, 松耦合”"></a>什么是”高内聚, 松耦合”</h3><p>所谓”高内聚”, 就是指相近的功能应该放到同一个类中, 不相近的功能不要放到同一个类中. 相近的功能放在一起, 容易管理和维护. 单一职责原则就是实现”高内聚”非常有效的手段.</p>
<p>所谓”松耦合”, 在代码中, 类与类之间的依赖关系简单清晰, 同时, 即使两个类之间有依赖关系, 一个类的改动不会或者很少导致依赖类的代码改动. 依赖注入, 接口隔离, 基于接口而非实现编程, 以及迪米特法则, 都是为了实现代码的松耦合.</p>
<h3 id="“高内聚”和”松耦合”之间的关系"><a href="#“高内聚”和”松耦合”之间的关系" class="headerlink" title="“高内聚”和”松耦合”之间的关系"></a>“高内聚”和”松耦合”之间的关系</h3><p>“高内聚”是用来指导类本身的设计, “松耦合”是用来指导类于类之间依赖的关系, 这两者并非完全独立不相干. 高内聚有助于松耦合, 松耦合又需要高内聚的支持.</p>
<h3 id="什么是”迪米特法则”"><a href="#什么是”迪米特法则”" class="headerlink" title="什么是”迪米特法则”"></a>什么是”迪米特法则”</h3><p>每个模块只应该了解那些与它关系密切的模块的有限知识. 具体一点说, 不该有直接依赖关系的类之间, 不要有依赖; 有依赖关系的类之间, 尽量只依赖必要的接口.</p>
<h3 id="如何实践”高内聚”和”松耦合”"><a href="#如何实践”高内聚”和”松耦合”" class="headerlink" title="如何实践”高内聚”和”松耦合”"></a>如何实践”高内聚”和”松耦合”</h3><ol>
<li>当两个类之间不应该有直接联系时, 使用一个中间类来联系两个类</li>
<li>当一个类要求”高耦合”, 但别的类又要求”松耦合”时, 可以通过实现接口来实现</li>
</ol>
<h2 id="理论一-什么情况下要重构-到底重构些什么-又该如何重构"><a href="#理论一-什么情况下要重构-到底重构些什么-又该如何重构" class="headerlink" title="理论一: 什么情况下要重构? 到底重构些什么? 又该如何重构?"></a>理论一: 什么情况下要重构? 到底重构些什么? 又该如何重构?</h2><h3 id="重构的目的-为什么要重构"><a href="#重构的目的-为什么要重构" class="headerlink" title="重构的目的: 为什么要重构?"></a>重构的目的: 为什么要重构?</h3><p><strong>重构</strong>是一种对软件内部结构的改善, 目的是在不改变软件的可见行为的情况下, 使其更易理解, 修改成本更低.</p>
<p><strong>重构</strong>是为了保证代码的质量. 防止代码质量差导致出现很多问题, 同时重构还可以提升代码质量, 让最初代码的质量变得越来越好.</p>
<h3 id="重构的对象-到底重构什么"><a href="#重构的对象-到底重构什么" class="headerlink" title="重构的对象: 到底重构什么?"></a>重构的对象: 到底重构什么?</h3><p>根据重构的规模, 我们可以笼统地分为大规模高层次重构(“大型重构”)和小规模低层次的重构(“小型重构”).</p>
<p><strong>大型重构</strong>指的是对顶层代码设计的重构, 包括: 系统, 模块, 代码结构, 类与类之间的关系等的重构, 重构的手段有: 分层, 模块化, 抽象可复用组件等等. 这类重构的工具就是设计思想, 原则和模式.</p>
<p><strong>小型重构</strong>指的是对代码细节的重构, 主要是针对类, 函数, 变量等代码级别的重构, 比如规范命名, 规范注释, 消除超大类和函数, 提取重复代码等等. 小型重构更多利用的是<strong>编程规范</strong>.</p>
<h3 id="重构的时机-什么时候重构"><a href="#重构的时机-什么时候重构" class="headerlink" title="重构的时机: 什么时候重构?"></a>重构的时机: 什么时候重构?</h3><p>提倡的重构策略是持续重构. 平时没有事情的时候, 可以看看项目中有哪些写得不够好的, 可以优化的代码, 主动去重构一下. 或者, 在修改, 添加某个功能的时候, 也可以顺手把不符合代码规范, 不好的设计重构一下. 总之, 就像把单元测试, 代码检视作为开发的一部分, 如果能把持续重构作为开发的一部分, 成为一种开发习惯, 对项目, 对自己都会很有好处.</p>
<h2 id="理论二-为了保证重构不出错-有哪些非常能落地的技术手段"><a href="#理论二-为了保证重构不出错-有哪些非常能落地的技术手段" class="headerlink" title="理论二: 为了保证重构不出错, 有哪些非常能落地的技术手段?"></a>理论二: 为了保证重构不出错, 有哪些非常能落地的技术手段?</h2><p>如何保证重构不出错, 熟悉掌握各种设计思想, 原则, 模式, 还需要对所重构的业务和代码有足够的了解. 除了这些个人能力因素之外, 最可落地执行, 最有效的保证重构不出错的手段是<strong>单元测试</strong>. 当重构完成之后, 如果新的代码仍能通过单元测试, 那就说明代码原有逻辑的正确性未被破坏, 原有的外部可见行为未变. 当然, 这需要之前的单元测试存在且有效. 还有一个手段是<strong>代码检视</strong>.</p>
<h3 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试?"></a>什么是单元测试?</h3><p><strong>单元测试</strong>有研发工程师自己编写, 用来测试自己写的代码的正确性. 我们通常将它跟集成测试放到一块来对比. 单元测试相对集成测试来说, 测试的粒度更小一些. 集成测试的对象是整个系统或者某个功能模块, 比如测试用户注册, 登录功能是否正常, 是一种端到端的测试. 而单元测试的测试对象是类或者函数, 用来测试一个类和函数是否都按照预期的逻辑执行. 这是代码层级的测试.</p>
<h3 id="为什么要写单元测试"><a href="#为什么要写单元测试" class="headerlink" title="为什么要写单元测试?"></a>为什么要写单元测试?</h3><ul>
<li>单元测试相当于一次”自我代码检视”, 能有效地帮你发现代码中的<code>bug</code>和代码设计上的不合理</li>
<li>单元测试可以通过<code>桩</code>很轻松写出某些集成测试不好测试的场景, 是对集成测试的有力补充</li>
<li>单元测试是重构的基础, 没有单元测试, 重构无法保证正确性</li>
</ul>
<h2 id="理论三-什么是代码的可测试性-如何写出可测试性好的代码"><a href="#理论三-什么是代码的可测试性-如何写出可测试性好的代码" class="headerlink" title="理论三: 什么是代码的可测试性? 如何写出可测试性好的代码?"></a>理论三: 什么是代码的可测试性? 如何写出可测试性好的代码?</h2><h3 id="什么是代码的可测试性"><a href="#什么是代码的可测试性" class="headerlink" title="什么是代码的可测试性"></a>什么是代码的可测试性</h3><p>粗略地讲, 所谓代码的可测试性, 就是针对代码编写单元测试的难易程度. 对于一段代码, 如果很难为其编写单元测试, 或者单元测试写起来很费劲, 需要依靠单元测试框架中很高级的特性, 那往往就意味着代码设计得不够合理, 代码的可测试性不好. </p>
<p>编写可测试性代码的最有效的手段是依赖注入, 通过依赖注入, 在写单元测试时, 可以通过<code>mock</code>的方法解决外部依赖.</p>
<h3 id="常见的测试性不友好的代码"><a href="#常见的测试性不友好的代码" class="headerlink" title="常见的测试性不友好的代码"></a>常见的测试性不友好的代码</h3><ul>
<li>代码中包含未决逻辑行为</li>
<li>滥用可变全局变量</li>
<li>滥用静态方法</li>
<li>使用复杂的继承关系</li>
<li>高度耦合的代码</li>
</ul>
<h2 id="理论四-如何通过封装-抽象-模块化-中间层等解耦代码"><a href="#理论四-如何通过封装-抽象-模块化-中间层等解耦代码" class="headerlink" title="理论四: 如何通过封装, 抽象, 模块化, 中间层等解耦代码?"></a>理论四: 如何通过封装, 抽象, 模块化, 中间层等解耦代码?</h2><h3 id="“解耦”为什么非常重要"><a href="#“解耦”为什么非常重要" class="headerlink" title="“解耦”为什么非常重要?"></a>“解耦”为什么非常重要?</h3><p>不管阅读代码还是修改代码, “高内聚, 松耦合”的特性能让我们聚焦在某一模块或类中, 不需要了解太多其他模块或类的代码, 让我们的焦点不至于过于发散, 降低阅读和修改代码的难度. 而且, 因为依赖关系简单, 耦合小, 修改代码不至于牵一发而动全身, 代码改动比较集中, 引入<code>bug</code>的风险也就减少了很多. 同时, “高内聚, 松耦合”的代码可测试性也更加好, 容易<code>mock</code>或者很少需要<code>mock</code>外部依赖的模块或者类.</p>

    </div>

    
    
    
      <div>
  <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
</div>


    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 设计模式</a>
          </div>
	  <script type="text/javascript">
            var tagsall=document.getElementsByClassName("post-tags")
            for (var i = tagsall.length - 1; i >= 0; i--){
                var tags=tagsall[i].getElementsByTagName("a");
                for (var j = tags.length - 1; j >= 0; j--) {
                    var golden_ratio = 0.618033988749895;
                    var s = 0.5;
                    var v = 0.999;
                    var h = golden_ratio + Math.random()*0.8 - 0.5;
                    var h_i = parseInt(h * 6);
                    var f = h * 6 - h_i;
                    var p = v * (1 - s);
                    var q = v * (1 - f * s);
                    var t = v * (1 - (1 - f) * s);
                    var r, g, b;
                    switch (h_i) {
                        case 0:
                            r = v;
                            g = t;
                            b = p;
                            break;
                        case 1:
                            r = q;
                            g = v;
                            b = p;
                            break;
                        case 2:
                            r = p;
                            g = v;
                            b = t;
                            break;
                        case 3 :
                            r = p;
                            g = q;
                            b = v;
                            break;
                        case 4:
                            r = t;
                            g = p;
                            b = v;
                            break;
                        case 5:
                            r = v;
                            g = p;
                            b = q;
                            break;
                        default:
                            r = 1;
                            g = 1;
                            b = 1;
                      }
                    tags[j].style.background = "rgba("+parseInt(r*255)+","+parseInt(g*255)+","+parseInt(b*255)+","+0.5+")";
                }
            }
            </script>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/06/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/Kubernetes/Kubernetes_In_Action/%E4%BF%9D%E9%9A%9C%E9%9B%86%E7%BE%A4%E5%86%85%E8%8A%82%E7%82%B9%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" rel="prev" title="保障集群内节点和网络安全">
                  <i class="fa fa-chevron-left"></i> 保障集群内节点和网络安全
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/12/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0(pytorch)/%E5%BC%95%E8%A8%80/" rel="next" title="引言">
                  引言 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-leaf"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">霄剑</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">72k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:21</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/55OX5XO55" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
